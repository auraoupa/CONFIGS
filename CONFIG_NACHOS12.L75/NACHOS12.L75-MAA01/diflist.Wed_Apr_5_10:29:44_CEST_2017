diff -bic /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/LIM_SRC_2/iceini_2.F90 /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/LIM_SRC_2/iceini_2.F90
*** /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/LIM_SRC_2/iceini_2.F90	Tue Apr  4 14:51:16 2017
--- /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/LIM_SRC_2/iceini_2.F90	Fri Feb 24 15:39:23 2017
***************
*** 39,45 ****
  
     !!----------------------------------------------------------------------
     !! NEMO/LIM2 4.0 , UCL - NEMO Consortium (2011)
!    !! $Id: iceini_2.F90 5385 2015-06-09 13:50:42Z cetlod $
     !! Software governed by the CeCILL licence     (NEMOGCM/NEMO_CeCILL.txt)
     !!----------------------------------------------------------------------
  CONTAINS
--- 39,45 ----
  
     !!----------------------------------------------------------------------
     !! NEMO/LIM2 4.0 , UCL - NEMO Consortium (2011)
!    !! $Id: iceini_2.F90 6140 2015-12-21 11:35:23Z timgraham $
     !! Software governed by the CeCILL licence     (NEMOGCM/NEMO_CeCILL.txt)
     !!----------------------------------------------------------------------
  CONTAINS
***************
*** 120,126 ****
        NAMELIST/namicerun/ cn_icerst_in, cn_icerst_indir, cn_icerst_out, cn_icerst_outdir, &
                            ln_limdyn, ln_limdmp, acrit, hsndif, hicdif
        INTEGER  ::   ios                 ! Local integer output status for namelist read
-       CHARACTER(LEN=20) :: cl_no
        !!-------------------------------------------------------------------
        !                    
        REWIND( numnam_ice_ref )              ! Namelist namicerun in reference namelist : Parameters for ice
--- 120,125 ----
***************
*** 132,149 ****
  902   IF( ios /= 0 ) CALL ctl_nam ( ios , 'namicerun in configuration namelist', lwp )
        IF(lwm) WRITE ( numoni, namicerun )
        !
-       ! Add extension (job number to the restart dir. Differ for restart input and restart output
- !{ DRAKKAR modification : NEMO reads restart files :<CN_ICERST_INDIR>.<<nn_no-1>>/<CN_ICERST_IN>-<<nn_no -1 >>_<RANK>.nc
-       WRITE(cl_no,*) nn_no-1 ; cl_no = TRIM(ADJUSTL(cl_no) )
-       cn_icerst_indir=TRIM(cn_icerst_indir)//'.'//TRIM(cl_no)
-       cn_icerst_in= TRIM(cn_icerst_in)//'-'//TRIM(cl_no)
- 
- !  DRAKKAR modification : NEMO write restart files :<CN_ICERST_OUTDIR>.<<nn_no>>/<CN_ICERST_OUT>-<<nn_no >>_<RANK>.nc
-       WRITE(cl_no,*) nn_no   ; cl_no = TRIM(ADJUSTL(cl_no) )
-       cn_icerst_outdir=TRIM(cn_icerst_outdir)//'.'//TRIM(cl_no)
-       cn_icerst_out= TRIM(cn_icerst_out)//'-'//TRIM(cl_no)
- !}
- 
        IF(lwp) THEN                              ! control print
           WRITE(numout,*)
           WRITE(numout,*) 'ice_run : ice share parameters for dynamics/advection/thermo of sea-ice'
--- 131,136 ----
diff -bic /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/LIM_SRC_2/limdmp_2.F90 /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/LIM_SRC_2/limdmp_2.F90
*** /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/LIM_SRC_2/limdmp_2.F90	Tue Apr  4 14:51:16 2017
--- /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/LIM_SRC_2/limdmp_2.F90	Fri Feb 24 15:39:23 2017
***************
*** 33,39 ****
  #  include "vectopt_loop_substitute.h90"
     !!----------------------------------------------------------------------
     !! NEMO/LIM 3.3 , UCL-NEMO-consortium (2010) 
!    !! $Id: limdmp_2.F90 4624 2014-04-28 12:09:03Z acc $
     !! Software governed by the CeCILL licence     (NEMOGCM/NEMO_CeCILL.txt)
     !!----------------------------------------------------------------------
  CONTAINS
--- 33,39 ----
  #  include "vectopt_loop_substitute.h90"
     !!----------------------------------------------------------------------
     !! NEMO/LIM 3.3 , UCL-NEMO-consortium (2010) 
!    !! $Id: limdmp_2.F90 5836 2015-10-26 14:49:40Z cetlod $
     !! Software governed by the CeCILL licence     (NEMOGCM/NEMO_CeCILL.txt)
     !!----------------------------------------------------------------------
  CONTAINS
***************
*** 58,64 ****
        !
        IF( kt == nit000 ) THEN 
           IF(lwp) WRITE(numout,*)
!          IF(lwp) WRITE(numout,*) 'lim_dmp_2 : Ice thickness and lead fraction restoring'
           IF(lwp) WRITE(numout,*) '~~~~~~~~~~'
           !
           ! ice_resto_init create resto_ice (in 1/s) for restoring ice parameters near open boundaries.
--- 58,64 ----
        !
        IF( kt == nit000 ) THEN 
           IF(lwp) WRITE(numout,*)
!          IF(lwp) WRITE(numout,*) 'lim_dmp_2 : Ice thickness and ice concentration restoring'
           IF(lwp) WRITE(numout,*) '~~~~~~~~~~'
           !
           ! ice_resto_init create resto_ice (in 1/s) for restoring ice parameters near open boundaries.
***************
*** 66,71 ****
--- 66,72 ----
           CALL lim_dmp_init
        ENDIF
        !
+       IF( ln_limdmp ) THEN   ! ice restoring in this case
           !
           CALL fld_read( kt, nn_fsbc, sf_icedmp )
           !
***************
*** 74,79 ****
--- 75,81 ----
           frld (:,:) = MAX( 0._wp, MIN( 1._wp,         &        ! 0<= frld<=1    values which blow the run up
              &         frld (:,:) - rdt_ice * resto_ice(:,:,1) * ( frld (:,:) - sf_icedmp(jp_frld )%fnow(:,:,1) )  )  )
           !
+       ENDIF
        !
     END SUBROUTINE lim_dmp_2
  
***************
*** 100,106 ****
        TYPE(FLD_N), DIMENSION (2)   ::   sl_icedmp    ! informations about the icedmp  field to be read
        TYPE(FLD_N)                  ::   sn_hicif     ! 
        TYPE(FLD_N)                  ::   sn_frld      ! 
!       NAMELIST/namice_dmp/ cn_dir, sn_hicif, sn_frld
        !!----------------------------------------------------------------------
        !
        ! 1)  initialize fld read structure for input data 
--- 102,108 ----
        TYPE(FLD_N), DIMENSION (2)   ::   sl_icedmp    ! informations about the icedmp  field to be read
        TYPE(FLD_N)                  ::   sn_hicif     ! 
        TYPE(FLD_N)                  ::   sn_frld      ! 
!       NAMELIST/namice_dmp/ cn_dir, ln_limdmp, sn_hicif, sn_frld
        !!----------------------------------------------------------------------
        !
        ! 1)  initialize fld read structure for input data 
***************
*** 118,123 ****
--- 120,126 ----
        IF ( lwp ) THEN                     !* control print
           WRITE (numout,*)'     lim_dmp_init : lim_dmp initialization ' 
           WRITE (numout,*)'       Namelist namicedmp read '
+          WRITE (numout,*)'         Ice restoring (T) or not (F) ln_limdmp =', ln_limdmp 
           WRITE (numout,*)
           WRITE (numout,*)'     CAUTION : here hard coded ice restoring along northern and southern boundaries'
           WRITE (numout,*)'               adapt the lim_dmp_init routine to your needs'
***************
*** 126,131 ****
--- 129,135 ----
        ! 2)  initialise resto_ice    ==>  config dependant !
        !     --------------------         ++++++++++++++++
        !
+       IF( ln_limdmp ) THEN                !* ice restoring is used, follow initialization
           ! 
           sl_icedmp ( jp_hicif ) = sn_hicif
           sl_icedmp ( jp_frld  ) = sn_frld
***************
*** 161,166 ****
--- 165,171 ----
              zreltim = zdmpmin + zfactor * (jpjglo - ( mjg(jj) - jpjzoom + 1 ))
              resto_ice(:,jj,:) = 1.e0 / ( zreltim * 86400 )
           END DO
+       ENDIF
        !
     END SUBROUTINE lim_dmp_init
     
diff -bic /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/LIM_SRC_2/limrst_2.F90 /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/LIM_SRC_2/limrst_2.F90
*** /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/LIM_SRC_2/limrst_2.F90	Tue Apr  4 14:51:16 2017
--- /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/LIM_SRC_2/limrst_2.F90	Fri Feb 24 15:39:23 2017
***************
*** 34,40 ****
  
     !!----------------------------------------------------------------------
     !! NEMO/LIM2 3.3 , UCL - NEMO Consortium (2010)
!    !! $Id: limrst_2.F90 5341 2015-06-03 14:59:46Z davestorkey $
     !! Software governed by the CeCILL licence     (NEMOGCM/NEMO_CeCILL.txt)
     !!----------------------------------------------------------------------
  CONTAINS
--- 34,40 ----
  
     !!----------------------------------------------------------------------
     !! NEMO/LIM2 3.3 , UCL - NEMO Consortium (2010)
!    !! $Id: limrst_2.F90 6140 2015-12-21 11:35:23Z timgraham $
     !! Software governed by the CeCILL licence     (NEMOGCM/NEMO_CeCILL.txt)
     !!----------------------------------------------------------------------
  CONTAINS
***************
*** 64,73 ****
              ELSE                           ;   WRITE(clkt, '(i8.8)') nitrst
              ENDIF
              ! create the file
! !{ DRAKKAR : use simpler name for restart files ( defined in iceini_2.F90 )
!             !clname = TRIM(cexper)//"_"//TRIM(ADJUSTL(clkt))//"_"//TRIM(cn_icerst_out)
!             clname = TRIM(cn_icerst_out)
! !}
              clpath = TRIM(cn_icerst_outdir) 
              IF( clpath(LEN_TRIM(clpath):) /= '/' ) clpath = TRIM(clpath)//'/' 
              IF(lwp) THEN
--- 64,70 ----
              ELSE                           ;   WRITE(clkt, '(i8.8)') nitrst
              ENDIF
              ! create the file
!             clname = TRIM(cexper)//"_"//TRIM(ADJUSTL(clkt))//"_"//TRIM(cn_icerst_out)
              clpath = TRIM(cn_icerst_outdir) 
              IF( clpath(LEN_TRIM(clpath):) /= '/' ) clpath = TRIM(clpath)//'/' 
              IF(lwp) THEN
diff -bic /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/LIM_SRC_3/limistate.F90 /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/LIM_SRC_3/limistate.F90
*** /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/LIM_SRC_3/limistate.F90	Tue Apr  4 14:56:58 2017
--- /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/LIM_SRC_3/limistate.F90	Fri Feb 24 15:39:23 2017
***************
*** 312,318 ****
                    END DO ! i_fill
  
                    IF(lwp) THEN 
! !                    WRITE(numout,*) ' ztests : ', ztests
                       IF( ztests .NE. 4 )THEN
                          WRITE(numout,*)
                          WRITE(numout,*) ' !!!! ALERT                  !!! '
--- 312,318 ----
                    END DO ! i_fill
  
                    IF(lwp) THEN 
!                      WRITE(numout,*) ' ztests : ', ztests
                       IF( ztests .NE. 4 )THEN
                          WRITE(numout,*)
                          WRITE(numout,*) ' !!!! ALERT                  !!! '
diff -bic /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/LIM_SRC_3/limrst.F90 /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/LIM_SRC_3/limrst.F90
*** /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/LIM_SRC_3/limrst.F90	Tue Apr  4 14:51:15 2017
--- /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/LIM_SRC_3/limrst.F90	Fri Feb 24 15:39:23 2017
***************
*** 70,82 ****
              ELSE                           ;   WRITE(clkt, '(i8.8)') nitrst
              ENDIF
              ! create the file
! !{ DRAKKAR : use simpler name for restart files ( defined in iceini_2.F90 )
!             !clname = TRIM(cexper)//"_"//TRIM(ADJUSTL(clkt))//"_"//TRIM(cn_icerst_out)
!             clname = TRIM(cn_icerst_out)
! !}
!             clpath = TRIM(cn_icerst_outdir)
!             IF( clpath(LEN_TRIM(clpath):) /= '/' ) clpath = TRIM(clpath)//'/'
! 
              clpath = TRIM(cn_icerst_outdir) 
              IF( clpath(LEN_TRIM(clpath):) /= '/' ) clpath = TRIM(clpath)//'/'
              IF(lwp) THEN
--- 70,76 ----
              ELSE                           ;   WRITE(clkt, '(i8.8)') nitrst
              ENDIF
              ! create the file
!             clname = TRIM(cexper)//"_"//TRIM(ADJUSTL(clkt))//"_"//TRIM(cn_icerst_out)
              clpath = TRIM(cn_icerst_outdir) 
              IF( clpath(LEN_TRIM(clpath):) /= '/' ) clpath = TRIM(clpath)//'/'
              IF(lwp) THEN
Common subdirectories: /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/TOP_SRC/C14b and /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/TOP_SRC/C14b
Common subdirectories: /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/TOP_SRC/CFC and /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/TOP_SRC/CFC
Common subdirectories: /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/TOP_SRC/MY_TRC and /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/TOP_SRC/MY_TRC
Common subdirectories: /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/TOP_SRC/PISCES and /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/TOP_SRC/PISCES
Common subdirectories: /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/TOP_SRC/TRP and /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/TOP_SRC/TRP
diff -bic /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/TOP_SRC/trcnam.F90 /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/TOP_SRC/trcnam.F90
*** /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/TOP_SRC/trcnam.F90	Tue Apr  4 14:51:16 2017
--- /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/TOP_SRC/trcnam.F90	Fri Feb 24 15:39:23 2017
***************
*** 35,41 ****
  
     !!----------------------------------------------------------------------
     !! NEMO/TOP 3.3 , NEMO Consortium (2010)
!    !! $Id: trcnam.F90 6204 2016-01-04 13:47:06Z cetlod $
     !! Software governed by the CeCILL licence (NEMOGCM/NEMO_CeCILL.txt)
     !!----------------------------------------------------------------------
  CONTAINS
--- 35,41 ----
  
     !!----------------------------------------------------------------------
     !! NEMO/TOP 3.3 , NEMO Consortium (2010)
!    !! $Id: trcnam.F90 6140 2015-12-21 11:35:23Z timgraham $
     !! Software governed by the CeCILL licence (NEMOGCM/NEMO_CeCILL.txt)
     !!----------------------------------------------------------------------
  CONTAINS
***************
*** 170,176 ****
          &                  cn_trcrst_indir, cn_trcrst_outdir, cn_trcrst_in, cn_trcrst_out
        !
        INTEGER  ::   ios                 ! Local integer output status for namelist read
-       CHARACTER(LEN=255) :: cl_no
        !!---------------------------------------------------------------------
        !
        IF(lwp) WRITE(numout,*) 'trc_nam_run : read the passive tracer namelists'
--- 170,175 ----
***************
*** 189,206 ****
  902   IF( ios /= 0 ) CALL ctl_nam ( ios , 'namtrc in configuration namelist', lwp )
        IF(lwm) WRITE ( numont, namtrc_run )
  
-       ! Add extension (job number to the restart dir. Differ for restart input and restart output
- !{ DRAKKAR modification : NEMO reads restart files :<CN_OCERST_INDIR>.<<nn_no-1>>/<CN_OCERST_IN>-<<nn_no -1 >>_<RANK>.nc
-       WRITE(cl_no,*) nn_no-1 ; cl_no = TRIM(ADJUSTL(cl_no) )
-       cn_trcrst_indir=TRIM(cn_trcrst_indir)//'.'//TRIM(cl_no)
-       cn_trcrst_in= TRIM(cn_trcrst_in)//'-'//TRIM(cl_no)
- 
-       !  DRAKKAR modification : NEMO writes restart files :<CN_OCERST_INDIR>.<<nn_no>>/<CN_OCERST_IN>-<<nn_no  >>_<RANK>.nc
-       WRITE(cl_no,*) nn_no   ; cl_no = TRIM(ADJUSTL(cl_no) )
-       cn_trcrst_outdir=TRIM(cn_trcrst_outdir)//'.'//TRIM(cl_no)
-       cn_trcrst_out= TRIM(cn_trcrst_out)//'-'//TRIM(cl_no)
- !}
- 
        !  computes the first time step of tracer model
        nittrc000 = nit000 + nn_dttrc - 1
  
--- 188,193 ----
***************
*** 394,400 ****
  
     !!----------------------------------------------------------------------
     !! NEMO/TOP 3.3 , NEMO Consortium (2010)
!    !! $Id: trcnam.F90 6204 2016-01-04 13:47:06Z cetlod $
     !! Software governed by the CeCILL licence (NEMOGCM/NEMO_CeCILL.txt)
     !!======================================================================
  END MODULE trcnam
--- 381,387 ----
  
     !!----------------------------------------------------------------------
     !! NEMO/TOP 3.3 , NEMO Consortium (2010)
!    !! $Id: trcnam.F90 6140 2015-12-21 11:35:23Z timgraham $
     !! Software governed by the CeCILL licence (NEMOGCM/NEMO_CeCILL.txt)
     !!======================================================================
  END MODULE trcnam
diff -bic /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/TOP_SRC/trcrst.F90 /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/TOP_SRC/trcrst.F90
*** /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/TOP_SRC/trcrst.F90	Tue Apr  4 14:51:16 2017
--- /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/TOP_SRC/trcrst.F90	Fri Feb 24 15:39:23 2017
***************
*** 14,32 ****
     !!----------------------------------------------------------------------
     !!----------------------------------------------------------------------
     !!   trc_rst :   Restart for passive tracer
-    !!----------------------------------------------------------------------
-    !!----------------------------------------------------------------------
-    !!   'key_top'                                                TOP models
-    !!----------------------------------------------------------------------
     !!   trc_rst_opn    : open  restart file
     !!   trc_rst_read   : read  restart file
     !!   trc_rst_wri    : write restart file
     !!----------------------------------------------------------------------
     USE oce_trc
     USE trc
-    USE trcnam_trp
     USE iom
     USE daymod
     IMPLICIT NONE
     PRIVATE
  
--- 14,28 ----
     !!----------------------------------------------------------------------
     !!----------------------------------------------------------------------
     !!   trc_rst        : Restart for passive tracer
     !!   trc_rst_opn    : open  restart file
     !!   trc_rst_read   : read  restart file
     !!   trc_rst_wri    : write restart file
     !!----------------------------------------------------------------------
     USE oce_trc
     USE trc
     USE iom
     USE daymod
+    
     IMPLICIT NONE
     PRIVATE
  
***************
*** 35,43 ****
     PUBLIC   trc_rst_wri       ! called by ???
     PUBLIC   trc_rst_cal
  
!    !! * Substitutions
! #  include "top_substitute.h90"
!    
  CONTAINS
     
     SUBROUTINE trc_rst_opn( kt )
--- 31,41 ----
     PUBLIC   trc_rst_wri       ! called by ???
     PUBLIC   trc_rst_cal
  
!    !!----------------------------------------------------------------------
!    !! NEMO/TOP 3.7 , NEMO Consortium (2010)
!    !! $Id: trcrst.F90 6140 2015-12-21 11:35:23Z timgraham $
!    !! Software governed by the CeCILL licence (NEMOGCM/NEMO_CeCILL.txt)
!    !!----------------------------------------------------------------------
  CONTAINS
     
     SUBROUTINE trc_rst_opn( kt )
***************
*** 83,92 ****
           ENDIF
           ! create the file
           IF(lwp) WRITE(numout,*)
! !{ DRAKKAR : use simpler name for restart files ( defined in trcnam.F90 )
! !        clname = TRIM(cexper)//"_"//TRIM(ADJUSTL(clkt))//"_"//TRIM(cn_trcrst_out)
!          clname = TRIM(cn_trcrst_out)
! !}
           clpath = TRIM(cn_trcrst_outdir)
           IF( clpath(LEN_TRIM(clpath):) /= '/' ) clpath = TRIM(clpath) // '/'
           IF(lwp) WRITE(numout,*) &
--- 81,87 ----
           ENDIF
           ! create the file
           IF(lwp) WRITE(numout,*)
!          clname = TRIM(cexper)//"_"//TRIM(ADJUSTL(clkt))//"_"//TRIM(cn_trcrst_out)
           clpath = TRIM(cn_trcrst_outdir)
           IF( clpath(LEN_TRIM(clpath):) /= '/' ) clpath = TRIM(clpath) // '/'
           IF(lwp) WRITE(numout,*) &
***************
*** 134,140 ****
        REAL(wp) :: zarak0
        !!----------------------------------------------------------------------
        !
!       CALL iom_rstput( kt, nitrst, numrtw, 'rdttrc1', rdttrc(1) )   ! surface passive tracer time step
        ! prognostic variables 
        ! -------------------- 
        DO jn = 1, jptra
--- 129,135 ----
        REAL(wp) :: zarak0
        !!----------------------------------------------------------------------
        !
!       CALL iom_rstput( kt, nitrst, numrtw, 'rdttrc1', rdttrc )   ! passive tracer time step
        ! prognostic variables 
        ! -------------------- 
        DO jn = 1, jptra
***************
*** 202,214 ****
           IF(lwp) WRITE(numout,*) 'trc_rst_cal : read the TOP restart file for calendar'
           IF(lwp) WRITE(numout,*) '~~~~~~~~~~~~'
  
-          IF ( jprstlib == jprstdimg ) THEN
-            ! eventually read netcdf file (monobloc)  for restarting on different number of processors
-            ! if {cn_trcrst_in}.nc exists, then set jlibalt to jpnf90 
-            INQUIRE( FILE = TRIM(cn_trcrst_indir)//'/'//TRIM(cn_trcrst_in)//'.nc', EXIST = llok )
-            IF ( llok ) THEN ; jlibalt = jpnf90  ; ELSE ; jlibalt = jprstlib ; ENDIF
-          ENDIF
- 
           IF( ln_rsttr ) THEN
              CALL iom_open( TRIM(cn_trcrst_indir)//'/'//cn_trcrst_in, numrtr, kiolib = jlibalt )
              CALL iom_get ( numrtr, 'kt', zkt )   ! last time-step of previous run
--- 197,202 ----
***************
*** 238,244 ****
                 CALL iom_get( numrtr, 'adatrj', adatrj  )
               ELSE
                 ndastp = ndate0 - 1     ! ndate0 read in the namelist in dom_nam
!                adatrj = ( REAL( nittrc000-1, wp ) * rdttra(1) ) / rday
                 ! note this is wrong if time step has changed during run
              ENDIF
              !
--- 226,232 ----
                 CALL iom_get( numrtr, 'adatrj', adatrj  )
               ELSE
                 ndastp = ndate0 - 1     ! ndate0 read in the namelist in dom_nam
!                adatrj = ( REAL( nittrc000-1, wp ) * rdt ) / rday
                 ! note this is wrong if time step has changed during run
              ENDIF
              !
***************
*** 291,297 ****
        ENDIF
        !
        DO jk = 1, jpk
!          zvol(:,:,jk) = e1e2t(:,:) * fse3t_a(:,:,jk) * tmask(:,:,jk)
        END DO
        !
        DO jn = 1, jptra
--- 279,285 ----
        ENDIF
        !
        DO jk = 1, jpk
!          zvol(:,:,jk) = e1e2t(:,:) * e3t_a(:,:,jk) * tmask(:,:,jk)
        END DO
        !
        DO jn = 1, jptra
***************
*** 306,312 ****
           zdrift = ( ( ztraf - trai(jn) ) / ( trai(jn) + 1.e-12 )  ) * 100._wp
           IF(lwp) WRITE(numout,9000) jn, TRIM( ctrcnm(jn) ), zmean, zmin, zmax, zdrift
        END DO
!       IF (lwp )WRITE(numout,*) 
  9000  FORMAT(' tracer nb :',i2,'    name :',a10,'    mean :',e18.10,'    min :',e18.10, &
        &      '    max :',e18.10,'    drift :',e18.10, ' %')
        !
--- 294,300 ----
           zdrift = ( ( ztraf - trai(jn) ) / ( trai(jn) + 1.e-12 )  ) * 100._wp
           IF(lwp) WRITE(numout,9000) jn, TRIM( ctrcnm(jn) ), zmean, zmin, zmax, zdrift
        END DO
!       WRITE(numout,*) 
  9000  FORMAT(' tracer nb :',i2,'    name :',a10,'    mean :',e18.10,'    min :',e18.10, &
        &      '    max :',e18.10,'    drift :',e18.10, ' %')
        !
***************
*** 327,333 ****
  
     !!----------------------------------------------------------------------
     !! NEMO/TOP 3.3 , NEMO Consortium (2010)
!    !! $Id: trcrst.F90 5513 2015-06-30 09:59:46Z cetlod $
     !! Software governed by the CeCILL licence (NEMOGCM/NEMO_CeCILL.txt)
     !!======================================================================
  END MODULE trcrst
--- 315,321 ----
  
     !!----------------------------------------------------------------------
     !! NEMO/TOP 3.3 , NEMO Consortium (2010)
!    !! $Id: trcrst.F90 6140 2015-12-21 11:35:23Z timgraham $
     !! Software governed by the CeCILL licence (NEMOGCM/NEMO_CeCILL.txt)
     !!======================================================================
  END MODULE trcrst
Common subdirectories: /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/TOP_SRC/PISCES/P2Z and /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/TOP_SRC/PISCES/P2Z
Common subdirectories: /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/TOP_SRC/PISCES/P4Z and /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/TOP_SRC/PISCES/P4Z
Common subdirectories: /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/TOP_SRC/PISCES/SED and /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/TOP_SRC/PISCES/SED
Common subdirectories: /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/ASM and /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/ASM
Common subdirectories: /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/BDY and /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/BDY
Common subdirectories: /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/C1D and /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/C1D
Common subdirectories: /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/CRS and /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/CRS
Common subdirectories: /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/DIA and /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/DIA
Common subdirectories: /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/DIU and /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/DIU
Common subdirectories: /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/DOM and /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/DOM
Common subdirectories: /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/DYN and /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/DYN
Common subdirectories: /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/FLO and /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/FLO
Common subdirectories: /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/ICB and /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/ICB
Common subdirectories: /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/IOM and /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/IOM
Common subdirectories: /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/LBC and /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/LBC
Common subdirectories: /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/LDF and /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/LDF
Common subdirectories: /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/OBS and /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/OBS
Only in /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/: README
Common subdirectories: /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/SBC and /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/SBC
Only in /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/: SOL
Common subdirectories: /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/STO and /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/STO
Common subdirectories: /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/TRA and /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/TRA
Common subdirectories: /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/TRD and /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/TRD
Common subdirectories: /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/ZDF and /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/ZDF
diff -bic /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/nemogcm.F90 /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/nemogcm.F90
*** /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/nemogcm.F90	Tue Apr  4 14:51:16 2017
--- /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/nemogcm.F90	Fri Feb 24 15:39:23 2017
***************
*** 38,46 ****
     !!   nemo_gcm       : solve ocean dynamics, tracer, biogeochemistry and/or sea-ice
     !!   nemo_init      : initialization of the NEMO system
     !!   nemo_ctl       : initialisation of the contol print
!    !!   nemo_closefile : close remaining open files
     !!   nemo_alloc     : dynamical allocation
!    !!   nemo_partition : calculate MPP domain decomposition
     !!   factorise      : calculate the factors of the no. of MPI processes
     !!----------------------------------------------------------------------
     USE step_oce       ! module used in the ocean time stepping module (step.F90)
--- 38,46 ----
     !!   nemo_gcm      : solve ocean dynamics, tracer, biogeochemistry and/or sea-ice
     !!   nemo_init     : initialization of the NEMO system
     !!   nemo_ctl      : initialisation of the contol print
!    !!   nemo_closefile: close remaining open files
     !!   nemo_alloc    : dynamical allocation
!    !!   nemo_partition: calculate MPP domain decomposition
     !!   factorise     : calculate the factors of the no. of MPI processes
     !!----------------------------------------------------------------------
     USE step_oce       ! module used in the ocean time stepping module (step.F90)
***************
*** 87,94 ****
     USE xios           ! xIOserver
  #endif
     USE crsini          ! initialise grid coarsening utility
!    USE lbcnfd, ONLY: isendto, nsndto, nfsloop, nfeloop ! Setup of north fold exchanges 
!    USE sbc_oce, ONLY: lk_oasis
     USE diatmb          ! Top,middle,bottom output
     USE dia25h          ! 25h mean output
     USE wet_dry         ! Wetting and drying setting   (wad_init routine)
--- 87,94 ----
     USE xios           ! xIOserver
  #endif
     USE crsini         ! initialise grid coarsening utility
!    USE lbcnfd , ONLY  : isendto, nsndto, nfsloop, nfeloop   ! Setup of north fold exchanges 
!    USE sbc_oce, ONLY  : lk_oasis
     USE diatmb          ! Top,middle,bottom output
     USE dia25h          ! 25h mean output
     USE wet_dry         ! Wetting and drying setting   (wad_init routine)
***************
*** 101,112 ****
     PUBLIC   nemo_alloc  ! needed by TAM
  
     CHARACTER(lc) ::   cform_aaa="( /, 'AAAAAAAA', / ) "     ! flag for output listing
-    CHARACTER(lc) ::   cform_bbb="( /, 'BBBBBBBB', / ) "     ! flag for output listing
-    CHARACTER(lc) ::   cform_ccc="( /, ';);););)', / ) "     ! flag for output listing
  
     !!----------------------------------------------------------------------
     !! NEMO/OPA 3.7 , NEMO Consortium (2015)
!    !! $Id: nemogcm.F90 5656 2015-07-31 08:55:56Z timgraham $
     !! Software governed by the CeCILL licence     (NEMOGCM/NEMO_CeCILL.txt)
     !!----------------------------------------------------------------------
  CONTAINS
--- 101,110 ----
     PUBLIC   nemo_alloc  ! needed by TAM
  
     CHARACTER(lc) ::   cform_aaa="( /, 'AAAAAAAA', / ) "     ! flag for output listing
  
     !!----------------------------------------------------------------------
     !! NEMO/OPA 3.7 , NEMO Consortium (2015)
!    !! $Id: nemogcm.F90 6152 2015-12-21 22:33:57Z acc $
     !! Software governed by the CeCILL licence     (NEMOGCM/NEMO_CeCILL.txt)
     !!----------------------------------------------------------------------
  CONTAINS
***************
*** 126,136 ****
        !!              Madec, 2008, internal report, IPSL.
        !!----------------------------------------------------------------------
        INTEGER ::   istp       ! time step index
-       !! for timing each step
-       CHARACTER(LEN=8)      :: cldate
-       CHARACTER(LEN=10)     :: cltime
-       CHARACTER(LEN=5)      :: clzone
-       INTEGER, DIMENSION(8) :: ivalue
        !!----------------------------------------------------------------------
        !
  #if defined key_agrif
--- 124,129 ----
***************
*** 154,160 ****
        ! they will never enter in step and other processes will wait until the end of the cpu time!
        IF( lk_mpp )   CALL mpp_max( nstop )
  
!       IF(lwp) WRITE(numout,cform_bbb)   ! Flag BBBBBB
  
        !                            !-----------------------!
        !                            !==   time stepping   ==!
--- 147,153 ----
        ! they will never enter in step and other processes will wait until the end of the cpu time!
        IF( lk_mpp )   CALL mpp_max( nstop )
  
!       IF(lwp) WRITE(numout,cform_aaa)   ! Flag AAAAAAA
  
        !                            !-----------------------!
        !                            !==   time stepping   ==!
***************
*** 180,191 ****
  #endif
  
           DO WHILE ( istp <= nitend .AND. nstop == 0 )
-             !{ DRAKKAR : print time step for run monitoring
-            IF (lwp ) THEN
-              CALL DATE_AND_TIME(cldate,cltime,clzone,ivalue)
-              print '(i8,1x,8i4)', istp, ivalue(:)   ! DRAKKAR code : print time step for run monitoring
-            ENDIF
-             !}
  #if defined key_agrif
              CALL stp                         ! AGRIF: time stepping
  #else
--- 173,178 ----
***************
*** 207,223 ****
        !                            !------------------------!
        !                            !==  finalize the run  ==!
        !                            !------------------------!
!       !{ DRAKKAR : to have information  for scripts
!       IF(lwp) WRITE(numout,*) 'run stop at : ',ndastp
!       !}
!       IF ( lwp ) THEN 
!       IF( nstop /= 0  ) THEN   ! error print
!          WRITE(numout,cform_ccc)   ! Flag ;);););)
           WRITE(numout,cform_err)
           WRITE(numout,*) nstop, ' error have been found' 
-       ELSE
-          WRITE(numout,cform_aaa)   ! Flag AAAAAAA
-       ENDIF
        ENDIF
        !
  #if defined key_agrif
--- 194,204 ----
        !                            !------------------------!
        !                            !==  finalize the run  ==!
        !                            !------------------------!
!       IF(lwp) WRITE(numout,cform_aaa)   ! Flag AAAAAAA
!       !
!       IF( nstop /= 0 .AND. lwp ) THEN   ! error print
           WRITE(numout,cform_err)
           WRITE(numout,*) nstop, ' error have been found'
        ENDIF
        !
  #if defined key_agrif
***************
*** 351,363 ****
        ! then we calculate them here now that we have our communicator size
        IF( jpni < 1 .OR. jpnj < 1 ) THEN
  #if   defined key_mpp_mpi
!          IF( Agrif_Root() ) CALL nemo_partition(mppsize)
  #else
           jpni  = 1
           jpnj  = 1
           jpnij = jpni*jpnj
  #endif
!       END IF
  
        ! Calculate domain dimensions given calculated jpni and jpnj
        ! This used to be done in par_oce.F90 when they were parameters rather than variables
--- 332,344 ----
        ! then we calculate them here now that we have our communicator size
        IF( jpni < 1 .OR. jpnj < 1 ) THEN
  #if   defined key_mpp_mpi
!          IF( Agrif_Root() )   CALL nemo_partition( mppsize )
  #else
           jpni  = 1
           jpnj  = 1
           jpnij = jpni*jpnj
  #endif
!       ENDIF
  
        ! Calculate domain dimensions given calculated jpni and jpnj
        ! This used to be done in par_oce.F90 when they were parameters rather than variables
***************
*** 366,373 ****
           jpi = ( nx_global+2-2*jpreci + (jpni-1) ) / jpni + 2*jpreci ! first  dim.
           jpj = ( ny_global+2-2*jprecj + (jpnj-1) ) / jpnj + 2*jprecj ! second dim. 
  #else
!          jpi = ( jpiglo-2*jpreci + (jpni-1) ) / jpni + 2*jpreci   ! first  dim.
!          jpj = ( jpjglo-2*jprecj + (jpnj-1) ) / jpnj + 2*jprecj   ! second dim.
  #endif
        ENDIF         
           jpk = jpkdta                                             ! third dim
--- 347,354 ----
           jpi = ( nx_global+2-2*jpreci + (jpni-1) ) / jpni + 2*jpreci    ! first  dim.
           jpj = ( ny_global+2-2*jprecj + (jpnj-1) ) / jpnj + 2*jprecj    ! second dim. 
  #else
!          jpi = ( jpiglo     -2*jpreci + (jpni-1) ) / jpni + 2*jpreci    ! first  dim.
!          jpj = ( jpjglo     -2*jprecj + (jpnj-1) ) / jpnj + 2*jprecj    ! second dim.
  #endif
        ENDIF         
           jpk = jpkdta                                             ! third dim
***************
*** 375,381 ****
           ! simple trick to use same vertical grid as parent but different number of levels: 
           ! Save maximum number of levels in jpkdta, then define all vertical grids with this number.
           ! Suppress once vertical online interpolation is ok
!          IF(.NOT.Agrif_Root()) jpkdta = Agrif_Parent(jpkdta)
  #endif
           jpim1 = jpi-1                                            ! inner domain indices
           jpjm1 = jpj-1                                            !   "           "
--- 356,362 ----
           ! simple trick to use same vertical grid as parent but different number of levels: 
           ! Save maximum number of levels in jpkdta, then define all vertical grids with this number.
           ! Suppress once vertical online interpolation is ok
!          IF(.NOT.Agrif_Root())   jpkdta = Agrif_Parent( jpkdta )
  #endif
           jpim1 = jpi-1                                            ! inner domain indices
           jpjm1 = jpj-1                                            !   "           "
diff -bic /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/stpctl.F90 /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/stpctl.F90
*** /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/stpctl.F90	Tue Apr  4 14:56:58 2017
--- /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/stpctl.F90	Fri Feb 24 15:39:23 2017
***************
*** 27,33 ****
     PUBLIC stp_ctl           ! routine called by step.F90
     !!----------------------------------------------------------------------
     !! NEMO/OPA 3.3 , NEMO Consortium (2010)
!    !! $Id: stpctl.F90 3294 2012-01-28 16:44:18Z rblod $
     !! Software governed by the CeCILL licence (NEMOGCM/NEMO_CeCILL.txt)
     !!----------------------------------------------------------------------
  CONTAINS
--- 27,33 ----
     PUBLIC stp_ctl           ! routine called by step.F90
     !!----------------------------------------------------------------------
     !! NEMO/OPA 3.3 , NEMO Consortium (2010)
!    !! $Id: stpctl.F90 6140 2015-12-21 11:35:23Z timgraham $
     !! Software governed by the CeCILL licence (NEMOGCM/NEMO_CeCILL.txt)
     !!----------------------------------------------------------------------
  CONTAINS
***************
*** 45,51 ****
        !! ** Actions :   'time.step' file containing the last ocean time-step
        !!                
        !!----------------------------------------------------------------------
!       INTEGER, INTENT( in ) ::   kt         ! ocean time-step index
        INTEGER, INTENT(inout) ::   kindic   ! error indicator
        !!
        INTEGER  ::   ji, jj, jk              ! dummy loop indices
--- 45,51 ----
        !! ** Actions :   'time.step' file containing the last ocean time-step
        !!                
        !!----------------------------------------------------------------------
!       INTEGER, INTENT(in   ) ::   kt       ! ocean time-step index
        INTEGER, INTENT(inout) ::   kindic   ! error indicator
        !!
        INTEGER  ::   ji, jj, jk             ! dummy loop indices
***************
*** 79,86 ****
        END DO        
        IF( lk_mpp )   CALL mpp_max( zumax )                 ! max over the global domain
        !
!       IF( MOD( kt, 10  ) == 1 .AND. lwp )   WRITE(numout,*) ' ==>> time-step= ',kt,' abs(U) max: ', zumax
! !     IF( lwp )   WRITE(numout,*) ' ==>> time-step= ',kt,' abs(U) max: ', zumax
        !
        IF( zumax > 20.e0 ) THEN
           IF( lk_mpp ) THEN
--- 79,85 ----
        END DO        
        IF( lk_mpp )   CALL mpp_max( zumax )                 ! max over the global domain
        !
!       IF( MOD( kt, nwrite ) == 1 .AND. lwp )   WRITE(numout,*) ' ==>> time-step= ',kt,' abs(U) max: ', zumax
        !
        IF( zumax > 20.e0 ) THEN
           IF( lk_mpp ) THEN
***************
*** 101,112 ****
           ENDIF
           kindic = -3
        ENDIF
! 9400  FORMAT (' kt=',i8,' max abs(U): ',1pg11.4,', i j k: ',3i5)
! 
        !                                              !* Test minimum of salinity
        !                                              !  ------------------------
        !! zsmin = MINVAL( tsn(:,:,1,jp_sal), mask = tmask(:,:,1) == 1.e0 )  slower than the following loop on NEC SX5
!       zsmin = 100.e0
        DO jj = 2, jpjm1
           DO ji = 1, jpi
              IF( tmask(ji,jj,1) == 1) zsmin = MIN(zsmin,tsn(ji,jj,1,jp_sal))
--- 100,111 ----
           ENDIF
           kindic = -3
        ENDIF
! 9400  FORMAT (' kt=',i6,' max abs(U): ',1pg11.4,', i j k: ',3i5)
!       !
        !                                              !* Test minimum of salinity
        !                                              !  ------------------------
        !! zsmin = MINVAL( tsn(:,:,1,jp_sal), mask = tmask(:,:,1) == 1.e0 )  slower than the following loop on NEC SX5
!       zsmin = 100._wp
        DO jj = 2, jpjm1
           DO ji = 1, jpi
              IF( tmask(ji,jj,1) == 1) zsmin = MIN(zsmin,tsn(ji,jj,1,jp_sal))
***************
*** 114,121 ****
        END DO
        IF( lk_mpp )   CALL mpp_min( zsmin )                ! min over the global domain
        !
!       IF( MOD( kt, 60 ) == 1 .AND. lwp )   WRITE(numout,*) ' ==>> time-step= ',kt,' SSS min:', zsmin
! !     IF( lwp )   WRITE(numout,*) ' ==>> time-step= ',kt,' SSS min:', zsmin
        !
        IF( zsmin < 0.) THEN 
           IF (lk_mpp) THEN
--- 113,119 ----
        END DO
        IF( lk_mpp )   CALL mpp_min( zsmin )                ! min over the global domain
        !
!       IF( MOD( kt, nwrite ) == 1 .AND. lwp )   WRITE(numout,*) ' ==>> time-step= ',kt,' SSS min:', zsmin
        !
        IF( zsmin < 0.) THEN 
           IF (lk_mpp) THEN
***************
*** 136,144 ****
           ENDIF
           kindic = -3
        ENDIF
! 9500  FORMAT (' kt=',i8,' min SSS: ',1pg11.4,', i j: ',2i5)
! 
!       
        IF( lk_c1d )  RETURN          ! No log file in case of 1D vertical configuration
  
        ! log file (ssh statistics)
--- 134,142 ----
           ENDIF
           kindic = -3
        ENDIF
! 9500  FORMAT (' kt=',i6,' min SSS: ',1pg11.4,', i j: ',2i5)
!       !
!       !
        IF( lk_c1d )  RETURN          ! No log file in case of 1D vertical configuration
  
        ! log file (ssh statistics)
diff -bic /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/timing.F90 /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/timing.F90
*** /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/timing.F90	Tue Apr  4 14:51:16 2017
--- /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/timing.F90	Fri Feb 24 15:39:23 2017
***************
*** 77,83 ****
     LOGICAL :: lwriter
     !!----------------------------------------------------------------------
     !! NEMO/OPA 4.0 , NEMO Consortium (2011)
!    !! $Id: timing.F90 5120 2015-03-03 16:11:55Z acc $
     !! Software governed by the CeCILL licence     (NEMOGCM/NEMO_CeCILL.txt)
     !!----------------------------------------------------------------------
  CONTAINS
--- 77,83 ----
     LOGICAL :: lwriter
     !!----------------------------------------------------------------------
     !! NEMO/OPA 4.0 , NEMO Consortium (2011)
!    !! $Id: timing.F90 6981 2016-10-04 12:34:18Z nicolasmartin $
     !! Software governed by the CeCILL licence     (NEMOGCM/NEMO_CeCILL.txt)
     !!----------------------------------------------------------------------
  CONTAINS
***************
*** 321,327 ****
        IF( lwriter ) WRITE(numtime,*) 'Total timing (sum) :'
        IF( lwriter ) WRITE(numtime,*) '--------------------'
        IF( lwriter ) WRITE(numtime,"('Elapsed Time (s)  CPU Time (s)')")
!       IF( lwriter ) WRITE(numtime,'(5x,f13.3,1x,f12.3)')  tot_etime, tot_ctime
        IF( lwriter ) WRITE(numtime,*) 
  #if defined key_mpp_mpi
        IF( ll_averep ) CALL waver_info
--- 321,327 ----
        IF( lwriter ) WRITE(numtime,*) 'Total timing (sum) :'
        IF( lwriter ) WRITE(numtime,*) '--------------------'
        IF( lwriter ) WRITE(numtime,"('Elapsed Time (s)  CPU Time (s)')")
!       IF( lwriter ) WRITE(numtime,'(5x,f12.3,1x,f12.3)')  tot_etime, tot_ctime
        IF( lwriter ) WRITE(numtime,*) 
  #if defined key_mpp_mpi
        IF( ll_averep ) CALL waver_info
***************
*** 491,496 ****
--- 491,498 ----
           s_timer => s_timer%next
        END DO      
  
+          WRITE(*,*) 'ARPDBG: timing: done gathers'
+       
        IF( narea == 1 ) THEN    
           ! Compute some stats
           sl_timer_glob => sl_timer_glob_root
***************
*** 513,518 ****
--- 515,522 ----
              sl_timer_glob => sl_timer_glob%next                                
           END DO
  
+          WRITE(*,*) 'ARPDBG: timing: done computing stats'
+       
           ! reorder the averaged list by CPU time      
           s_wrk => NULL()
           sl_timer_ave => sl_timer_ave_root
Only in /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/ASM: .gitkeep
diff -bic /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/BDY/bdyini.F90 /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/BDY/bdyini.F90
*** /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/BDY/bdyini.F90	Tue Apr  4 14:51:16 2017
--- /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/BDY/bdyini.F90	Fri Feb 24 15:39:23 2017
***************
*** 48,54 ****
     INTEGER, DIMENSION(jp_nseg) ::   jpjsob, jpisdt, jpisft, npckgs   !
     !!----------------------------------------------------------------------
     !! NEMO/OPA 3.7 , NEMO Consortium (2015)
!    !! $Id: bdyini.F90 6204 2016-01-04 13:47:06Z cetlod $ 
     !! Software governed by the CeCILL licence     (NEMOGCM/NEMO_CeCILL.txt)
     !!----------------------------------------------------------------------
  CONTAINS
--- 48,54 ----
     INTEGER, DIMENSION(jp_nseg) ::   jpjsob, jpisdt, jpisft, npckgs   !
     !!----------------------------------------------------------------------
     !! NEMO/OPA 3.7 , NEMO Consortium (2015)
!    !! $Id: bdyini.F90 6140 2015-12-21 11:35:23Z timgraham $ 
     !! Software governed by the CeCILL licence     (NEMOGCM/NEMO_CeCILL.txt)
     !!----------------------------------------------------------------------
  CONTAINS
***************
*** 471,479 ****
              ! used so far in obc package)
  
              nblendta(1:jpbgrd,ib_bdy) =  (nbdyend - nbdybeg + 1) * nn_rimwidth(ib_bdy)
! !           jpbdtas = MAX(jpbdtas, (nbdyend - nbdybeg + 1))
! !JMM FIX
!             jpbdtas = MAX(jpbdtas, (nbdyend - nbdybeg + 1) * nn_rimwidth(ib_bdy)  )
              IF (lwp.and.(nn_rimwidth(ib_bdy)>nrimmax)) &
              & CALL ctl_stop( 'rimwidth must be lower than nrimmax' )
  
--- 471,477 ----
              ! used so far in obc package)
  
              nblendta(1:jpbgrd,ib_bdy) =  (nbdyend - nbdybeg + 1) * nn_rimwidth(ib_bdy)
!             jpbdtas = MAX(jpbdtas, (nbdyend - nbdybeg + 1))
              IF (lwp.and.(nn_rimwidth(ib_bdy)>nrimmax)) &
              & CALL ctl_stop( 'rimwidth must be lower than nrimmax' )
  
Only in /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/C1D: .gitkeep
Only in /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/CRS: .gitkeep
diff -bic /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/DIA/diawri.F90 /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/DIA/diawri.F90
*** /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/DIA/diawri.F90	Tue Apr  4 14:51:16 2017
--- /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/DIA/diawri.F90	Fri Feb 24 15:39:23 2017
***************
*** 406,412 ****
        INTEGER, INTENT( in ) ::   kt   ! ocean time-step index
        !
        LOGICAL ::   ll_print = .FALSE.                        ! =T print and flush numout
!       CHARACTER (len=80) ::   clhstnam, clop, clmx           ! local names
        INTEGER  ::   inum = 11                                ! temporary logical unit
        INTEGER  ::   ji, jj, jk                               ! dummy loop indices
        INTEGER  ::   ierr                                     ! error code return from allocation
--- 406,412 ----
        INTEGER, INTENT( in ) ::   kt   ! ocean time-step index
        !
        LOGICAL ::   ll_print = .FALSE.                        ! =T print and flush numout
!       CHARACTER (len=40) ::   clhstnam, clop, clmx           ! local names
        INTEGER  ::   inum = 11                                ! temporary logical unit
        INTEGER  ::   ji, jj, jk                               ! dummy loop indices
        INTEGER  ::   ierr                                     ! error code return from allocation
diff -bic /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/DOM/domain.F90 /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/DOM/domain.F90
*** /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/DOM/domain.F90	Tue Apr  4 14:51:16 2017
--- /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/DOM/domain.F90	Fri Feb 24 15:39:23 2017
***************
*** 48,54 ****
  
     !!-------------------------------------------------------------------------
     !! NEMO/OPA 3.3 , NEMO Consortium (2010)
!    !! $Id: domain.F90 4624 2014-04-28 12:09:03Z acc $
     !! Software governed by the CeCILL licence        (NEMOGCM/NEMO_CeCILL.txt)
     !!-------------------------------------------------------------------------
  CONTAINS
--- 48,54 ----
  
     !!-------------------------------------------------------------------------
     !! NEMO/OPA 3.3 , NEMO Consortium (2010)
!    !! $Id: domain.F90 6981 2016-10-04 12:34:18Z nicolasmartin $
     !! Software governed by the CeCILL licence        (NEMOGCM/NEMO_CeCILL.txt)
     !!-------------------------------------------------------------------------
  CONTAINS
***************
*** 159,166 ****
        !!              - namnc4 namelist   ! "key_netcdf4" only
        !!----------------------------------------------------------------------
        USE ioipsl
!       NAMELIST/namrun/ cn_ocerst_indir, cn_ocerst_outdir, nn_stocklist, ln_rst_list, cn_dirout ,     &
!          &             nn_no   , cn_exp   , cn_ocerst_in, cn_ocerst_out, ln_rstart , nn_rstctl ,     &
           &             nn_it000, nn_itend , nn_date0    , nn_time0     , nn_leapy  , nn_istate ,     &
           &             nn_stock, nn_write , ln_mskland  , ln_clobber   , nn_chunksz, nn_euler  ,     &
           &             ln_cfmeta, ln_iscpl
--- 159,166 ----
        !!              - namnc4 namelist   ! "key_netcdf4" only
        !!----------------------------------------------------------------------
        USE ioipsl
!       NAMELIST/namrun/ cn_ocerst_indir, cn_ocerst_outdir, nn_stocklist, ln_rst_list,                 &
!                        nn_no   , cn_exp   , cn_ocerst_in, cn_ocerst_out, ln_rstart , nn_rstctl ,     &
           &             nn_it000, nn_itend , nn_date0    , nn_time0     , nn_leapy  , nn_istate ,     &
           &             nn_stock, nn_write , ln_mskland  , ln_clobber   , nn_chunksz, nn_euler  ,     &
           &             ln_cfmeta, ln_iscpl
***************
*** 173,179 ****
        NAMELIST/namnc4/ nn_nchunks_i, nn_nchunks_j, nn_nchunks_k, ln_nc4zip
  #endif
        INTEGER  ::   ios                 ! Local integer output status for namelist read
-       CHARACTER(LEN=255) :: cl_no
        !!----------------------------------------------------------------------
  
        REWIND( numnam_ref )              ! Namelist namrun in reference namelist : Parameters of the run
--- 173,178 ----
***************
*** 184,201 ****
        READ  ( numnam_cfg, namrun, IOSTAT = ios, ERR = 902 )
  902   IF( ios /= 0 )   CALL ctl_nam ( ios , 'namrun in configuration namelist', lwp )
        IF(lwm) WRITE ( numond, namrun )
!       ! Add extension (job number to the restart dir. Differ for restart input and restart output
! !{ DRAKKAR modification : NEMO reads restart files :<CN_OCERST_INDIR>.<<nn_no-1>>/<CN_OCERST_IN>-<<nn_no -1 >>_<RANK>.nc
!       WRITE(cl_no,*) nn_no-1 ; cl_no = TRIM(ADJUSTL(cl_no) )
!       cn_ocerst_indir=TRIM(cn_ocerst_indir)//'.'//TRIM(cl_no)
!       cn_ocerst_in= TRIM(cn_ocerst_in)//'-'//TRIM(cl_no)
! 
!       !  DRAKKAR modification : NEMO writes restart files :<CN_OCERST_INDIR>.<<nn_no>>/<CN_OCERST_IN>-<<nn_no  >>_<RANK>.nc
!       WRITE(cl_no,*) nn_no   ; cl_no = TRIM(ADJUSTL(cl_no) )
!       cn_ocerst_outdir=TRIM(cn_ocerst_outdir)//'.'//TRIM(cl_no)
!       cn_ocerst_out= TRIM(cn_ocerst_out)//'-'//TRIM(cl_no)
! !}
! 
        IF(lwp) THEN                  ! control print
           WRITE(numout,*)
           WRITE(numout,*) 'dom_nam  : domain initialization through namelist read'
--- 183,189 ----
        READ  ( numnam_cfg, namrun, IOSTAT = ios, ERR = 902 )
  902   IF( ios /= 0 )   CALL ctl_nam ( ios , 'namrun in configuration namelist', lwp )
        IF(lwm) WRITE ( numond, namrun )
!       !
        IF(lwp) THEN                  ! control print
           WRITE(numout,*)
           WRITE(numout,*) 'dom_nam  : domain initialization through namelist read'
***************
*** 226,232 ****
           WRITE(numout,*) '      additional CF standard metadata ln_cfmeta  = ', ln_cfmeta
           WRITE(numout,*) '      overwrite an existing file      ln_clobber = ', ln_clobber
           WRITE(numout,*) '      NetCDF chunksize (bytes)        nn_chunksz = ', nn_chunksz
-          WRITE(numout,*) '      Output directory                cn_dirout  = ', cn_dirout
           WRITE(numout,*) '      IS coupling at the restart step ln_iscpl   = ', ln_iscpl
        ENDIF
  
--- 214,219 ----
***************
*** 260,266 ****
--- 247,255 ----
           nwrite = nitend
        ENDIF
  
+ #if defined key_agrif
        IF( Agrif_Root() ) THEN
+ #endif
        SELECT CASE ( nleapy )        ! Choose calendar for IOIPSL
        CASE (  1 ) 
           CALL ioconf_calendar('gregorian')
***************
*** 272,278 ****
--- 261,269 ----
           CALL ioconf_calendar('360d')
           IF(lwp) WRITE(numout,*) '   The IOIPSL calendar is "360d", i.e. 360 days in a year'
        END SELECT
+ #if defined key_agrif
        ENDIF
+ #endif
  
        REWIND( numnam_ref )              ! Namelist namdom in reference namelist : space & time domain (bathymetry, mesh, timestep)
        READ  ( numnam_ref, namdom, IOSTAT = ios, ERR = 903)
diff -bic /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/DOM/domhgr.F90 /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/DOM/domhgr.F90
*** /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/DOM/domhgr.F90	Tue Apr  4 14:51:16 2017
--- /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/DOM/domhgr.F90	Fri Feb 24 15:39:23 2017
***************
*** 38,44 ****
  
     !!----------------------------------------------------------------------
     !! NEMO/OPA 3.7 , NEMO Consortium (2014)
!    !! $Id: domhgr.F90 4366 2014-01-22 14:57:03Z jchanut $ 
     !! Software governed by the CeCILL licence     (NEMOGCM/NEMO_CeCILL.txt)
     !!----------------------------------------------------------------------
  CONTAINS
--- 38,44 ----
  
     !!----------------------------------------------------------------------
     !! NEMO/OPA 3.7 , NEMO Consortium (2014)
!    !! $Id: domhgr.F90 6140 2015-12-21 11:35:23Z timgraham $ 
     !! Software governed by the CeCILL licence     (NEMOGCM/NEMO_CeCILL.txt)
     !!----------------------------------------------------------------------
  CONTAINS
***************
*** 136,151 ****
           ie1e2u_v = 0                  ! set to unread e1e2u and e1e2v
           !
           CALL hgr_read( ie1e2u_v )     ! read the coordinate.nc file
- !{ DRAKKAR : need to modify coordinates.nc file for ORCA025 according to these lines
-          IF( cp_cfg == "orca" .AND. jp_cfg == 025 ) THEN   ! ORCA R025 configuration
-             !                                              ! ======================
-             ii0 = 278   ;   ii1 =  279        ! Torres Strait (e2u = 10 km)
-             ij0 = 457   ;   ij1 =  461  ;   e2u( mi0(ii0):mi1(ii1) , mj0(ij0):mj1(ij1) ) =  10.e3
-             IF(lwp) WRITE(numout,*)
-             IF(lwp) WRITE(numout,*) '             orca_r025: Reduced e2u at the Torres Strait'
-             !
-          ENDIF
- !}
           !
           IF( ie1e2u_v == 0 ) THEN      ! e1e2u and e1e2v have not been read: compute them
              !                          ! e2u and e1v does not include a reduction in some strait: apply reduction
--- 136,141 ----
***************
*** 471,477 ****
        !!----------------------------------------------------------------------
        USE iom
        !!
!       INTEGER, INTENT( inout ) ::   ke1e2u_v   ! flag: e1e2u & e1e2v read in coordinate file (=1) or not (=0)
        !
        INTEGER ::   inum   ! temporary logical unit
        !!----------------------------------------------------------------------
--- 461,467 ----
        !!----------------------------------------------------------------------
        USE iom
        !!
!       INTEGER, INTENT( inout ) ::   ke1e2u_v   ! fag: e1e2u & e1e2v read in coordinate file (=1) or not (=0)
        !
        INTEGER ::   inum   ! temporary logical unit
        !!----------------------------------------------------------------------
diff -bic /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/DOM/dommsk.F90 /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/DOM/dommsk.F90
*** /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/DOM/dommsk.F90	Tue Apr  4 14:51:16 2017
--- /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/DOM/dommsk.F90	Fri Feb 24 15:39:23 2017
***************
*** 29,38 ****
     USE lib_mpp         !
     USE wrk_nemo        ! Memory allocation
     USE timing          ! Timing
- !{ DRAKKAR
-    USE iom             ! For shlat2d
-    USE fldread         ! for sn_shlat2d
- !}
  
     IMPLICIT NONE
     PRIVATE
--- 29,34 ----
***************
*** 48,77 ****
  #  include "vectopt_loop_substitute.h90"
     !!----------------------------------------------------------------------
     !! NEMO/OPA 3.2 , LODYC-IPSL  (2009)
!    !! $Id: dommsk.F90 4624 2014-04-28 12:09:03Z acc $ 
     !! Software governed by the CeCILL licence     (NEMOGCM/NEMO_CeCILL.txt)
     !!----------------------------------------------------------------------
  CONTAINS
     
-    INTEGER FUNCTION dom_msk_alloc()
-       !!---------------------------------------------------------------------
-       !!                 ***  FUNCTION dom_msk_alloc  ***
-       !!---------------------------------------------------------------------
-       dom_msk_alloc = 0
- #if defined key_noslip_accurate
-       ALLOCATE(icoord(jpi*jpj*jpk,3), STAT=dom_msk_alloc)
- #endif
-       IF( dom_msk_alloc /= 0 )   CALL ctl_warn('dom_msk_alloc: failed to allocate icoord array')
-       !
-    END FUNCTION dom_msk_alloc
- 
- 
     SUBROUTINE dom_msk
        !!---------------------------------------------------------------------
        !!                 ***  ROUTINE dom_msk  ***
        !!
        !! ** Purpose :   Compute land/ocean mask arrays at tracer points, hori-
!       !!      zonal velocity points (u & v), vorticity points (f) points.
        !!
        !! ** Method  :   The ocean/land mask is computed from the basin bathy-
        !!      metry in level (mbathy) which is defined or read in dommba.
--- 44,60 ----
  #  include "vectopt_loop_substitute.h90"
     !!----------------------------------------------------------------------
     !! NEMO/OPA 3.2 , LODYC-IPSL  (2009)
!    !! $Id: dommsk.F90 6140 2015-12-21 11:35:23Z timgraham $ 
     !! Software governed by the CeCILL licence     (NEMOGCM/NEMO_CeCILL.txt)
     !!----------------------------------------------------------------------
  CONTAINS
  
     SUBROUTINE dom_msk
        !!---------------------------------------------------------------------
        !!                 ***  ROUTINE dom_msk  ***
        !!
        !! ** Purpose :   Compute land/ocean mask arrays at tracer points, hori-
!       !!      zontal velocity points (u & v), vorticity points (f) points.
        !!
        !! ** Method  :   The ocean/land mask is computed from the basin bathy-
        !!      metry in level (mbathy) which is defined or read in dommba.
***************
*** 122,137 ****
        INTEGER  ::   isrow                    ! index for ORCA1 starting row
        INTEGER , POINTER, DIMENSION(:,:) ::  imsk
        REAL(wp), POINTER, DIMENSION(:,:) ::  zwf
- 
- !{ DRAKKAR
-       INTEGER  :: inum             !  logical unit for shlat2d
-       REAL(wp) :: zshlat           !: locally modified shlat for some strait
-       REAL(wp), POINTER, DIMENSION(:,:) :: zshlat2d
-       LOGICAL  :: ln_shlat2d
-       TYPE(FLD_N) :: sn_shlat2d
        !!
!       NAMELIST/namlbc/ rn_shlat, ln_vorlat, ln_shlat2d, sn_shlat2d
! !}
        !!---------------------------------------------------------------------
        !
        IF( nn_timing == 1 )  CALL timing_start('dom_msk')
--- 105,112 ----
        INTEGER  ::   isrow                    ! index for ORCA1 starting row
        INTEGER , POINTER, DIMENSION(:,:) ::  imsk
        REAL(wp), POINTER, DIMENSION(:,:) ::  zwf
        !!
!       NAMELIST/namlbc/ rn_shlat, ln_vorlat
        !!---------------------------------------------------------------------
        !
        IF( nn_timing == 1 )  CALL timing_start('dom_msk')
***************
*** 166,181 ****
           CALL ctl_stop( ctmp1 )
        ENDIF
  
- !{ DRAKKAR
-       IF ( ln_shlat2d ) THEN
-          IF(lwp) WRITE(numout,*) '         READ shlat as a 2D coefficient in a file '
-          CALL wrk_alloc( jpi, jpj, zshlat2d  )
-          CALL iom_open(sn_shlat2d%clname, inum)
-          CALL iom_get (inum, jpdom_data, sn_shlat2d%clvar, zshlat2d, 1) !
-          CALL iom_close(inum)
-       ENDIF
- !}
- 
        ! 1. Ocean/land mask at t-point (computed from mbathy)
        ! -----------------------------
        ! N.B. tmask has already the right boundary conditions since mbathy is ok
--- 141,146 ----
***************
*** 263,296 ****
                 &            * ssmask(ji,jj+1) * ssmask(ji+1,jj+1) * MIN(1._wp,SUM(fmask(ji,jj,:)))
           END DO
        END DO
- 
- !{ DRAKKAR
-       IF( cp_cfg == "orca" .AND. jp_cfg == 25 ) THEN  ! ORCA R025 configuration
-           !                                            !  =======================
-           ii0 = 212    ;   ii1 = 212        ! East of Ombai strait
-           ij0 = 464    ;   ij1 = 465   ;   fmask( mi0(ii0):mi1(ii1) , mj0(ij0):mj1(ij1), 1:jpk ) =  2.0
-           IF(lwp) WRITE(numout,*)
-           IF(lwp) WRITE(numout,*) '             orca_r025: fmask = 2 at the East Ombai Strait'
-           ii0 = 210    ;   ii1 = 211        ! West of Ombai strait
-           ij0 = 466    ;   ij1 = 466   ;   fmask( mi0(ii0):mi1(ii1) , mj0(ij0):mj1(ij1), 1:jpk ) =  2.0
-           IF(lwp) WRITE(numout,*)
-           IF(lwp) WRITE(numout,*) '             orca_r025: fmask = 2 at the West Ombai Strait '
-           ii0 = 210    ;   ii1 = 210        ! exit of Ombai strait
-           ij0 = 464    ;   ij1 = 465   ;   fmask( mi0(ii0):mi1(ii1) , mj0(ij0):mj1(ij1), 1:jpk ) =  2.0
-           IF(lwp) WRITE(numout,*)
-           IF(lwp) WRITE(numout,*) '             orca_r025: fmask = 2 at the exit of Ombai Strait '
-           ii0 = 172    ;   ii1 = 175        ! Lombok strait
-           ij0 = 463    ;   ij1 = 463   ;   fmask( mi0(ii0):mi1(ii1) , mj0(ij0):mj1(ij1), 1:jpk ) =  2.0
-           IF(lwp) WRITE(numout,*)
-           IF(lwp) WRITE(numout,*) '             orca_r025: fmask = 2 at the Lombok Strait'
-           ii0 = 278    ;   ii1 = 279        ! Torres Strait
-           ij0 = 456    ;   ij1 = 461   ;   fmask( mi0(ii0):mi1(ii1) , mj0(ij0):mj1(ij1), 1:jpk ) =  4.0
-           IF(lwp) WRITE(numout,*)
-           IF(lwp) WRITE(numout,*) '             orca_r025: fmask = 4 at the Torres Strait'
-  
-           !
-        ENDIF
- !}
        CALL lbc_lnk( umask  , 'U', 1._wp )      ! Lateral boundary conditions
        CALL lbc_lnk( vmask  , 'V', 1._wp )
        CALL lbc_lnk( fmask  , 'F', 1._wp )
--- 228,233 ----
***************
*** 313,331 ****
        ! ---------------------------------------     
        DO jk = 1, jpk
           zwf(:,:) = fmask(:,:,jk)         
- !{ DRAKKAR
-          IF (  ln_shlat2d ) THEN
-             DO jj = 2, jpjm1
-                DO ji = fs_2, fs_jpim1   ! vector opt.
-                   IF( fmask(ji,jj,jk) == 0. ) THEN
-                      fmask(ji,jj,jk) = zshlat2d(ji,jj) * MIN( 1._wp, MAX( zwf(ji+1,jj), zwf(ji,jj+1),   &
-                         &                                              zwf(ji-1,jj), zwf(ji,jj-1)  )  )
-                   ENDIF
-                END DO
-             END DO
- 
-          ELSE
- !}
              DO jj = 2, jpjm1
                 DO ji = fs_2, fs_jpim1   ! vector opt.
                    IF( fmask(ji,jj,jk) == 0._wp ) THEN
--- 250,255 ----
***************
*** 334,364 ****
                    ENDIF
                 END DO
              END DO
-          ENDIF
- !}
- 
- !{ DRAKKAR
-        ! Locally modify shlat :
-        IF( cp_cfg == "orca" .AND. jp_cfg == 025 ) THEN
-          !                                           ! =======================
-          ! Increased lateral friction in             !  ORCA_R025 configuration
-          ! the vicinity of some straits              ! =======================
-          !
-             !! Gibraltar strait and Gulf of Cadiz
-             ij0 = 652    ;   ij1 = 654
-             ii0 = 1125   ;   ii1 = 1127
-             zshlat=3
-          DO jj = mj0(ij0),mj1(ij1)
-             DO ji = mi0(ii0), mi1(ii1)
-                IF( fmask(ji,jj,jk) == 0._wp ) THEN
-                   fmask(ji,jj,jk) = zshlat * MIN( 1., MAX( zwf(ji+1,jj), zwf(ji,jj+1),   &
-                      &                                     zwf(ji-1,jj), zwf(ji,jj-1)  )  )
-                ENDIF
-             END DO
-          END DO
-          !
-        ENDIF
- !}
           DO jj = 2, jpjm1
              IF( fmask(1,jj,jk) == 0._wp ) THEN
                 fmask(1  ,jj,jk) = rn_shlat * MIN( 1._wp , MAX( zwf(2,jj), zwf(1,jj+1), zwf(1,jj-1) ) )
--- 258,263 ----
***************
*** 451,461 ****
        !
        CALL wrk_dealloc( jpi, jpj, imsk )
        CALL wrk_dealloc( jpi, jpj, zwf  )
- !{ DRAKKAR
-       IF ( ln_shlat2d ) THEN
-         CALL wrk_dealloc( jpi, jpj, zshlat2d  )
-       ENDIF
- !}
        !
        IF( nn_timing == 1 )  CALL timing_stop('dom_msk')
        !
--- 350,355 ----
diff -bic /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/DOM/domzgr.F90 /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/DOM/domzgr.F90
*** /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/DOM/domzgr.F90	Tue Apr  4 14:56:58 2017
--- /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/DOM/domzgr.F90	Fri Feb 24 15:39:23 2017
***************
*** 78,84 ****
  #  include "vectopt_loop_substitute.h90"
     !!----------------------------------------------------------------------
     !! NEMO/OPA 3.3.1 , NEMO Consortium (2011)
!    !! $Id: domzgr.F90 4687 2014-06-24 15:22:03Z acc $
     !! Software governed by the CeCILL licence     (NEMOGCM/NEMO_CeCILL.txt)
     !!----------------------------------------------------------------------
  CONTAINS       
--- 78,84 ----
  #  include "vectopt_loop_substitute.h90"
     !!----------------------------------------------------------------------
     !! NEMO/OPA 3.3.1 , NEMO Consortium (2011)
!    !! $Id: domzgr.F90 6492 2016-04-22 13:04:31Z mathiot $
     !! Software governed by the CeCILL licence     (NEMOGCM/NEMO_CeCILL.txt)
     !!----------------------------------------------------------------------
  CONTAINS       
***************
*** 388,394 ****
        !! ** Action  : - mbathy: level bathymetry (in level index)
        !!              - bathy : meter bathymetry (in meters)
        !!----------------------------------------------------------------------
!       INTEGER  ::   ji, jj, jl, jk            ! dummy loop indices
        INTEGER  ::   inum                      ! temporary logical unit
        INTEGER  ::   ierror                    ! error flag
        INTEGER  ::   ii_bump, ij_bump, ih      ! bump center position
--- 388,394 ----
        !! ** Action  : - mbathy: level bathymetry (in level index)
        !!              - bathy : meter bathymetry (in meters)
        !!----------------------------------------------------------------------
!       INTEGER  ::   ji, jj, jk            ! dummy loop indices
        INTEGER  ::   inum                      ! temporary logical unit
        INTEGER  ::   ierror                    ! error flag
        INTEGER  ::   ii_bump, ij_bump, ih      ! bump center position
***************
*** 512,519 ****
              !                                                ! =====================
              IF( cp_cfg == "orca" .AND. jp_cfg == 2 ) THEN    ! ORCA R2 configuration
                 !                                             ! =====================
! 
!                   IF ( jpk == 31 )  THEN   ! standard ORCA2 code
                       ii0 = 140   ;   ii1 = 140                  ! Gibraltar Strait open 
                       ij0 = 102   ;   ij1 = 102                  ! (Thomson, Ocean Modelling, 1995)
                       DO ji = mi0(ii0), mi1(ii1)
--- 512,518 ----
              !                                                ! =====================
              IF( cp_cfg == "orca" .AND. jp_cfg == 2 ) THEN    ! ORCA R2 configuration
                 !                                             ! =====================
!                !
                 ii0 = 140   ;   ii1 = 140                  ! Gibraltar Strait open 
                 ij0 = 102   ;   ij1 = 102                  ! (Thomson, Ocean Modelling, 1995)
                 DO ji = mi0(ii0), mi1(ii1)
***************
*** 533,564 ****
                       END DO
                       IF(lwp) WRITE(numout,*)
                       IF(lwp) WRITE(numout,*) '      orca_r2: Bab el Mandeb strait open at i=',ii0,' j=',ij0
-                   ELSE IF ( jpk == 46 ) THEN  ! L46
-                      ii0 = 140   ;   ii1 = 140                  ! Gibraltar Strait open 
-                      ij0 = 102   ;   ij1 = 102                  ! (Thomson, Ocean Modelling, 1995)
-                      DO ji = mi0(ii0), mi1(ii1)
-                         DO jj = mj0(ij0), mj1(ij1)
-                            mbathy(ji,jj) = 17
-                         END DO
-                      END DO
-                      IF(lwp) WRITE(numout,*)
-                      IF(lwp) WRITE(numout,*) '      orca_r2: Gibraltar strait open at i=',ii0,' j=',ij0
-                      !
-                      ii0 = 160   ;   ii1 = 160                  ! Bab el mandeb Strait open
-                      ij0 = 88    ;   ij1 = 88                   ! (Thomson, Ocean Modelling, 1995)
-                      DO ji = mi0(ii0), mi1(ii1)
-                         DO jj = mj0(ij0), mj1(ij1)
-                            mbathy(ji,jj) = 13
-                         END DO
-                      END DO
-                      IF(lwp) WRITE(numout,*)
-                      IF(lwp) WRITE(numout,*) '      orca_r2: Bab el Mandeb strait open at i=',ii0,' j=',ij0
- 
-                   ELSE
-                   ctmp1=' number of levels differs from 31 or 46; Update domzgr routine '
-                   CALL ctl_stop( '    zgr_bat : '//trim(ctmp1) )
-                   ENDIF
-                   
                 !
              ENDIF
              !
--- 532,537 ----
***************
*** 567,578 ****
              CALL iom_open ( 'bathy_meter.nc', inum ) 
              IF ( ln_isfcav ) THEN
                 CALL iom_get  ( inum, jpdom_data, 'Bathymetry_isf', bathy, lrowattr=.false. )
-                ! fix for pb
-                DO ji= mi0(1007+141),mi1(1007+141)
-                  DO jj=mj0(482), mj1(482)
-                     bathy(ji,jj)= 0.
-                  ENDDO
-                ENDDO
              ELSE
                 CALL iom_get  ( inum, jpdom_data, 'Bathymetry'    , bathy, lrowattr=ln_use_jattr  )
              END IF
--- 540,545 ----
***************
*** 582,597 ****
              risfdep(:,:)=0._wp ; misfdep(:,:)=1             
              !
              IF ( ln_isfcav ) THEN
! !              CALL iom_open ( 'isf_draft_meter.nc', inum ) 
!                CALL iom_open ( 'bathy_meter.nc', inum ) 
                 CALL iom_get  ( inum, jpdom_data, 'isf_draft', risfdep )
                 CALL iom_close( inum )
                 WHERE( bathy(:,:) <= 0._wp )  risfdep(:,:) = 0._wp
  
                 ! set grounded point to 0 
                 ! (a treshold could be set here if needed, or set it offline based on the grounded fraction)
!                !JMM fix :                                      ----------------------------
!                WHERE ( bathy(:,:) <= risfdep(:,:) + rn_isfhmin .AND. risfdep(:,:) > 0._wp  )
                    misfdep(:,:) = 0 ; risfdep(:,:) = 0._wp
                    mbathy (:,:) = 0 ; bathy  (:,:) = 0._wp
                 END WHERE
--- 549,562 ----
              risfdep(:,:)=0._wp ; misfdep(:,:)=1             
              !
              IF ( ln_isfcav ) THEN
!                CALL iom_open ( 'isf_draft_meter.nc', inum ) 
                 CALL iom_get  ( inum, jpdom_data, 'isf_draft', risfdep )
                 CALL iom_close( inum )
                 WHERE( bathy(:,:) <= 0._wp )  risfdep(:,:) = 0._wp
  
                 ! set grounded point to 0 
                 ! (a treshold could be set here if needed, or set it offline based on the grounded fraction)
!                WHERE ( bathy(:,:) <= risfdep(:,:) + rn_isfhmin )
                    misfdep(:,:) = 0 ; risfdep(:,:) = 0._wp
                    mbathy (:,:) = 0 ; bathy  (:,:) = 0._wp
                 END WHERE
***************
*** 1272,1279 ****
  ! run the bathy check 10 times to be sure all the modif in the bathy or iceshelf draft are compatible together
        DO jl = 1, 10     
           ! check at each iteration if isf is grounded or not (1cm treshold have to be update after first coupling experiments)
!          !JMM fix :                                      ----------------------------
!          WHERE (bathy(:,:) <= risfdep(:,:) + rn_isfhmin .AND. risfdep(:,:) > 0._wp )
              misfdep(:,:) = 0 ; risfdep(:,:) = 0._wp
              mbathy (:,:) = 0 ; bathy  (:,:) = 0._wp
           END WHERE
--- 1237,1243 ----
  ! run the bathy check 10 times to be sure all the modif in the bathy or iceshelf draft are compatible together
        DO jl = 1, 10     
           ! check at each iteration if isf is grounded or not (1cm treshold have to be update after first coupling experiments)
!          WHERE (bathy(:,:) <= risfdep(:,:) + rn_isfhmin)
              misfdep(:,:) = 0 ; risfdep(:,:) = 0._wp
              mbathy (:,:) = 0 ; bathy  (:,:) = 0._wp
           END WHERE
***************
*** 2238,2249 ****
--- 2202,2215 ----
          WHERE( e3vw_0(:,:,:) == 0._wp )   e3vw_0(:,:,:) = 1._wp
        END IF
  
+ #if defined key_agrif
        IF( .NOT. Agrif_Root() ) THEN    ! Ensure meaningful vertical scale factors in ghost lines/columns
           IF( nbondi == -1 .OR. nbondi == 2 )   e3u_0(  1   ,  :   ,:) = e3u_0(  2   ,  :   ,:)
           IF( nbondi ==  1 .OR. nbondi == 2 )   e3u_0(nlci-1,  :   ,:) = e3u_0(nlci-2,  :   ,:)
           IF( nbondj == -1 .OR. nbondj == 2 )   e3v_0(  :   ,  1   ,:) = e3v_0(  :   ,  2   ,:)
           IF( nbondj ==  1 .OR. nbondj == 2 )   e3v_0(  :   ,nlcj-1,:) = e3v_0(  :   ,nlcj-2,:)
         ENDIF
+ #endif
  
  !!gm   I don't like that HERE we are supposed to set the reference coordinate (i.e. _0 arrays)
  !!gm   and only that !!!!!
***************
*** 2305,2327 ****
           WRITE(numout,"(9x,' level  gdept_0   gdepw_0   e3t_0    e3w_0')")
           WRITE(numout,"(10x,i4,4f9.2)") ( jk, gdept_0(1,1,jk), gdepw_0(1,1,jk),     &
              &                                 e3t_0 (1,1,jk) , e3w_0 (1,1,jk) , jk=1,jpk )
!          iip1 = MIN(20, jpiglo-1)  ! for config with i smaller than 20 points
!          ijp1 = MIN(20, jpjglo-1)  ! for config with j smaller than 20 points
!          DO jj = mj0(ijp1), mj1(ijp1)
!             DO ji = mi0(iip1), mi1(iip1)
                 WRITE(numout,*)
!                WRITE(numout,*) ' domzgr: vertical coordinates : point (',iip1,',',ijp1,',k)   bathy = ',  &
!                   &                                              bathy(ji,jj), hbatt(ji,jj)
                 WRITE(numout,*) ' ~~~~~~  --------------------'
                 WRITE(numout,"(9x,' level  gdept_0   gdepw_0   e3t_0    e3w_0')")
                 WRITE(numout,"(10x,i4,4f9.2)") ( jk, gdept_0(ji,jj,jk), gdepw_0(ji,jj,jk),     &
                    &                                 e3t_0 (ji,jj,jk) , e3w_0 (ji,jj,jk) , jk=1,jpk )
              END DO
           END DO
!          iip1 = MIN(  74, jpiglo-1)
!          ijp1 = MIN( 100, jpjglo-1)
!          DO jj = mj0(ijp1), mj1(ijp1)
!             DO ji = mi0(iip1), mi1(iip1)
                 WRITE(numout,*)
                 WRITE(numout,*) ' domzgr: vertical coordinates : point (100,74,k)   bathy = ', bathy(ji,jj), hbatt(ji,jj)
                 WRITE(numout,*) ' ~~~~~~  --------------------'
--- 2271,2288 ----
           WRITE(numout,"(9x,' level  gdept_0   gdepw_0   e3t_0    e3w_0')")
           WRITE(numout,"(10x,i4,4f9.2)") ( jk, gdept_0(1,1,jk), gdepw_0(1,1,jk),     &
              &                                 e3t_0 (1,1,jk) , e3w_0 (1,1,jk) , jk=1,jpk )
!          DO jj = mj0(20), mj1(20)
!             DO ji = mi0(20), mi1(20)
                 WRITE(numout,*)
!                WRITE(numout,*) ' domzgr: vertical coordinates : point (20,20,k)   bathy = ', bathy(ji,jj), hbatt(ji,jj)
                 WRITE(numout,*) ' ~~~~~~  --------------------'
                 WRITE(numout,"(9x,' level  gdept_0   gdepw_0   e3t_0    e3w_0')")
                 WRITE(numout,"(10x,i4,4f9.2)") ( jk, gdept_0(ji,jj,jk), gdepw_0(ji,jj,jk),     &
                    &                                 e3t_0 (ji,jj,jk) , e3w_0 (ji,jj,jk) , jk=1,jpk )
              END DO
           END DO
!          DO jj = mj0(74), mj1(74)
!             DO ji = mi0(100), mi1(100)
                 WRITE(numout,*)
                 WRITE(numout,*) ' domzgr: vertical coordinates : point (100,74,k)   bathy = ', bathy(ji,jj), hbatt(ji,jj)
                 WRITE(numout,*) ' ~~~~~~  --------------------'
***************
*** 2331,2345 ****
              END DO
           END DO
        ENDIF
! 
! !================================================================================
! ! check the coordinate makes sense
! !================================================================================
! !JMM : missing check on lwp prior writing on numout
! !###################################################
        DO ji = 1, jpi
           DO jj = 1, jpj
! 
              IF( hbatt(ji,jj) > 0._wp) THEN
                 DO jk = 1, mbathy(ji,jj)
                   ! check coordinate is monotonically increasing
--- 2292,2304 ----
              END DO
           END DO
        ENDIF
!       !
!       !================================================================================
!       ! check the coordinate makes sense
!       !================================================================================
        DO ji = 1, jpi
           DO jj = 1, jpj
!             !
              IF( hbatt(ji,jj) > 0._wp) THEN
                 DO jk = 1, mbathy(ji,jj)
                   ! check coordinate is monotonically increasing
diff -bic /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/DOM/dtatsd.F90 /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/DOM/dtatsd.F90
*** /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/DOM/dtatsd.F90	Tue Apr  4 14:51:16 2017
--- /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/DOM/dtatsd.F90	Fri Feb 24 15:39:23 2017
***************
*** 32,49 ****
     LOGICAL , PUBLIC ::   ln_tsd_init      !: T & S data flag
     LOGICAL , PUBLIC ::   ln_tsd_tradmp    !: internal damping toward input data flag
  
! #if ! defined key_agrif
!    TYPE(FLD), ALLOCATABLE, DIMENSION(:), TARGET ::   sf_tsd_ini   ! structure of input TS ini (file informations, fields read)
!    TYPE(FLD), ALLOCATABLE, DIMENSION(:), TARGET ::   sf_tsd_dmp   ! structure of input TS dmp (file informations, fields read)
! #else
!    TYPE(FLD), ALLOCATABLE, DIMENSION(:)         ::   sf_tsd_ini   ! structure of input TS ini (file informations, fields read)
!    TYPE(FLD), ALLOCATABLE, DIMENSION(:)         ::   sf_tsd_dmp   ! structure of input TS dmp (file informations, fields read)
! #endif
! 
  
     !!----------------------------------------------------------------------
     !! NEMO/OPA 3.3 , NEMO Consortium (2010)
!    !! $Id: dtatem.F90 2392 2010-11-15 21:20:05Z gm $ 
     !! Software governed by the CeCILL licence     (NEMOGCM/NEMO_CeCILL.txt)
     !!----------------------------------------------------------------------
  CONTAINS
--- 32,42 ----
     LOGICAL , PUBLIC ::   ln_tsd_init      !: T & S data flag
     LOGICAL , PUBLIC ::   ln_tsd_tradmp    !: internal damping toward input data flag
  
!    TYPE(FLD), ALLOCATABLE, DIMENSION(:) ::   sf_tsd   ! structure of input SST (file informations, fields read)
  
     !!----------------------------------------------------------------------
     !! NEMO/OPA 3.3 , NEMO Consortium (2010)
!    !! $Id: dtatsd.F90 6140 2015-12-21 11:35:23Z timgraham $ 
     !! Software governed by the CeCILL licence     (NEMOGCM/NEMO_CeCILL.txt)
     !!----------------------------------------------------------------------
  CONTAINS
***************
*** 62,73 ****
        INTEGER ::   ierr0, ierr1, ierr2, ierr3   ! temporary integers
        !
        CHARACTER(len=100)            ::   cn_dir          ! Root directory for location of ssr files
!       TYPE(FLD_N), DIMENSION( jpts) ::   slf_i_ini       ! array of namelist informations on the fields to read
!       TYPE(FLD_N), DIMENSION( jpts) ::   slf_i_dmp       ! array of namelist informations on the fields to read
!       TYPE(FLD_N)                   ::   sn_tem_ini, sn_sal_ini
!       TYPE(FLD_N)                   ::   sn_tem_dmp, sn_sal_dmp
        !!
!       NAMELIST/namtsd/   ln_tsd_init, ln_tsd_tradmp, cn_dir, sn_tem_ini, sn_sal_ini, sn_tem_dmp, sn_sal_dmp
        INTEGER  ::   ios
        !!----------------------------------------------------------------------
        !
--- 55,64 ----
        INTEGER ::   ierr0, ierr1, ierr2, ierr3   ! temporary integers
        !
        CHARACTER(len=100)            ::   cn_dir          ! Root directory for location of ssr files
!       TYPE(FLD_N), DIMENSION( jpts) ::   slf_i           ! array of namelist informations on the fields to read
!       TYPE(FLD_N)                   ::   sn_tem, sn_sal
        !!
!       NAMELIST/namtsd/   ln_tsd_init, ln_tsd_tradmp, cn_dir, sn_tem, sn_sal
        INTEGER  ::   ios
        !!----------------------------------------------------------------------
        !
***************
*** 95,107 ****
           WRITE(numout,*) '      Initialisation of ocean T & S with T &S input data   ln_tsd_init   = ', ln_tsd_init
           WRITE(numout,*) '      damping of ocean T & S toward T &S input data        ln_tsd_tradmp = ', ln_tsd_tradmp
           WRITE(numout,*)
!          IF( .NOT.ln_tsd_init ) THEN
!             WRITE(numout,*)
!             WRITE(numout,*) '   T & S initial data not used'
!          ENDIF
!          IF( .NOT. ln_tsd_tradmp ) THEN
              WRITE(numout,*)
!             WRITE(numout,*) '   T & S damping data not used'
           ENDIF
        ENDIF
        !
--- 86,94 ----
           WRITE(numout,*) '      Initialisation of ocean T & S with T &S input data   ln_tsd_init   = ', ln_tsd_init
           WRITE(numout,*) '      damping of ocean T & S toward T &S input data        ln_tsd_tradmp = ', ln_tsd_tradmp
           WRITE(numout,*)
!          IF( .NOT.ln_tsd_init .AND. .NOT.ln_tsd_tradmp ) THEN
              WRITE(numout,*)
!             WRITE(numout,*) '   T & S data not used'
           ENDIF
        ENDIF
        !
***************
*** 111,156 ****
           ln_tsd_init = .FALSE.
        ENDIF
        !
!       !                             ! allocate the arrays (if necessary) ( initial state)
!       IF( ln_tsd_init  ) THEN
!          !
!          ALLOCATE( sf_tsd_ini(jpts), STAT=ierr0 )
!          IF( ierr0 > 0 ) THEN
!             CALL ctl_stop( 'dta_tsd_init: unable to allocate sf_tsd_ini structure' )   ;   RETURN
!          ENDIF
!          !
!                                     ALLOCATE( sf_tsd_ini(jp_tem)%fnow(jpi,jpj,jpk)   , STAT=ierr0 )
!          IF( sn_tem_ini%ln_tint )   ALLOCATE( sf_tsd_ini(jp_tem)%fdta(jpi,jpj,jpk,2) , STAT=ierr1 )
!                                     ALLOCATE( sf_tsd_ini(jp_sal)%fnow(jpi,jpj,jpk)   , STAT=ierr2 )
!          IF( sn_sal_ini%ln_tint )   ALLOCATE( sf_tsd_ini(jp_sal)%fdta(jpi,jpj,jpk,2) , STAT=ierr3 )
!          !
!          IF( ierr0 + ierr1 + ierr2 + ierr3 > 0 ) THEN
!             CALL ctl_stop( 'dta_tsd : unable to allocate initial T & S data arrays' )   ;   RETURN
!          ENDIF
!          !                         ! fill sf_tsd with sn_tem & sn_sal and control print
!          slf_i_ini(jp_tem) = sn_tem_ini   ;   slf_i_ini(jp_sal) = sn_sal_ini
!          CALL fld_fill( sf_tsd_ini, slf_i_ini, cn_dir, 'dta_tsd', 'Initial Temperature & Salinity data', 'namtsd' )
!          !
!       ENDIF
!       !                             ! allocate the arrays (if necessary) ( restoring )
!       IF( ln_tsd_tradmp  ) THEN
           !
!          ALLOCATE( sf_tsd_dmp(jpts), STAT=ierr0 )
           IF( ierr0 > 0 ) THEN
              CALL ctl_stop( 'dta_tsd_init: unable to allocate sf_tsd structure' )   ;   RETURN
           ENDIF
           !
!                                     ALLOCATE( sf_tsd_dmp(jp_tem)%fnow(jpi,jpj,jpk)   , STAT=ierr0 )
!          IF( sn_tem_dmp%ln_tint )   ALLOCATE( sf_tsd_dmp(jp_tem)%fdta(jpi,jpj,jpk,2) , STAT=ierr1 )
!                                     ALLOCATE( sf_tsd_dmp(jp_sal)%fnow(jpi,jpj,jpk)   , STAT=ierr2 )
!          IF( sn_sal_dmp%ln_tint )   ALLOCATE( sf_tsd_dmp(jp_sal)%fdta(jpi,jpj,jpk,2) , STAT=ierr3 )
           !
           IF( ierr0 + ierr1 + ierr2 + ierr3 > 0 ) THEN
!             CALL ctl_stop( 'dta_tsd : unable to allocate damping T & S data arrays' )   ;   RETURN
           ENDIF
           !                         ! fill sf_tsd with sn_tem & sn_sal and control print
!          slf_i_dmp(jp_tem) = sn_tem_dmp   ;   slf_i_dmp(jp_sal) = sn_sal_dmp
!          CALL fld_fill( sf_tsd_dmp, slf_i_dmp, cn_dir, 'dta_tsd', 'Damping Temperature & Salinity data', 'namtsd' )
           !
        ENDIF
        !
--- 98,122 ----
           ln_tsd_init = .FALSE.
        ENDIF
        !
!       !                             ! allocate the arrays (if necessary)
!       IF(  ln_tsd_init .OR. ln_tsd_tradmp  ) THEN
           !
!          ALLOCATE( sf_tsd(jpts), STAT=ierr0 )
           IF( ierr0 > 0 ) THEN
              CALL ctl_stop( 'dta_tsd_init: unable to allocate sf_tsd structure' )   ;   RETURN
           ENDIF
           !
!                                 ALLOCATE( sf_tsd(jp_tem)%fnow(jpi,jpj,jpk)   , STAT=ierr0 )
!          IF( sn_tem%ln_tint )   ALLOCATE( sf_tsd(jp_tem)%fdta(jpi,jpj,jpk,2) , STAT=ierr1 )
!                                 ALLOCATE( sf_tsd(jp_sal)%fnow(jpi,jpj,jpk)   , STAT=ierr2 )
!          IF( sn_sal%ln_tint )   ALLOCATE( sf_tsd(jp_sal)%fdta(jpi,jpj,jpk,2) , STAT=ierr3 )
           !
           IF( ierr0 + ierr1 + ierr2 + ierr3 > 0 ) THEN
!             CALL ctl_stop( 'dta_tsd : unable to allocate T & S data arrays' )   ;   RETURN
           ENDIF
           !                         ! fill sf_tsd with sn_tem & sn_sal and control print
!          slf_i(jp_tem) = sn_tem   ;   slf_i(jp_sal) = sn_sal
!          CALL fld_fill( sf_tsd, slf_i, cn_dir, 'dta_tsd', 'Temperature & Salinity data', 'namtsd' )
           !
        ENDIF
        !
***************
*** 181,197 ****
        INTEGER ::   ik, il0, il1, ii0, ii1, ij0, ij1   ! local integers
        REAL(wp)::   zl, zi
        REAL(wp),  POINTER, DIMENSION(:) ::  ztp, zsp   ! 1D workspace
-       TYPE(FLD), POINTER, DIMENSION(:) ::  sf_tsd     ! structure of input TS dmp (file informations, fields read)
- 
        !!----------------------------------------------------------------------
        !
        IF( nn_timing == 1 )  CALL timing_start('dta_tsd')
- 
-       IF ( ln_tsd_init ) THEN   ! when called for initialization ( from istate)
-          sf_tsd => sf_tsd_ini
-       ELSE                      ! called from tradmp
-          sf_tsd => sf_tsd_dmp
-       ENDIF
        !
        CALL fld_read( kt, 1, sf_tsd )      !==   read T & S data at kt time step   ==!
        !
--- 147,155 ----
***************
*** 289,304 ****
           !
        ENDIF
        !
!       IF( ln_tsd_init ) THEN                   !==   deallocate T & S structure   ==! 
           !                                              (data used only for initialisation)
!          IF(lwp) WRITE(numout,*) 'dta_tsd: deallocate initial T & S arrays as they are only use to initialize the run'
!                                             DEALLOCATE( sf_tsd_ini(jp_tem)%fnow )     ! T arrays in the structure
!          IF( sf_tsd_ini(jp_tem)%ln_tint )   DEALLOCATE( sf_tsd_ini(jp_tem)%fdta )
!                                             DEALLOCATE( sf_tsd_ini(jp_sal)%fnow )     ! S arrays in the structure
!          IF( sf_tsd_ini(jp_sal)%ln_tint )   DEALLOCATE( sf_tsd_ini(jp_sal)%fdta )
!                                             DEALLOCATE( sf_tsd_ini              )     ! the structure itself
!          ! un-set ln_tsd_init for further call
!          ln_tsd_init =.FALSE.
        ENDIF
        !
        IF( nn_timing == 1 )  CALL timing_stop('dta_tsd')
--- 247,260 ----
           !
        ENDIF
        !
!       IF( .NOT.ln_tsd_tradmp ) THEN                   !==   deallocate T & S structure   ==! 
           !                                              (data used only for initialisation)
!          IF(lwp) WRITE(numout,*) 'dta_tsd: deallocte T & S arrays as they are only use to initialize the run'
!                                         DEALLOCATE( sf_tsd(jp_tem)%fnow )     ! T arrays in the structure
!          IF( sf_tsd(jp_tem)%ln_tint )   DEALLOCATE( sf_tsd(jp_tem)%fdta )
!                                         DEALLOCATE( sf_tsd(jp_sal)%fnow )     ! S arrays in the structure
!          IF( sf_tsd(jp_sal)%ln_tint )   DEALLOCATE( sf_tsd(jp_sal)%fdta )
!                                         DEALLOCATE( sf_tsd              )     ! the structure itself
        ENDIF
        !
        IF( nn_timing == 1 )  CALL timing_stop('dta_tsd')
diff -bic /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/DOM/istate.F90 /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/DOM/istate.F90
*** /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/DOM/istate.F90	Tue Apr  4 14:56:58 2017
--- /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/DOM/istate.F90	Fri Feb 24 15:39:23 2017
***************
*** 106,116 ****
              CALL istate_gyre                     ! GYRE  configuration : start from pre-defined T-S fields
           ELSE                                    ! Initial T-S, U-V fields read in files
              IF ( ln_tsd_init ) THEN              ! read 3D T and S data at nit000
-                tsb(:,:,:,:)= -99.d0
                 CALL dta_tsd( nit000, tsb )  
                 tsn(:,:,:,:) = tsb(:,:,:,:)
- !              PRINT '(a,i5,4e14.3)', ' NAREA', narea, minval(tsb(:,:,:,jp_tem)*tmask,(tmask /= 0) ), maxval(tsb(:,:,:,jp_tem)*tmask,(tmask /= 0) ), &
- !                                                      minval(tsb(:,:,:,jp_sal)*tmask,(tmask /= 0) ),maxval( tsb(:,:,:,jp_sal)*tmask,(tmask /= 0))
                 !
              ELSE                                 ! Initial T-S fields defined analytically
                 CALL istate_t_s
--- 106,113 ----
Only in /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/DYN: .gitkeep
Only in /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/FLO: .gitkeep
Only in /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/ICB: .gitkeep
diff -bic /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/ICB/icb_oce.F90 /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/ICB/icb_oce.F90
*** /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/ICB/icb_oce.F90	Tue Apr  4 14:56:58 2017
--- /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/ICB/icb_oce.F90	Fri Feb 24 15:39:23 2017
***************
*** 44,50 ****
  
     INTEGER, PUBLIC, PARAMETER ::   nclasses = 10   !: Number of icebergs classes   
     INTEGER, PUBLIC, PARAMETER ::   nkounts  =  3   !: Number of integers combined for unique naming
-    INTEGER, PUBLIC, PARAMETER ::   nsectors = 10   !: Number of origin sectors. Initial value is the maximum for iom.F90 axis definition
  
     TYPE, PUBLIC ::   icebergs_gridded   !: various icebergs properties on model grid
        REAL(wp), DIMENSION(:,:)  , ALLOCATABLE ::   calving         ! Calving mass rate  (into stored ice)         [kg/s]
--- 44,49 ----
***************
*** 69,77 ****
     TYPE, PUBLIC ::   iceberg            !: linked list defining all the icebergs present in the model domain
        TYPE(iceberg), POINTER      ::   prev=>NULL(), next=>NULL()   ! pointers to previous and next unique icebergs in linked list
        INTEGER, DIMENSION(nkounts) ::   number                       ! variables which do not change for this iceberg
-       INTEGER                     ::   origin = 0                   ! Number of origin box correspondin to Sectors_Boxes
-       REAL(wp)                    ::   lon_origin                   ! Longitude from wich iceberg was released
-       REAL(wp)                    ::   lat_origin                   ! Latitude from wich iceberg was released 
        REAL(wp)                    ::   mass_scaling                 !    -        -            -                -  
        TYPE(point), POINTER        ::   current_point => NULL()      ! variables which change with time are held in a separate type
     END TYPE iceberg
--- 68,73 ----
***************
*** 86,93 ****
     LOGICAL                             ::   l_restarted_bergs=.FALSE.  ! Indicate whether we read state from a restart or not
     !                                                               ! arbitrary numbers for diawri entry
     REAL(wp), DIMENSION(nclasses), PUBLIC ::   class_num=(/ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 /)
-    REAL(wp), DIMENSION(nsectors), PUBLIC ::   sectors_num=(/ 1, 2, 3, 4, 5, 6, 7,8, 9, 10 /)
-  !  REAL(wp), DIMENSION(:), ALLOCATABLE, PUBLIC ::   sectors_num !To be allocate and initilized afeter reading namelist in icbini
  
     ! Extra arrays with bigger halo, needed when interpolating forcing onto iceberg position
     ! particularly for MPP when iceberg can lie inside T grid but outside U, V, or f grid
--- 82,87 ----
***************
*** 127,150 ****
     LOGICAL , PUBLIC ::   ln_passive_mode                 !: iceberg - ocean decoupling
     LOGICAL , PUBLIC ::   ln_time_average_weight          !: Time average the weight on the ocean    !!gm I don't understand that !
     REAL(wp), PUBLIC ::   rn_speed_limit                  !: CFL speed limit for a berg
-    LOGICAL , PUBLIC ::   ln_restart_boxes                !: Recompute the origin of each iceberg after restart
-    !
-    INTEGER , PUBLIC ::   nn_sectors_boxes          = 0         !: Turn on definition of boxes for icebergs origin sectors
-    REAL(wp), PUBLIC, TARGET, DIMENSION(4) ::   rn_box_1 = (/ 0._wp, 1._wp, 0._wp, 1._wp /)   !: lon1,lon2,lat1,lat2 sector box
-    REAL(wp), PUBLIC, TARGET, DIMENSION(4) ::   rn_box_2 = (/ 0._wp, 1._wp, 0._wp, 1._wp/)   !: lon1,lon2,lat1,lat2 sector box
-    REAL(wp), PUBLIC, Target, DIMENSION(4) ::   rn_box_3 = (/ 0._wp, 1._wp, 0._wp,1._wp/)   !: lon1,lon2,lat1,lat2 sector box
-    REAL(wp), PUBLIC, TARGET, DIMENSION(4) ::   rn_box_4 = (/ 0._wp, 1._wp, 0._wp,1._wp/)   !: lon1,lon2,lat1,lat2 sector box
-    REAL(wp), PUBLIC, TARGET, DIMENSION(4) ::   rn_box_5 = (/ 0._wp, 1._wp, 0._wp,1._wp/)   !: lon1,lon2,lat1,lat2 sector box
-    REAL(wp), PUBLIC, TARGET, DIMENSION(4) ::   rn_box_6 = (/ 0._wp, 1._wp, 0._wp,1._wp/)   !: lon1,lon2,lat1,lat2 sector box
-    REAL(wp), PUBLIC, TARGET, DIMENSION(4) ::   rn_box_7 = (/ 0._wp, 1._wp, 0._wp,1._wp/)   !: lon1,lon2,lat1,lat2 sector box
-    REAL(wp), PUBLIC, TARGET, DIMENSION(4) ::   rn_box_8 = (/ 0._wp, 1._wp, 0._wp,1._wp/)   !: lon1,lon2,lat1,lat2 sector box
-    REAL(wp), PUBLIC, TARGET, DIMENSION(4) ::   rn_box_9 = (/ 0._wp, 1._wp, 0._wp,1._wp/)   !: lon1,lon2,lat1,lat2 sector box
-    REAL(wp), PUBLIC, TARGET, DIMENSION(4) ::   rn_box_10 = (/ 0._wp, 1._wp, 0._wp,1._wp/)   !: lon1,lon2,lat1,lat2 sector box
- 
-    TYPE sector_box 
-          REAL(wp), PUBLIC, DIMENSION(:), POINTER :: box
-    END TYPE
-    TYPE (sector_box), PUBLIC, DIMENSION(10) :: Sector_Boxes
     !
     !                                     ! Mass thresholds between iceberg classes [kg]
     REAL(wp), DIMENSION(nclasses), PUBLIC ::   rn_initial_mass      ! Fraction of calving to apply to this class [non-dim]
--- 121,126 ----
***************
*** 167,174 ****
  
     REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:,:)   :: griddata                           !: work array for icbrst
  
-    CHARACTER(LEN=255), PUBLIC  :: cn_icbrst_in, cn_icbrst_out, cn_icbdir_trj
- 
     !!----------------------------------------------------------------------
     !! NEMO/OPA 3.3 , NEMO Consortium (2011)
     !! $Id: icb_oce.F90 6140 2015-12-21 11:35:23Z timgraham $
--- 143,148 ----
diff -bic /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/ICB/icbclv.F90 /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/ICB/icbclv.F90
*** /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/ICB/icbclv.F90	Tue Apr  4 14:56:58 2017
--- /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/ICB/icbclv.F90	Fri Feb 24 15:39:23 2017
***************
*** 151,159 ****
                    !
                    CALL icb_utl_incr()
                    newberg%number(:) = num_bergs(:)
-                   newberg%origin = icb_utl_origin(newpt%lat, newpt%lon)
-                   newberg%lat_origin = newpt%lat
-                   newberg%lon_origin = newpt%lon
                    !
                    CALL icb_utl_add( newberg, newpt )
                    !
--- 151,156 ----
diff -bic /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/ICB/icbdia.F90 /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/ICB/icbdia.F90
*** /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/ICB/icbdia.F90	Tue Apr  4 14:56:58 2017
--- /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/ICB/icbdia.F90	Fri Feb 24 15:39:23 2017
***************
*** 36,43 ****
     PUBLIC   icb_dia_calve     ! routine called in icbclv.F90 module
     PUBLIC   icb_dia_income    ! routine called in icbclv.F90 module
  
!    REAL(wp), DIMENSION(:,:)  , ALLOCATABLE, PUBLIC  ::   berg_melt       ! Melting+erosion rate of icebergs     [kg/s/m2]a
!    REAL(wp), DIMENSION(:,:,:)  , ALLOCATABLE, PUBLIC  ::   berg_sectors_melt       !Melting+erosion rate of icebergs per origin sector     [kg/s/m2] !NACHO MERINO
     REAL(wp), DIMENSION(:,:)  , ALLOCATABLE, PUBLIC  ::   buoy_melt       ! Buoyancy component of melting rate   [kg/s/m2]
     REAL(wp), DIMENSION(:,:)  , ALLOCATABLE, PUBLIC  ::   eros_melt       ! Erosion component of melting rate    [kg/s/m2]
     REAL(wp), DIMENSION(:,:)  , ALLOCATABLE, PUBLIC  ::   conv_melt       ! Convective component of melting rate [kg/s/m2]
--- 36,42 ----
     PUBLIC   icb_dia_calve     ! routine called in icbclv.F90 module
     PUBLIC   icb_dia_income    ! routine called in icbclv.F90 module
  
!    REAL(wp), DIMENSION(:,:)  , ALLOCATABLE, PUBLIC  ::   berg_melt       ! Melting+erosion rate of icebergs     [kg/s/m2]
     REAL(wp), DIMENSION(:,:)  , ALLOCATABLE, PUBLIC  ::   buoy_melt       ! Buoyancy component of melting rate   [kg/s/m2]
     REAL(wp), DIMENSION(:,:)  , ALLOCATABLE, PUBLIC  ::   eros_melt       ! Erosion component of melting rate    [kg/s/m2]
     REAL(wp), DIMENSION(:,:)  , ALLOCATABLE, PUBLIC  ::   conv_melt       ! Convective component of melting rate [kg/s/m2]
***************
*** 88,94 ****
        IF( .NOT. ln_bergdia ) RETURN
  
        ALLOCATE( berg_melt    (jpi,jpj)   )           ;   berg_melt   (:,:)   = 0._wp
-       ALLOCATE( berg_sectors_melt    (jpi,jpj,nsectors)   )           ;   berg_sectors_melt   (:,:,:)   = 0._wp !NACHO MERINO
        ALLOCATE( buoy_melt    (jpi,jpj)   )           ;   buoy_melt   (:,:)   = 0._wp
        ALLOCATE( eros_melt    (jpi,jpj)   )           ;   eros_melt   (:,:)   = 0._wp
        ALLOCATE( conv_melt    (jpi,jpj)   )           ;   conv_melt   (:,:)   = 0._wp
--- 87,92 ----
***************
*** 353,359 ****
        !
        IF( .NOT. ln_bergdia ) RETURN
        berg_melt    (:,:)   = 0._wp
-       berg_sectors_melt (:,:,:) = 0._wp
        buoy_melt    (:,:)   = 0._wp
        eros_melt    (:,:)   = 0._wp
        conv_melt    (:,:)   = 0._wp
--- 351,356 ----
***************
*** 374,380 ****
        IF( .NOT. ln_bergdia )   RETURN            !!gm useless iom will control whether it is output or not
        !
        CALL iom_put( "berg_melt"        , berg_melt   (:,:)   )   ! Melt rate of icebergs                     [kg/m2/s]
-       CALL iom_put( "berg_sectors_melt", berg_sectors_melt   (:,:,:)   )   ! Melt rate oficebergs per origin sector   [kg/m2/s]
        CALL iom_put( "berg_buoy_melt"   , buoy_melt   (:,:)   )   ! Buoyancy component of iceberg melt rate   [kg/m2/s]
        CALL iom_put( "berg_eros_melt"   , eros_melt   (:,:)   )   ! Erosion component of iceberg melt rate    [kg/m2/s]
        CALL iom_put( "berg_conv_melt"   , conv_melt   (:,:)   )   ! Convective component of iceberg melt rate [kg/m2/s]
--- 371,376 ----
***************
*** 464,483 ****
  
     SUBROUTINE icb_dia_melt(ki, kj, pmnew, pheat, pmass_scale,   &
        &                   pdM, pdMbitsE, pdMbitsM, pdMb, pdMe,   &
!       &                   pdMv, pz1_dt_e1e2, kSector )
        !!----------------------------------------------------------------------
        !!----------------------------------------------------------------------
!       INTEGER , INTENT(in) ::   ki, kj, kSector
        REAL(wp), INTENT(in) ::   pmnew, pheat, pmass_scale
        REAL(wp), INTENT(in) ::   pdM, pdMbitsE, pdMbitsM, pdMb, pdMe, pdMv, pz1_dt_e1e2
        !!----------------------------------------------------------------------
        !
        IF( .NOT. ln_bergdia ) RETURN
-       IF( nn_sectors_boxes .gt. 0) then
-           if (kSector.gt.0) then
-                 berg_sectors_melt(ki,kj,kSector) =  berg_sectors_melt (ki,kj,kSector) + pdM  *pz1_dt_e1e2   ! kg/m2/s
-           ENDIF
-       ENDIF
  
        berg_melt (ki,kj) = berg_melt (ki,kj) + pdM      * pz1_dt_e1e2   ! kg/m2/s
        bits_src  (ki,kj) = bits_src  (ki,kj) + pdMbitsE * pz1_dt_e1e2   ! mass flux into bergy bitskg/m2/s
--- 460,474 ----
  
     SUBROUTINE icb_dia_melt(ki, kj, pmnew, pheat, pmass_scale,   &
        &                   pdM, pdMbitsE, pdMbitsM, pdMb, pdMe,   &
!       &                   pdMv, pz1_dt_e1e2 )
        !!----------------------------------------------------------------------
        !!----------------------------------------------------------------------
!       INTEGER , INTENT(in) ::   ki, kj
        REAL(wp), INTENT(in) ::   pmnew, pheat, pmass_scale
        REAL(wp), INTENT(in) ::   pdM, pdMbitsE, pdMbitsM, pdMb, pdMe, pdMv, pz1_dt_e1e2
        !!----------------------------------------------------------------------
        !
        IF( .NOT. ln_bergdia ) RETURN
  
        berg_melt (ki,kj) = berg_melt (ki,kj) + pdM      * pz1_dt_e1e2   ! kg/m2/s
        bits_src  (ki,kj) = bits_src  (ki,kj) + pdMbitsE * pz1_dt_e1e2   ! mass flux into bergy bitskg/m2/s
diff -bic /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/ICB/icbdyn.F90 /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/ICB/icbdyn.F90
*** /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/ICB/icbdyn.F90	Tue Apr  4 14:56:58 2017
--- /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/ICB/icbdyn.F90	Fri Feb 24 15:39:23 2017
***************
*** 45,52 ****
        REAL(wp)                        ::   zuvel3 , zvvel3 , zu3, zv3, zax3, zay3, zxi3 , zyj3
        REAL(wp)                        ::   zuvel4 , zvvel4 , zu4, zv4, zax4, zay4, zxi4 , zyj4
        REAL(wp)                        ::   zuvel_n, zvvel_n, zxi_n   , zyj_n
!       REAL(wp)                        ::   zdt, zdt_2, zdt_6, ze1, ze2, zT, zD
!       INTEGER                         ::   ii,ij
        LOGICAL                         ::   ll_bounced
        TYPE(iceberg), POINTER          ::   berg
        TYPE(point)  , POINTER          ::   pt
--- 45,51 ----
        REAL(wp)                        ::   zuvel3 , zvvel3 , zu3, zv3, zax3, zay3, zxi3 , zyj3
        REAL(wp)                        ::   zuvel4 , zvvel4 , zu4, zv4, zax4, zay4, zxi4 , zyj4
        REAL(wp)                        ::   zuvel_n, zvvel_n, zxi_n   , zyj_n
!       REAL(wp)                        ::   zdt, zdt_2, zdt_6, ze1, ze2
        LOGICAL                         ::   ll_bounced
        TYPE(iceberg), POINTER          ::   berg
        TYPE(point)  , POINTER          ::   pt
***************
*** 83,99 ****
           zxi1 = pt%xi   ;   zuvel1 = pt%uvel     !**   X1 in (i,j)  ;  V1 in m/s
           zyj1 = pt%yj   ;   zvvel1 = pt%vvel
  
- !-----MODIF Nacho Merino, dealing with icebergs grounded with the bathymetry.
- !Vel=0 imposed adn cycle
-          zT = berg%current_point%thickness               ! total thickness
-          zD = ( rn_rho_bergs / pp_rho_seawater ) * zT    ! draught (keel depth)
- 
-          ii  = INT( zxi1 +0.5 )   ;   ij  = INT( zyj1 +0.5 )       ! current
- 
-          ii  = mi1( ii  )
-          ij  = mj1( ij  )
  
- !!!!END MODIF!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
           !                                         !**   A1 = A(X1,V1)
           CALL icb_accel( berg , zxi1, ze1, zuvel1, zuvel1, zax1,     &
              &                   zyj1, ze2, zvvel1, zvvel1, zay1, zdt_2 )
--- 82,88 ----
***************
*** 109,115 ****
           zyj2 = zyj1 + zdt_2 * zv1          ;   zvvel2 = zvvel1 + zdt_2 * zay1
           !
           CALL icb_ground( zxi2, zxi1, zu1,   &
!          &                zyj2, zyj1, zv1, ll_bounced, zD)
  
           !                                         !**   A2 = A(X2,V2)
           CALL icb_accel( berg , zxi2, ze1, zuvel2, zuvel1, zax2,    &
--- 98,104 ----
           zyj2 = zyj1 + zdt_2 * zv1          ;   zvvel2 = zvvel1 + zdt_2 * zay1
           !
           CALL icb_ground( zxi2, zxi1, zu1,   &
!          &                zyj2, zyj1, zv1, ll_bounced )
  
           !                                         !**   A2 = A(X2,V2)
           CALL icb_accel( berg , zxi2, ze1, zuvel2, zuvel1, zax2,    &
***************
*** 125,131 ****
           zyj3  = zyj1  + zdt_2 * zv2   ;   zvvel3 = zvvel1 + zdt_2 * zay2
           !
           CALL icb_ground( zxi3, zxi1, zu3,   &
!          &                zyj3, zyj1, zv3, ll_bounced, zD )
  
           !                                         !**   A3 = A(X3,V3)
           CALL icb_accel( berg , zxi3, ze1, zuvel3, zuvel1, zax3,    &
--- 114,120 ----
           zyj3  = zyj1  + zdt_2 * zv2   ;   zvvel3 = zvvel1 + zdt_2 * zay2
           !
           CALL icb_ground( zxi3, zxi1, zu3,   &
!          &                zyj3, zyj1, zv3, ll_bounced )
  
           !                                         !**   A3 = A(X3,V3)
           CALL icb_accel( berg , zxi3, ze1, zuvel3, zuvel1, zax3,    &
***************
*** 141,147 ****
           zyj4 = zyj1 + zdt * zv3   ;   zvvel4 = zvvel1 + zdt * zay3
  
           CALL icb_ground( zxi4, zxi1, zu4,   &
!          &                zyj4, zyj1, zv4, ll_bounced, zD )
  
           !                                         !**   A4 = A(X4,V4)
           CALL icb_accel( berg , zxi4, ze1, zuvel4, zuvel1, zax4,    &
--- 130,136 ----
           zyj4 = zyj1 + zdt * zv3   ;   zvvel4 = zvvel1 + zdt * zay3
  
           CALL icb_ground( zxi4, zxi1, zu4,   &
!          &                zyj4, zyj1, zv4, ll_bounced )
  
           !                                         !**   A4 = A(X4,V4)
           CALL icb_accel( berg , zxi4, ze1, zuvel4, zuvel1, zax4,    &
***************
*** 160,166 ****
           zvvel_n = pt%vvel + zdt_6 * (  zay1 + 2.*(zay2 + zay3) + zay4 )
  
           CALL icb_ground( zxi_n, zxi1, zuvel_n,   &
!          &                      zyj_n, zyj1, zvvel_n, ll_bounced, zD )
  
           pt%uvel = zuvel_n                        !** save in berg structure
           pt%vvel = zvvel_n
--- 149,155 ----
           zvvel_n = pt%vvel + zdt_6 * (  zay1 + 2.*(zay2 + zay3) + zay4 )
  
           CALL icb_ground( zxi_n, zxi1, zuvel_n,   &
!          &                      zyj_n, zyj1, zvvel_n, ll_bounced )
  
           pt%uvel = zuvel_n                        !** save in berg structure
           pt%vvel = zvvel_n
***************
*** 179,185 ****
  
  
     SUBROUTINE icb_ground( pi, pi0, pu,   &
!       &                         pj, pj0, pv, ld_bounced, zD )
        !!----------------------------------------------------------------------
        !!                  ***  ROUTINE icb_ground  ***
        !!
--- 168,174 ----
  
  
     SUBROUTINE icb_ground( pi, pi0, pu,   &
!       &                         pj, pj0, pv, ld_bounced )
        !!----------------------------------------------------------------------
        !!                  ***  ROUTINE icb_ground  ***
        !!
***************
*** 189,195 ****
        !!                NB two possibilities available one of which is hard-coded here
        !!----------------------------------------------------------------------
        REAL(wp), INTENT(inout) ::   pi , pj      ! current iceberg position
!       REAL(wp), INTENT(in   ) ::   pi0, pj0, zD     ! previous iceberg position
        REAL(wp), INTENT(inout) ::   pu  , pv     ! current iceberg velocities
        LOGICAL , INTENT(  out) ::   ld_bounced   ! bounced indicator
        !
--- 178,184 ----
        !!                NB two possibilities available one of which is hard-coded here
        !!----------------------------------------------------------------------
        REAL(wp), INTENT(inout) ::   pi , pj      ! current iceberg position
!       REAL(wp), INTENT(in   ) ::   pi0, pj0     ! previous iceberg position
        REAL(wp), INTENT(inout) ::   pu  , pv     ! current iceberg velocities
        LOGICAL , INTENT(  out) ::   ld_bounced   ! bounced indicator
        !
***************
*** 206,235 ****
        IF( ii == ii0  .AND.  ij == ij0  )   RETURN           ! berg remains in the same cell
        !
        ! map into current processor
- !MODIF Nacho
- !MODIF Nacho
- 
-       if (ii.lt.mig(1)) then
-         ii = 1
-       else if (ii.gt.mig(jpi)) then
-         ii = jpi
-       else
-       ii  = mi1( ii  )
-       end if
- 
-       if (ij.lt.mjg(1)) then
-         ij = 1
-       else if (ij.gt.mjg(jpj)) then
-         ij = jpj
-       else
-       ij  = mj1( ij  )
-       end if
- 
- 
        ii0 = mi1( ii0 )
        ij0 = mj1( ij0 )
!       !ii  = mi1( ii  )
!       !ij  = mj1( ij  )
        !
        IF(  tmask(ii,ij,1)  /=   0._wp  )   RETURN           ! berg reach a new t-cell, but an ocean one
        !
--- 195,204 ----
        IF( ii == ii0  .AND.  ij == ij0  )   RETURN           ! berg remains in the same cell
        !
        ! map into current processor
        ii0 = mi1( ii0 )
        ij0 = mj1( ij0 )
!       ii  = mi1( ii  )
!       ij  = mj1( ij  )
        !
        IF(  tmask(ii,ij,1)  /=   0._wp  )   RETURN           ! berg reach a new t-cell, but an ocean one
        !
***************
*** 288,295 ****
        REAL(wp), PARAMETER ::   pp_accel_lim = 1.e-2_wp   ! max allowed berg acceleration
        REAL(wp), PARAMETER ::   pp_Cr0       = 0.06_wp    !
        !
!       INTEGER  ::   itloop, kLevel, ii ,ij
!       REAL(wp) ::   zuo,  zuoSurf, zvo, zvoSurf,  zui, zvi, zua, zva, zuwave,zvwave, zssh_x, zssh_y, zsst, zcn, zhi
        REAL(wp) ::   zff, zT, zD, zW, zL, zM, zF
        REAL(wp) ::   zdrag_ocn, zdrag_atm, zdrag_ice, zwave_rad
        REAL(wp) ::   z_ocn, z_atm, z_ice
--- 257,264 ----
        REAL(wp), PARAMETER ::   pp_accel_lim = 1.e-2_wp   ! max allowed berg acceleration
        REAL(wp), PARAMETER ::   pp_Cr0       = 0.06_wp    !
        !
!       INTEGER  ::   itloop
!       REAL(wp) ::   zuo, zvo, zui, zvi, zua, zva, zuwave, zvwave, zssh_x, zssh_y, zsst, zcn, zhi
        REAL(wp) ::   zff, zT, zD, zW, zL, zM, zF
        REAL(wp) ::   zdrag_ocn, zdrag_atm, zdrag_ice, zwave_rad
        REAL(wp) ::   z_ocn, z_atm, z_ice
***************
*** 309,337 ****
        zF = zT - zD                                    ! freeboard
        zW = berg%current_point%width
        zL = berg%current_point%length
- !MODIF Compute numer of levels touching (only taking into account levels where
- !center point is reached
-       kLevel = 1
-       DO WHILE (gdept_1d(kLevel) .lt. zD)
-         kLevel = kLevel + 1
-       END DO
- 
-       ii  = INT( pxi +0.5 )   ;   ij  = INT( pyj +0.5 )
-       ii  = mi1( ii  )
-       ij  = mj1( ij  )
- 
- !end modif
-       zuoSurf = zuo
-       zvoSurf = zvo
-       CALL icb_utl_velocityIntegral(kLevel, pxi, zuo, pyj, zvo )
- 
- !print *, 'Comparacion',  zuoSurf,  'ahora',  zuo, kLevel
  
        zhi   = MIN( zhi   , zD    )
        zD_hi = MAX( 0._wp, zD-zhi )
  
        ! Wave radiation
!       zuwave = zua - zuoSurf   ;   zvwave = zva - zvoSurf     ! Use wind speed rel. to ocean for wave model
        zwmod  = zuwave*zuwave + zvwave*zvwave          ! The wave amplitude and length depend on the  current;
        !                                               ! wind speed relative to the ocean. Actually wmod is wmod**2 here.
        zampl        = 0.5 * 0.02025 * zwmod            ! This is "a", the wave amplitude
--- 278,289 ----
        zF = zT - zD                                    ! freeboard
        zW = berg%current_point%width
        zL = berg%current_point%length
  
        zhi   = MIN( zhi   , zD    )
        zD_hi = MAX( 0._wp, zD-zhi )
  
        ! Wave radiation
!       zuwave = zua - zuo   ;   zvwave = zva - zvo     ! Use wind speed rel. to ocean for wave model
        zwmod  = zuwave*zuwave + zvwave*zvwave          ! The wave amplitude and length depend on the  current;
        !                                               ! wind speed relative to the ocean. Actually wmod is wmod**2 here.
        zampl        = 0.5 * 0.02025 * zwmod            ! This is "a", the wave amplitude
diff -bic /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/ICB/icbini.F90 /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/ICB/icbini.F90
*** /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/ICB/icbini.F90	Tue Apr  4 14:56:58 2017
--- /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/ICB/icbini.F90	Fri Feb 24 15:39:23 2017
***************
*** 77,83 ****
        !                          ! open ascii output file or files for iceberg status information
        !                          ! note that we choose to do this on all processors since we cannot
        !                          ! predict where icebergs will be ahead of time
!       CALL ctl_opn( numicb, 'icebergs.stat', 'REPLACE', 'FORMATTED', 'SEQUENTIAL', -1, numout, lwp, narea, TRIM(cn_icbdir_trj) )
  
        ! set parameters (mostly from namelist)
        !
--- 77,83 ----
        !                          ! open ascii output file or files for iceberg status information
        !                          ! note that we choose to do this on all processors since we cannot
        !                          ! predict where icebergs will be ahead of time
!       CALL ctl_opn( numicb, 'icebergs.stat', 'REPLACE', 'FORMATTED', 'SEQUENTIAL', -1, numout, lwp, narea )
  
        ! set parameters (mostly from namelist)
        !
***************
*** 261,270 ****
           ELSE
              CALL icb_rst_read()
              l_restarted_bergs = .TRUE.
-             !NACHO MERINO redifining sectors of icebergs if reauired
-             IF (ln_restart_boxes) THEN
-                 CALL icb_utl_redefine_origin()
-             ENDIF
           ENDIF
        ENDIF
        !
--- 261,266 ----
***************
*** 361,374 ****
           &              rn_rho_bergs   , rn_LoW_ratio   , nn_verbose_level    , ln_operator_splitting,   &
           &              rn_bits_erosion_fraction        , rn_sicn_shift       , ln_passive_mode      ,   &
           &              ln_time_average_weight          , nn_test_icebergs    , rn_test_box          ,   &
!          &              rn_speed_limit , nn_sectors_boxes, rn_box_1, rn_box_2 , rn_box_3             ,   &
!          &              rn_box_4       , rn_box_5, rn_box_6, rn_box_7, rn_box_8, rn_box_9            ,   &
!          &              rn_box_10      , ln_restart_boxes,             cn_dir, sn_icb                ,   &
!          &              cn_icbrst_in,  cn_icbrst_out, cn_icbdir_trj
        !!----------------------------------------------------------------------
- !{ DRAKKAR
-       CHARACTER(LEN=20) :: cl_no
- !}
  
  #if !defined key_agrif
        REWIND( numnam_ref )              ! Namelist namberg in reference namelist : Iceberg parameters
--- 357,364 ----
           &              rn_rho_bergs   , rn_LoW_ratio   , nn_verbose_level    , ln_operator_splitting,   &
           &              rn_bits_erosion_fraction        , rn_sicn_shift       , ln_passive_mode      ,   &
           &              ln_time_average_weight          , nn_test_icebergs    , rn_test_box          ,   &
!          &              rn_speed_limit , cn_dir, sn_icb
        !!----------------------------------------------------------------------
  
  #if !defined key_agrif
        REWIND( numnam_ref )              ! Namelist namberg in reference namelist : Iceberg parameters
***************
*** 396,433 ****
           RETURN
        ENDIF
  
-       ! Add extension (job number to the restart dir. Differ for restart input and restart output
- !{ DRAKKAR modification : NEMO reads restart files :<CN_ICERST_INDIR>.<<nn_no-1>>/<CN_ICERST_IN>-<<nn_no -1 >>_<RANK>.nc
-       WRITE(cl_no,*) nn_no-1 ; cl_no = TRIM(ADJUSTL(cl_no) )
-       cn_icbrst_in= TRIM(cn_icbrst_in)//'-'//TRIM(cl_no)
- 
- !  DRAKKAR modification : NEMO write restart files :<CN_ICERST_OUTDIR>.<<nn_no>>/<CN_ICERST_OUT>-<<nn_no >>_<RANK>.nc
-       WRITE(cl_no,*) nn_no   ; cl_no = TRIM(ADJUSTL(cl_no) )
-       cn_icbrst_out= TRIM(cn_icbrst_out)//'-'//TRIM(cl_no)
- !     cn_icbdir_trj= TRIM(cn_icbdir_trj)//'-'//TRIM(cl_no)
- !}
- 
- !!!!!!NACHO MERINO  Allocate and initialize sector_num array in order to
- !configure axis icbsect
-       !DEALLOCATE(sectors_num)
- 
- !      ALLOCATE(sectors_num(nn_sectors_boxes))
- !      DO jn=1,nn_sectors_boxes
- !          sectors_num(jn) = jn
- !      ENDDO
-       
- !PRINT *, 'just before of init axis'
- !       CALL iom_init_icb_axis()
- !PRINT *, 'out of init axis'
- !!!!!!!!!!-------------------------------------------------------------
- 
- 
-       ! Initializing Sector Boxes array of pointers (icb_oce) NACHO MERINO
-       IF ( nn_sectors_boxes .gt. 0) THEN
-         Sector_Boxes(1)%box=>rn_box_1; Sector_Boxes(2)%box=>rn_box_2; Sector_Boxes(3)%box=>rn_box_3; Sector_Boxes(4)%box=>rn_box_4; Sector_Boxes(5)%box=>rn_box_5
-         Sector_Boxes(6)%box=>rn_box_6; Sector_Boxes(7)%box=>rn_box_7; Sector_Boxes(8)%box=>rn_box_8; Sector_Boxes(9)%box=>rn_box_9; Sector_Boxes(10)%box=>rn_box_10
-       END IF
-       !!!!!!!!!!!!
        IF( nn_test_icebergs > nclasses ) THEN
            IF(lwp) WRITE(numout,*) 'Resetting nn_test_icebergs to ', nclasses
            nn_test_icebergs = nclasses
--- 386,391 ----
Only in /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/ICB: icbini.F90.48784
diff -bic /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/ICB/icblbc.F90 /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/ICB/icblbc.F90
*** /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/ICB/icblbc.F90	Tue Apr  4 14:56:58 2017
--- /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/ICB/icblbc.F90	Fri Feb 24 15:39:23 2017
***************
*** 812,822 ****
        pbuff%data(14,kb) = berg%current_point%heat_density
  
        pbuff%data(15,kb) = berg%mass_scaling
-       pbuff%data(16,kb) = float(berg%origin)
-       pbuff%data(17,kb) = berg%lon_origin
-       pbuff%data(18,kb) = berg%lat_origin
        DO k=1,nkounts
!          pbuff%data(18+k,kb) = REAL( berg%number(k), wp )
        END DO
        !
     END SUBROUTINE icb_pack_into_buffer
--- 812,819 ----
        pbuff%data(14,kb) = berg%current_point%heat_density
  
        pbuff%data(15,kb) = berg%mass_scaling
        DO k=1,nkounts
!          pbuff%data(15+k,kb) = REAL( berg%number(k), wp )
        END DO
        !
     END SUBROUTINE icb_pack_into_buffer
***************
*** 850,860 ****
        pt%heat_density   =      pbuff%data(14,kb)
  
        currentberg%mass_scaling =      pbuff%data(15,kb)
-       currentberg%origin =     INT(pbuff%data(16,kb))
-       currentberg%lon_origin =      pbuff%data(17,kb)
-       currentberg%lat_origin =      pbuff%data(18,kb)
        DO ik = 1, nkounts
!          currentberg%number(ik) = INT( pbuff%data(18+ik,kb) )
        END DO
        !
        CALL icb_utl_add(currentberg, pt )
--- 847,854 ----
        pt%heat_density   =      pbuff%data(14,kb)
  
        currentberg%mass_scaling =      pbuff%data(15,kb)
        DO ik = 1, nkounts
!          currentberg%number(ik) = INT( pbuff%data(15+ik,kb) )
        END DO
        !
        CALL icb_utl_add(currentberg, pt )
diff -bic /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/ICB/icbrst.F90 /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/ICB/icbrst.F90
*** /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/ICB/icbrst.F90	Tue Apr  4 14:56:58 2017
--- /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/ICB/icbrst.F90	Fri Feb 24 15:39:23 2017
***************
*** 33,39 ****
     PUBLIC   icb_rst_read    ! routine called in icbini.F90 module
     PUBLIC   icb_rst_write   ! routine called in icbstp.F90 module
     
!    INTEGER ::   nlonid, nlatid, nlonorigid, nlatorigid, norigid, nxid, nyid, nuvelid, nvvelid
     INTEGER ::   nmassid, nthicknessid, nwidthid, nlengthid
     INTEGER ::   nyearid, ndayid
     INTEGER ::   nscaling_id, nmass_of_bits_id, nheat_density_id, numberid
--- 33,39 ----
     PUBLIC   icb_rst_read    ! routine called in icbini.F90 module
     PUBLIC   icb_rst_write   ! routine called in icbstp.F90 module
     
!    INTEGER ::   nlonid, nlatid, nxid, nyid, nuvelid, nvvelid
     INTEGER ::   nmassid, nthicknessid, nwidthid, nlengthid
     INTEGER ::   nyearid, ndayid
     INTEGER ::   nscaling_id, nmass_of_bits_id, nheat_density_id, numberid
***************
*** 73,80 ****
        ! and are called TRIM(cn_ocerst)//'_icebergs'
        cl_path = TRIM(cn_ocerst_indir)
        IF( cl_path(LEN_TRIM(cl_path):) /= '/' ) cl_path = TRIM(cl_path) // '/'
! !     cl_filename = TRIM(cn_ocerst_in)//'_icebergs'
!       cl_filename = TRIM(cn_icbrst_in)
        CALL iom_open( TRIM(cl_path)//cl_filename, ncid )
  
        IF( iom_file(ncid)%iduld .GE. 0) THEN
--- 73,79 ----
        ! and are called TRIM(cn_ocerst)//'_icebergs'
        cl_path = TRIM(cn_ocerst_indir)
        IF( cl_path(LEN_TRIM(cl_path):) /= '/' ) cl_path = TRIM(cl_path) // '/'
!       cl_filename = TRIM(cn_ocerst_in)//'_icebergs'
        CALL iom_open( TRIM(cl_path)//cl_filename, ncid )
  
        IF( iom_file(ncid)%iduld .GE. 0) THEN
***************
*** 99,108 ****
                 CALL iom_get( ncid, 'mass_scaling' , localberg%mass_scaling, ktime=jn )
                 CALL iom_get( ncid, 'lon'          , localpt%lon           , ktime=jn )
                 CALL iom_get( ncid, 'lat'          , localpt%lat           , ktime=jn )
-                CALL iom_get( ncid, 'lon_origin'   , localberg%lon_origin  , ktime=jn )
-                CALL iom_get( ncid, 'lat_origin'   , localberg%lat_origin  , ktime=jn )
-                CALL iom_get( ncid, 'origin'       , zdata(1)              , ktime=jn )
-                localberg%origin = INT(zdata(1) )
                 CALL iom_get( ncid, 'uvel'         , localpt%uvel          , ktime=jn )
                 CALL iom_get( ncid, 'vvel'         , localpt%vvel          , ktime=jn )
                 CALL iom_get( ncid, 'mass'         , localpt%mass          , ktime=jn )
--- 98,103 ----
***************
*** 114,130 ****
                 CALL iom_get( ncid, 'day'          , localpt%day           , ktime=jn )
                 CALL iom_get( ncid, 'mass_of_bits' , localpt%mass_of_bits  , ktime=jn )
                 CALL iom_get( ncid, 'heat_density' , localpt%heat_density  , ktime=jn )
- !NACHO
- !        nret = NF90_INQ_VARID(ncid, 'lon_origin', nlonorigid)
- !         nret = NF90_INQ_VARID(ncid, 'lat_origin', nlatorigid)
- !         nret = NF90_INQ_VARID(ncid, 'origin', norigid)
- !...
- !            nret = NF90_GET_VAR(ncid, nlonorigid, zdata, istrt, ilngth)
- !            localberg%lon_origin = zdata(1)
- !            nret = NF90_GET_VAR(ncid, nlatorigid, zdata, istrt, ilngth)
- !            localberg%lat_origin = zdata(1)
- !           nret = NF90_GET_VAR(ncid, norigid, zdata, istrt, ilngth)
- !NACHO
  
                 !
                 CALL icb_utl_add( localberg, localpt )
--- 109,114 ----
***************
*** 183,190 ****
        cl_path = TRIM(cn_ocerst_outdir)
        IF( cl_path(LEN_TRIM(cl_path):) /= '/' ) cl_path = TRIM(cl_path) // '/'
        IF( lk_mpp ) THEN
! !        WRITE(cl_filename,'(A,"_icebergs_",I8.8,"_restart_",I4.4,".nc")') TRIM(cexper), kt, narea-1
!          WRITE(cl_filename,'(a,"_",I4.4,".nc")') TRIM(cn_icbrst_out), narea-1
        ELSE
           WRITE(cl_filename,'(A,"_icebergs_",I8.8,"_restart.nc")') TRIM(cexper), kt
        ENDIF
--- 167,173 ----
        cl_path = TRIM(cn_ocerst_outdir)
        IF( cl_path(LEN_TRIM(cl_path):) /= '/' ) cl_path = TRIM(cl_path) // '/'
        IF( lk_mpp ) THEN
!          WRITE(cl_filename,'(A,"_icebergs_",I8.8,"_restart_",I4.4,".nc")') TRIM(cexper), kt, narea-1
        ELSE
           WRITE(cl_filename,'(A,"_icebergs_",I8.8,"_restart.nc")') TRIM(cexper), kt
        ENDIF
***************
*** 250,258 ****
           ! Variables
           nret = NF90_DEF_VAR(ncid, 'lon', NF90_DOUBLE, in_dim, nlonid)
           nret = NF90_DEF_VAR(ncid, 'lat', NF90_DOUBLE, in_dim, nlatid)
-          nret = NF90_DEF_VAR(ncid, 'lon_origin', NF90_DOUBLE, in_dim, nlonorigid)
-          nret = NF90_DEF_VAR(ncid, 'lat_origin', NF90_DOUBLE, in_dim, nlatorigid)
-          nret = NF90_DEF_VAR(ncid, 'origin', NF90_INT, in_dim, norigid)
           nret = NF90_DEF_VAR(ncid, 'xi', NF90_DOUBLE, in_dim, nxid)
           nret = NF90_DEF_VAR(ncid, 'yj', NF90_DOUBLE, in_dim, nyid)
           nret = NF90_DEF_VAR(ncid, 'uvel', NF90_DOUBLE, in_dim, nuvelid)
--- 233,238 ----
***************
*** 273,282 ****
           nret = NF90_PUT_ATT(ncid, nlonid, 'units', 'degrees_E')
           nret = NF90_PUT_ATT(ncid, nlatid, 'long_name', 'latitude')
           nret = NF90_PUT_ATT(ncid, nlatid, 'units', 'degrees_N')
-          nret = NF90_PUT_ATT(ncid, nlonorigid, 'long_name', 'longitude of calving point')
-          nret = NF90_PUT_ATT(ncid, nlonorigid, 'units', 'degrees_E')
-          nret = NF90_PUT_ATT(ncid, nlatorigid, 'long_name', 'latitude of calving point')
-          nret = NF90_PUT_ATT(ncid, nlatorigid, 'units', 'degrees_N')
           nret = NF90_PUT_ATT(ncid, nxid, 'long_name', 'x grid box position')
           nret = NF90_PUT_ATT(ncid, nxid, 'units', 'fractional')
           nret = NF90_PUT_ATT(ncid, nyid, 'long_name', 'y grid box position')
--- 253,258 ----
***************
*** 360,368 ****
  
              nret = NF90_PUT_VAR(ncid, nlonid, pt%lon, (/ jn /) )
              nret = NF90_PUT_VAR(ncid, nlatid, pt%lat, (/ jn /) )
-             nret = NF90_PUT_VAR(ncid, nlonorigid, this%lon_origin, (/ jn /) )
-             nret = NF90_PUT_VAR(ncid, nlatorigid, this%lat_origin, (/ jn /) )
-             nret = NF90_PUT_VAR(ncid, norigid, this%origin, (/ jn /) )
              nret = NF90_PUT_VAR(ncid, nxid, pt%xi, (/ jn /) )
              nret = NF90_PUT_VAR(ncid, nyid, pt%yj, (/ jn /) )
              nret = NF90_PUT_VAR(ncid, nuvelid, pt%uvel, (/ jn /) )
--- 336,341 ----
diff -bic /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/ICB/icbstp.F90 /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/ICB/icbstp.F90
*** /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/ICB/icbstp.F90	Tue Apr  4 14:56:58 2017
--- /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/ICB/icbstp.F90	Fri Feb 24 15:39:23 2017
***************
*** 139,145 ****
        IF( nn_verbose_write > 0 .AND. MOD(kt-1,nn_verbose_write) == 0 )   ll_budget = ln_bergdia
        CALL icb_dia( ll_budget )
  
!       IF( MOD(kt,nstock) == 0 ) THEN
           CALL icb_rst_write( kt )
           IF( nn_sample_rate > 0 )   CALL icb_trj_sync()
        ENDIF
--- 139,145 ----
        IF( nn_verbose_write > 0 .AND. MOD(kt-1,nn_verbose_write) == 0 )   ll_budget = ln_bergdia
        CALL icb_dia( ll_budget )
  
!       IF( MOD(kt,nn_stock) == 0 ) THEN
           CALL icb_rst_write( kt )
           IF( nn_sample_rate > 0 )   CALL icb_trj_sync()
        ENDIF
***************
*** 160,166 ****
        !!----------------------------------------------------------------------
  
        ! only write a restart if not done in icb_stp
!       IF( MOD(kt,nstock) .NE. 0 ) CALL icb_rst_write( kt )
  
        ! finish with trajectories if they were written
        IF( nn_sample_rate .GT. 0 ) CALL icb_trj_end()
--- 160,166 ----
        !!----------------------------------------------------------------------
  
        ! only write a restart if not done in icb_stp
!       IF( MOD(kt,nn_stock) .NE. 0 ) CALL icb_rst_write( kt )
  
        ! finish with trajectories if they were written
        IF( nn_sample_rate .GT. 0 ) CALL icb_trj_end()
diff -bic /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/ICB/icbthm.F90 /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/ICB/icbthm.F90
*** /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/ICB/icbthm.F90	Tue Apr  4 14:56:58 2017
--- /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/ICB/icbthm.F90	Fri Feb 24 15:39:23 2017
***************
*** 43,50 ****
        !!----------------------------------------------------------------------
        INTEGER, INTENT(in) ::   kt   ! timestep number, just passed to icb_utl_print_berg
        !
!       INTEGER  ::   ii, ij, kLevel, iSector
!       REAL(wp) ::   zM, zT, zD, zW, zL, zSST, zVol, zLn, zWn, zTn, znVol, zIC, zDn
        REAL(wp) ::   zMv, zMe, zMb, zmelt, zdvo, zdva, zdM, zSs, zdMe, zdMb, zdMv
        REAL(wp) ::   zMnew, zMnew1, zMnew2, zheat
        REAL(wp) ::   zMbits, znMbits, zdMbitsE, zdMbitsM, zLbits, zAbits, zMbb
--- 43,50 ----
        !!----------------------------------------------------------------------
        INTEGER, INTENT(in) ::   kt   ! timestep number, just passed to icb_utl_print_berg
        !
!       INTEGER  ::   ii, ij
!       REAL(wp) ::   zM, zT, zW, zL, zSST, zVol, zLn, zWn, zTn, znVol, zIC, zDn
        REAL(wp) ::   zMv, zMe, zMb, zmelt, zdvo, zdva, zdM, zSs, zdMe, zdMb, zdMv
        REAL(wp) ::   zMnew, zMnew1, zMnew2, zheat
        REAL(wp) ::   zMbits, znMbits, zdMbitsE, zdMbitsM, zLbits, zAbits, zMbb
***************
*** 66,72 ****
        this => first_berg
        DO WHILE( associated(this) )
           !
-          iSector = this%origin  !NACHO MERINO
           pt => this%current_point
           nknberg = this%number(1)
           CALL icb_utl_interp( pt%xi, pt%e1, pt%uo, pt%ui, pt%ua, pt%ssh_x, &
--- 66,71 ----
***************
*** 77,136 ****
           zIC  = MIN( 1._wp, pt%cn + rn_sicn_shift )     ! Shift sea-ice concentration       !!gm ???
           zM   = pt%mass
           zT   = pt%thickness                               ! total thickness
!          zD   = (rn_rho_bergs/pp_rho_seawater)*zT ! draught (keel depth)
!          
!          !MODIF Compute numer of levels touching (only taking into account
!          !levels where
!          !center point is reached
!          kLevel = 1
!          DO WHILE (gdept_1d(kLevel) .lt. zD)
!             kLevel = kLevel + 1
!          END DO
! 
! 
!          !zF   = zT - D ! freeboard
           zW   = pt%width
           zL   = pt%length
           zxi  = pt%xi                                      ! position in (i,j) referential
           zyj  = pt%yj
           ii  = INT( zxi + 0.5 )                            ! T-cell of the berg
-          ij  = INT( zyj + 0.5 ) 
-         if (ij.lt.1) then
-                 print *, 'error j icbthm()', ij, jpjglo
-                 ij = jpjglo - (1-ij)
-         end if
- 
-         if (ij.gt.jpjglo) then
-                 print *, 'error j icbthm()', ij, jpjglo
-                 ij = 1 + (ij-jpjglo)
-         end if
- 
-         if (ii.lt.1) then
-                 print *, 'error i icbthm()', ii, jpiglo
-                 ii = jpiglo - (1-ii)
-         end if
- 
-         if (ii.gt.jpiglo) then
-                 print *, 'error i icbthm()', ii, jpiglo
-                 ii = 1 + (ii-jpiglo)
-         end if
- 
           ii  = mi1( ii )             
           ij  = mj1( ij )
           zVol = zT * zW * zL
           zdt = berg_dt   ;   z1_dt = 1._wp / zdt
  
           ! Environment
!          !zdvo = SQRT( (pt%uvel-pt%uo)**2 + (pt%vvel-pt%vo)**2 )
           zdva = SQRT( (pt%ua  -pt%uo)**2 + (pt%va  -pt%vo)**2 )
           zSs  = 1.5 * SQRT( zdva ) + 0.1 * zdva                ! Sea state      (eqn M.A9)
  
           ! Melt rates in m/s (i.e. division by rday)
! !MODIF NACHO MERINO  Icbergs melting rates Basal and Bouyant compute in 3D temperature field
!          !zMv = MAX( 7.62e-3*zSST+1.29e-3*(zSST**2)            , 0._wp ) * z1_rday   ! Buoyant convection at sides (eqn M.A10)
!          !zMb = MAX( 0.58*(zdvo**0.8)*(zSST+4.0)/(zL**0.2)      , 0._wp ) * z1_rday   ! Basal turbulent melting     (eqn M.A7 )
!          CALL icb_utl_basalMelting(kLevel, zxi, pt%uvel, zyj, pt%vvel, zL, z1_rday, zMb )
!          CALL icb_utl_boyantConvectionMelt(kLevel, zxi, zyj, z1_rday, zMv )
           zMe = MAX( 1./12.*(zSST+2.)*zSs*(1+cos(rpi*(zIC**3))) , 0._wp ) * z1_rday   ! Wave erosion                (eqn M.A8 )
  
           IF( ln_operator_splitting ) THEN      ! Operator split update of volume/mass
--- 76,102 ----
           zIC  = MIN( 1._wp, pt%cn + rn_sicn_shift )     ! Shift sea-ice concentration       !!gm ???
           zM   = pt%mass
           zT   = pt%thickness                               ! total thickness
!        ! D   = (rn_rho_bergs/pp_rho_seawater)*zT ! draught (keel depth)
!        ! F   = zT - D ! freeboard
           zW   = pt%width
           zL   = pt%length
           zxi  = pt%xi                                      ! position in (i,j) referential
           zyj  = pt%yj
           ii  = INT( zxi + 0.5 )                            ! T-cell of the berg
           ii  = mi1( ii )
+          ij  = INT( zyj + 0.5 )              
           ij  = mj1( ij )
           zVol = zT * zW * zL
           zdt = berg_dt   ;   z1_dt = 1._wp / zdt
  
           ! Environment
!          zdvo = SQRT( (pt%uvel-pt%uo)**2 + (pt%vvel-pt%vo)**2 )
           zdva = SQRT( (pt%ua  -pt%uo)**2 + (pt%va  -pt%vo)**2 )
           zSs  = 1.5 * SQRT( zdva ) + 0.1 * zdva                ! Sea state      (eqn M.A9)
  
           ! Melt rates in m/s (i.e. division by rday)
!          zMv = MAX( 7.62e-3*zSST+1.29e-3*(zSST**2)            , 0._wp ) * z1_rday   ! Buoyant convection at sides (eqn M.A10)
!          zMb = MAX( 0.58*(zdvo**0.8)*(zSST+4.0)/(zL**0.2)      , 0._wp ) * z1_rday   ! Basal turbulent melting     (eqn M.A7 )
           zMe = MAX( 1./12.*(zSST+2.)*zSs*(1+cos(rpi*(zIC**3))) , 0._wp ) * z1_rday   ! Wave erosion                (eqn M.A8 )
  
           IF( ln_operator_splitting ) THEN      ! Operator split update of volume/mass
***************
*** 197,203 ****
              berg_grid%calving_hflx (ii,ij) = berg_grid%calving_hflx (ii,ij) + zheat    * z1_e1e2    ! W/m2
              CALL icb_dia_melt( ii, ij, zMnew, zheat, this%mass_scaling,       &
              &                          zdM, zdMbitsE, zdMbitsM, zdMb, zdMe,   &
!             &                          zdMv, z1_dt_e1e2, iSector )
           ELSE
              WRITE(numout,*) 'icb_thm: berg ',this%number(:),' appears to have grounded  at ',narea,ii,ij
              CALL icb_utl_print_berg( this, kt )
--- 163,169 ----
              berg_grid%calving_hflx (ii,ij) = berg_grid%calving_hflx (ii,ij) + zheat    * z1_e1e2    ! W/m2
              CALL icb_dia_melt( ii, ij, zMnew, zheat, this%mass_scaling,       &
              &                          zdM, zdMbitsE, zdMbitsM, zdMb, zdMe,   &
!             &                          zdMv, z1_dt_e1e2 )
           ELSE
              WRITE(numout,*) 'icb_thm: berg ',this%number(:),' appears to have grounded  at ',narea,ii,ij
              CALL icb_utl_print_berg( this, kt )
diff -bic /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/ICB/icbtrj.F90 /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/ICB/icbtrj.F90
*** /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/ICB/icbtrj.F90	Tue Apr  4 14:56:58 2017
--- /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/ICB/icbtrj.F90	Fri Feb 24 15:39:23 2017
***************
*** 64,75 ****
        TYPE(point)  , POINTER                :: pt
        !!----------------------------------------------------------------------
  
!       IF( lk_mpp ) THEN   ;   WRITE(cl_filename,'("trajectory_icebergs_",I8.8,"_",I4.4,".nc")') ktend, narea-1
!       ELSE                ;   WRITE(cl_filename,'("trajectory_icebergs_",I8.8         ,".nc")') ktend
        ENDIF
        IF ( lwp .AND. nn_verbose_level >= 0) WRITE(numout,'(2a)') 'icebergs, icb_trj_init: creating ',TRIM(cl_filename)
  
!       iret = NF90_CREATE(TRIM(cn_icbdir_trj)//"/"//TRIM(cl_filename), NF90_CLOBBER, ntrajid)
        IF (iret .NE. NF90_NOERR) CALL ctl_stop('icebergs, icb_trj_init: nf_create failed')
  
        ! Dimensions
--- 64,75 ----
        TYPE(point)  , POINTER                :: pt
        !!----------------------------------------------------------------------
  
!       IF( lk_mpp ) THEN   ;   WRITE(cl_filename,'("trajectory_icebergs_",I6.6,"_",I4.4,".nc")') ktend, narea-1
!       ELSE                ;   WRITE(cl_filename,'("trajectory_icebergs_",I6.6         ,".nc")') ktend
        ENDIF
        IF ( lwp .AND. nn_verbose_level >= 0) WRITE(numout,'(2a)') 'icebergs, icb_trj_init: creating ',TRIM(cl_filename)
  
!       iret = NF90_CREATE(TRIM(cl_filename), NF90_CLOBBER, ntrajid)
        IF (iret .NE. NF90_NOERR) CALL ctl_stop('icebergs, icb_trj_init: nf_create failed')
  
        ! Dimensions
Only in /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/ICB: icbtrj.F90.64498
diff -bic /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/ICB/icbutl.F90 /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/ICB/icbutl.F90
*** /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/ICB/icbutl.F90	Tue Apr  4 14:56:58 2017
--- /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/ICB/icbutl.F90	Fri Feb 24 15:39:23 2017
***************
*** 20,28 ****
     USE lib_mpp                             ! MPI code and lk_mpp in particular
     USE icb_oce                             ! define iceberg arrays
     USE sbc_oce                             ! ocean surface boundary conditions
- !MODIF
-    USE oce  ,ONLY : un, vn, ub, vb, tsn                               ! ocean variables
- !Modif
  #if defined key_lim2
     USE ice_2,         ONLY: u_ice, v_ice   ! LIM-2 ice velocities  (CAUTION in C-grid do not use key_vp option)
     USE ice_2,         ONLY: hicif          ! LIM-2 ice thickness
--- 20,25 ----
***************
*** 37,45 ****
  
     PUBLIC   icb_utl_copy          ! routine called in icbstp module
     PUBLIC   icb_utl_interp        ! routine called in icbdyn, icbthm modules
-    PUBLIC   icb_utl_velocityIntegral ! routine called in icbdyn modules
-    PUBLIC   icb_utl_boyantConvectionMelt !routine called in icbthm
-    PUBLIC   icb_utl_basalMelting  ! routine called in icbthm
     PUBLIC   icb_utl_bilin         ! routine called in icbini, icbdyn modules
     PUBLIC   icb_utl_bilin_x       ! routine called in icbdyn module
     PUBLIC   icb_utl_add           ! routine called in icbini.F90, icbclv, icblbc and icbrst modules
--- 34,39 ----
***************
*** 49,56 ****
     PUBLIC   icb_utl_print_berg    ! routine called in icbthm module
     PUBLIC   icb_utl_print         ! routine called in icbini, icbstp module
     PUBLIC   icb_utl_count         ! routine called in icbdia, icbini, icblbc, icbrst modules
-    PUBLIC   icb_utl_origin        ! function called in icbdia, .... 
-    PUBLIC   icb_utl_redefine_origin  !function called in icbini
     PUBLIC   icb_utl_incr          ! routine called in icbini, icbclv modules
     PUBLIC   icb_utl_yearday       ! routine called in icbclv, icbstp module
     PUBLIC   icb_utl_mass          ! routine called in icbdia module
--- 43,48 ----
***************
*** 153,162 ****
        !
        puo  = icb_utl_bilin_h( uo_e, pi, pj, 'U' )             ! ocean velocities
        pvo  = icb_utl_bilin_h( vo_e, pi, pj, 'V' )
!       !psst = icb_utl_bilin( sst_m, pi, pj, 'T' )              ! SST
!       psst = icb_utl_bilin_h( tt_e, pi, pj, 'T' )                !SST Modfi
!       !pcn  = icb_utl_bilin( fr_i , pi, pj, 'T' )              ! ice concentration
!       pcn  = icb_utl_bilin_h( fr_e , pi, pj, 'T' )               ! ice concentration Modif
        pff  = icb_utl_bilin_h( ff_e , pi, pj, 'F' )            ! Coriolis parameter
        !
        pua  = icb_utl_bilin_h( ua_e , pi, pj, 'U' )            ! 10m wind
--- 145,152 ----
        !
        puo  = icb_utl_bilin_h( uo_e, pi, pj, 'U' )             ! ocean velocities
        pvo  = icb_utl_bilin_h( vo_e, pi, pj, 'V' )
!       psst = icb_utl_bilin_h( tt_e, pi, pj, 'T' )             ! SST
!       pcn  = icb_utl_bilin_h( fr_e , pi, pj, 'T' )            ! ice concentration
        pff  = icb_utl_bilin_h( ff_e , pi, pj, 'F' )            ! Coriolis parameter
        !
        pua  = icb_utl_bilin_h( ua_e , pi, pj, 'U' )            ! 10m wind
***************
*** 188,306 ****
        !
     END SUBROUTINE icb_utl_interp
  
-    SUBROUTINE icb_utl_velocityIntegral(kLevels, pi, puo, pj, pvo )
- 
-       INTEGER :: iter  !iterator
-       INTEGER  ::   ii, ij   ! local integer
-       INTEGER, INTENT(in)  :: kLevels
-       REAL(wp), INTENT(in   ) ::   pi , pj                        ! position in(i,j) referential
-       REAL(wp), INTENT(  out) ::   puo, pvo   ! ocean, iceand wind speeds
-       REAL(wp) ::   pu, pv , metric    ! ocean, iceand wind speeds
-       REAL(wp), DIMENSION(0:jpi+1,0:jpj+1) :: velLevelU, velLevelV
- 
-       velLevelU(:,:) = 0._wp ; velLevelV(:,:) = 0._wp
-       puo = 0._wp
-       pvo = 0._wp
-       metric = 0._wp
- 
-       DO iter=1,kLevels
-           velLevelU(1:jpi,1:jpj) = un(:,:,iter)
-           pu  = icb_utl_bilin_h( velLevelU, pi, pj, 'T' )
-           velLevelV(1:jpi,1:jpj) = vn(:,:,iter)
-           pv  = icb_utl_bilin_h( velLevelV, pi, pj, 'T' )
-           puo = puo + pu*e3t_n(mi1(pi),mj1(pj),iter)
-           pvo = pvo + pv*e3t_n(mi1(pi),mj1(pj),iter)
-           metric = metric + e3t_n(mi1(pi),mj1(pj),iter)
- !print *, 'level', iter, 'pu', pu, 'metric',metric
-       END DO
- 
-       puo = puo / metric
-       pvo = pvo / metric
- 
-       END SUBROUTINE icb_utl_velocityIntegral
- 
-    SUBROUTINE icb_utl_boyantConvectionMelt(kLevels, pi, pj, z1_rday, mvo )
- 
-       INTEGER :: iter, mlevel  !iterator
-       INTEGER, INTENT(in)  :: kLevels
-       REAL(wp), INTENT(in   ) ::   pi , pj, z1_rday           ! positionin(i,j) referential
-       REAL(wp), INTENT(  out) ::   mvo   ! melting out
-       REAL(wp) ::  kBathy
-       REAL(wp) ::   mv,pt, metric    ! melt, temperature, and metric temporal
-       REAL(wp), DIMENSION(0:jpi+1,0:jpj+1) :: temp !interpolation temp
- 
-       temp(:,:) = 0._wp
-       metric = 0._wp    
-       mvo = 0._wp      
-       kBathy = mbathy(mi1(pi+0.5),mj1(pj+0.5))
- 
-       DO iter=1,kLevels
- 
-           if (iter .gt. kbathy) then
-                 mlevel = kbathy
-           else
-                 mlevel = iter
-           end if
-           temp(1:jpi,1:jpj) = tsn(:,:,mlevel,1)
-           pt  = icb_utl_bilin_h( temp, pi, pj, 'T' )
-           mv = MAX( 7.62e-3*pt+1.29e-3*(pt**2)            , 0._wp ) * z1_rday
-           mvo = mvo + mv*e3t_n(mi1(pi),mj1(pj),mlevel)
-           metric = metric + e3t_n(mi1(pi),mj1(pj),mlevel)
-       END DO
- 
-       mvo = mvo / metric
- 
-       END SUBROUTINE icb_utl_boyantConvectionMelt
- 
- 
-    SUBROUTINE icb_utl_basalMelting(kLevels, pi, pu, pj, pv, zL, z1_rday, mvo )
- 
-       INTEGER  ::   ii, ij, mlevel   ! local integer
-       INTEGER, INTENT(in)  :: kLevels
-       REAL(wp), INTENT(in   ) :: z1_rday, zL !1/rday and icb lenght
-       REAL(wp), INTENT(in   ) ::   pi , pj, pu, pv  !position velocityin(i,j) referential
-       REAL(wp), INTENT(  out) ::   mvo   ! melt out
-       REAL(wp) ::  kBathy
-       REAL(wp) ::  zdvo, uvel,vvel,pt    ! velocity module, veocity interp, temp interpoled
-       REAL(wp), DIMENSION(0:jpi+1,0:jpj+1) :: VelU, VelV, temp  !temporal velocity and temperature
- 
-       temp(:,:) = 0._wp
-       VelU(:,:) = 0._wp
-       VelV(:,:) = 0._wp
-       pt = 0._wp
-       
-       kBathy = mbathy(mi1(pi+0.5),mj1(pj+0.5))
- 
-       if (kLevels .lt. kBathy+1) then  !Verify mbathy from 0
- !fror from 1
- 
-         VelU(1:jpi,1:jpj) = un(:,:,kLevels)
-         uvel  = icb_utl_bilin_h( VelU, pi, pj, 'U' )
-         VelV(1:jpi,1:jpj) = vn(:,:,kLevels)
-         vvel  = icb_utl_bilin_h( VelV, pi, pj, 'V' )
-         temp(1:jpi,1:jpj) = tsn(:,:,kLevels,1)
-         pt  = icb_utl_bilin_h( temp, pi, pj, 'T' )
- 
-         zdvo = SQRT( (pu-uvel)**2 + (pv-vvel)**2 )
-         mvo = MAX( 0.58*(zdvo**0.8)*(pt+4.0)/(zL**0.2)      , 0._wp ) * z1_rday
- 
-       else
- 
-         mlevel = kBathy
- 
-         VelU(1:jpi,1:jpj) = un(:,:,mlevel)
-         uvel  = icb_utl_bilin_h( VelU, pi, pj, 'U' )
-         VelV(1:jpi,1:jpj) = vn(:,:,mlevel)
-         vvel  = icb_utl_bilin_h( VelV, pi, pj, 'V' )
-         temp(1:jpi,1:jpj) = tsn(:,:,mlevel,1)
-         pt  = icb_utl_bilin_h( temp, pi, pj, 'T' )
- 
-         zdvo = SQRT( (pu-uvel)**2 + (pv-vvel)**2 )
-         mvo = MAX( 0.58*(zdvo**0.8)*(pt+4.0)/(zL**0.2)      , 0._wp ) * z1_rday
- 
-       end if
- 
-       END SUBROUTINE icb_utl_basalMelting
  
     REAL(wp) FUNCTION icb_utl_bilin_h( pfld, pi, pj, cd_type )
        !!----------------------------------------------------------------------
--- 178,183 ----
***************
*** 347,354 ****
              zj = pj - 0.5 - REAL(ij,wp)
        END SELECT
        !
!       ! find position in this processor
! !MODIF Nacho
  
        if (ii.lt.mig(1)) then
          ii = 1
--- 224,230 ----
              zj = pj - 0.5 - REAL(ij,wp)
        END SELECT
        !
!       ! find position in this processor. Prevent near edge problems (see #1389)
  
        if (ii.lt.mig(1)) then
          ii = 1
***************
*** 596,604 ****
        !
        icb_utl_bilin_e = ( ze01 * (1.-zi) + ze11 * zi ) *     zj    &
           &            + ( ze00 * (1.-zi) + ze10 * zi ) * (1.-zj)
- !end if
-    !print *, 'ii = 0'
-    !icb_utl_bilin_e=0.0
        !
     END FUNCTION icb_utl_bilin_e
  
--- 472,477 ----
***************
*** 643,651 ****
        ALLOCATE(berg, STAT=istat)
        IF( istat /= 0 ) CALL ctl_stop( 'failed to allocate iceberg' )
        berg%number(:) = bergvals%number(:)
-       berg%origin = bergvals%origin
-       berg%lat_origin =  bergvals%lat_origin
-       berg%lon_origin =  bergvals%lon_origin
        berg%mass_scaling = bergvals%mass_scaling
        berg%prev => NULL()
        berg%next => NULL()
--- 516,521 ----
***************
*** 684,739 ****
        !
     END SUBROUTINE icb_utl_insert
  
-    INTEGER FUNCTION icb_utl_origin(plat, plon)
-       !!----------------------------------------------------------------------
-       !!                 ***  FUNCTION icb_utl_origin  ***
-       !!
-       !! ** Purpose :   
-       !!
-       ! Give the number of the Sector_Box associated to a specific
-       ! lon lat
-       ! 
-       !
-       !! NACHO MERINO
-       !!
-       !!----------------------------------------------------------------------
-       REAL(wp), INTENT(in)     :: plat, plon
-       INTEGER                  :: i, origin = 0
-       LOGICAL                  :: lonCondition
-       ! 
-       !!----------------------------------------------------------------------
-       !
-       DO i=1,nn_sectors_boxes
-                 !The typical case when both longitud limits have the same sign (prod > 0) -> No
-                 !special treatement is needed, or the case when both have
-                 !different sign but the left limit is negative. That means than
-                 !the box definition contains de 0. and no special treatment is
-                 !needed neithe
-         IF ( ( (Sector_Boxes(i)%box(1) * Sector_Boxes(i)%box(2) ) .gt. 0. )  .or. ( Sector_Boxes(i)%box(1).lt.0. ) ) THEN !The case when both longitud limits have the same sign (prod > 0) -> No special treatement is needed
-            IF (plon.gt.Sector_Boxes(i)%box(1) .AND. plon.lt.Sector_Boxes(i)%box(2) .AND. &
-                         & plat.gt.Sector_Boxes(i)%box(3) .AND.  plat.lt.Sector_Boxes(i)%box(4)) THEN
-                 origin = i
-                 EXIT
-            ENDIF
-            cycle
- 
-                 !If the product of box1 and box2 is negative, and box1 is
-                 !positive that means that de box contains the 180 latitude so we have
-                 !to treat apart tha situation
-         ELSE 
-             lonCondition = (plon.gt.Sector_Boxes(i)%box(1) .AND. plon .le. 180.) .or. &
-                         & (plon.lt.Sector_Boxes(i)%box(2) .AND.plon .ge. -180.)
-             IF (lonCondition .and. plat.gt.Sector_Boxes(i)%box(3) .AND.plat.lt.Sector_Boxes(i)%box(4)) THEN
-                 origin = i
-                 EXIT
-             ENDIF
-         ENDIF
- 
-       ENDDO  
- 
-       icb_utl_origin = origin
-       
-    END FUNCTION icb_utl_origin
  
     REAL(wp) FUNCTION icb_utl_yearday(kmon, kday, khr, kmin, ksec)
        !!----------------------------------------------------------------------
--- 554,559 ----
***************
*** 796,823 ****
        DEALLOCATE(berg)
        !
     END SUBROUTINE icb_utl_destroy
-    SUBROUTINE icb_utl_redefine_origin()
-       !!----------------------------------------------------------------------
-       !!                 ***  ROUTINE icb_redefine origin  ***
-       !!
-       !! ** Purpose : If we have change the sectors box definition, this
-       !function takes the lon lat coordinates of the origin of each iceberg and
-       !change the origin parameter of the icebergs structure  
-       !!
-       !!----------------------------------------------------------------------
-       REAL(wp)                       :: zlon,zlat      
-       TYPE(iceberg), POINTER         :: this
-       !!----------------------------------------------------------------------
-       !
-       this => first_berg
-       DO WHILE( ASSOCIATED(this) )
-          zlon=this%lon_origin
-          zlat=this%lat_origin
-          this%origin=icb_utl_origin(zlat,zlon)
-          this => this%next
-       END DO
-       !
-    END SUBROUTINE icb_utl_redefine_origin
  
  
     SUBROUTINE icb_utl_track( knum, cd_label, kt )
--- 616,621 ----
diff -bic /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/IOM/in_out_manager.F90 /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/IOM/in_out_manager.F90
*** /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/IOM/in_out_manager.F90	Tue Apr  4 14:51:16 2017
--- /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/IOM/in_out_manager.F90	Fri Feb 24 15:39:23 2017
***************
*** 27,33 ****
     CHARACTER(lc) ::   cn_ocerst_indir  !: restart input directory
     CHARACTER(lc) ::   cn_ocerst_out    !: suffix of ocean restart name (output)
     CHARACTER(lc) ::   cn_ocerst_outdir !: restart output directory
-    CHARACTER(len=255) ::  cn_dirout = "./"        !: prefix for model outputfile
     LOGICAL       ::   ln_rstart        !: start from (F) rest or (T) a restart file
     LOGICAL       ::   ln_rst_list      !: output restarts at list of times (T) or by frequency (F)
     INTEGER       ::   nn_no            !: job number
--- 27,32 ----
***************
*** 153,159 ****
  
     !!----------------------------------------------------------------------
     !! NEMO/OPA 3.3 , NEMO Consortium (2010)
!    !! $Id: in_out_manager.F90 5518 2015-06-30 13:11:42Z clem $
     !! Software governed by the CeCILL licence     (NEMOGCM/NEMO_CeCILL.txt)
     !!=====================================================================
  END MODULE in_out_manager
--- 152,158 ----
  
     !!----------------------------------------------------------------------
     !! NEMO/OPA 3.3 , NEMO Consortium (2010)
!    !! $Id: in_out_manager.F90 6140 2015-12-21 11:35:23Z timgraham $
     !! Software governed by the CeCILL licence     (NEMOGCM/NEMO_CeCILL.txt)
     !!=====================================================================
  END MODULE in_out_manager
diff -bic /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/IOM/iom.F90 /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/IOM/iom.F90
*** /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/IOM/iom.F90	Tue Apr  4 14:56:58 2017
--- /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/IOM/iom.F90	Fri Feb 24 15:39:23 2017
***************
*** 29,37 ****
  #if defined key_iomput
     USE sbc_oce, ONLY :   nn_fsbc         ! ocean space and time domain
     USE trc_oce, ONLY :   nn_dttrc        !  !: frequency of step on passive tracers
! 
!    USE icb_oce, ONLY :   nsectors, nclasses, class_num, sectors_num   ! iceberg classes
! 
  #if defined key_lim3
     USE ice    , ONLY :   jpl
  #elif defined key_lim2
--- 29,35 ----
  #if defined key_iomput
     USE sbc_oce, ONLY :   nn_fsbc         ! ocean space and time domain
     USE trc_oce, ONLY :   nn_dttrc        !  !: frequency of step on passive tracers
!    USE icb_oce, ONLY :   nclasses, class_num       !  !: iceberg classes
  #if defined key_lim3
     USE ice    , ONLY :   jpl
  #elif defined key_lim2
***************
*** 79,85 ****
  
     !!----------------------------------------------------------------------
     !! NEMO/OPA 3.3 , NEMO Consortium (2010)
!    !! $Id: iom.F90 5426 2015-06-15 22:09:51Z hadcv $
     !! Software governed by the CeCILL licence (NEMOGCM/NEMO_CeCILL.txt)
     !!----------------------------------------------------------------------
  
--- 77,83 ----
  
     !!----------------------------------------------------------------------
     !! NEMO/OPA 3.3 , NEMO Consortium (2010)
!    !! $Id: iom.F90 6519 2016-05-11 10:50:34Z timgraham $
     !! Software governed by the CeCILL licence (NEMOGCM/NEMO_CeCILL.txt)
     !!----------------------------------------------------------------------
  
***************
*** 94,116 ****
        !!----------------------------------------------------------------------
        CHARACTER(len=*), INTENT(in)  :: cdname
  #if defined key_iomput
- #if ! defined key_xios2
        TYPE(xios_time)   :: dtime    = xios_time(0, 0, 0, 0, 0, 0)
        CHARACTER(len=19) :: cldate 
- #else
-       TYPE(xios_duration) :: dtime    = xios_duration(0, 0, 0, 0, 0, 0)
-       TYPE(xios_date)     :: start_date
- #endif
        CHARACTER(len=10) :: clname
        INTEGER           ::   ji
        !
        REAL(wp), ALLOCATABLE, DIMENSION(:,:) :: z_bnds
        !!----------------------------------------------------------------------
! #if ! defined key_xios2
        ALLOCATE( z_bnds(jpk,2) )
- #else
-       ALLOCATE( z_bnds(2,jpk) )
- #endif
  
        clname = cdname
        IF( TRIM(Agrif_CFixed()) /= '0' )   clname = TRIM(Agrif_CFixed())//"_"//TRIM(cdname)
--- 92,106 ----
        !!----------------------------------------------------------------------
        CHARACTER(len=*), INTENT(in)  :: cdname
  #if defined key_iomput
        TYPE(xios_time)   :: dtime    = xios_time(0, 0, 0, 0, 0, 0)
        CHARACTER(len=19) :: cldate 
        CHARACTER(len=10) :: clname
        INTEGER           ::   ji
        !
        REAL(wp), ALLOCATABLE, DIMENSION(:,:) :: z_bnds
        !!----------------------------------------------------------------------
! 
        ALLOCATE( z_bnds(jpk,2) )
  
        clname = cdname
        IF( TRIM(Agrif_CFixed()) /= '0' )   clname = TRIM(Agrif_CFixed())//"_"//TRIM(cdname)
***************
*** 118,124 ****
        CALL iom_swap( cdname )
  
        ! calendar parameters
- #if ! defined key_xios2
        SELECT CASE ( nleapy )        ! Choose calendar for IOIPSL
        CASE ( 1)   ;   CALL xios_set_context_attr(TRIM(clname), calendar_type= "Gregorian")
        CASE ( 0)   ;   CALL xios_set_context_attr(TRIM(clname), calendar_type= "NoLeap")
--- 108,113 ----
***************
*** 126,142 ****
        END SELECT
        WRITE(cldate,"(i4.4,'-',i2.2,'-',i2.2,' ',i2.2,':',i2.2,':00')") nyear,nmonth,nday,nhour,nminute
        CALL xios_set_context_attr(TRIM(clname), start_date=cldate )
! #else
!       ! Calendar type is now defined in xml file 
!       SELECT CASE ( nleapy )        ! Choose calendar for IOIPSL
!       CASE ( 1)   ; CALL xios_define_calendar( TYPE = "Gregorian", time_origin = xios_date(1900,01,01,0,00,00), &
!           &                                    start_date = xios_date(nyear,nmonth,nday,nhour,nminute,0) )
!       CASE ( 0)   ; CALL xios_define_calendar( TYPE = "NoLeap"   , time_origin = xios_date(1900,01,01,00,00,00), &
!           &                                    start_date = xios_date(nyear,nmonth,nday,nhour,nminute,0) )
!       CASE (30)   ; CALL xios_define_calendar( TYPE = "D360"     , time_origin = xios_date(1900,01,01,00,00,00), &
!           &                                    start_date = xios_date(nyear,nmonth,nday,nhour,nminute,0) )
!       END SELECT
! #endif
        ! horizontal grid definition
        CALL set_scalar
  
--- 115,121 ----
        END SELECT
        WRITE(cldate,"(i4.4,'-',i2.2,'-',i2.2,' ',i2.2,':',i2.2,':00')") nyear,nmonth,nday,nhour,nminute
        CALL xios_set_context_attr(TRIM(clname), start_date=cldate )
! 
        ! horizontal grid definition
        CALL set_scalar
  
***************
*** 189,217 ****
        CALL iom_set_axis_attr( "depthw", gdepw_1d )
  
        ! Add vertical grid bounds
- #if ! defined key_xios2
        z_bnds(:      ,1) = gdepw_1d(:)
        z_bnds(1:jpkm1,2) = gdepw_1d(2:jpk)
        z_bnds(jpk:   ,2) = gdepw_1d(jpk) + e3t_1d(jpk)
- #else
-       z_bnds(1      ,:) = gdepw_1d(:)
-       z_bnds(2,1:jpkm1) = gdepw_1d(2:jpk)
-       z_bnds(2,jpk:   ) = gdepw_1d(jpk) + e3t_1d(jpk)
- #endif
- 
        CALL iom_set_axis_attr( "deptht", bounds=z_bnds )
        CALL iom_set_axis_attr( "depthu", bounds=z_bnds )
        CALL iom_set_axis_attr( "depthv", bounds=z_bnds )
- 
- #if ! defined key_xios2
        z_bnds(:    ,2) = gdept_1d(:)
        z_bnds(2:jpk,1) = gdept_1d(1:jpkm1)
        z_bnds(1    ,1) = gdept_1d(1) - e3w_1d(1)
- #else
-       z_bnds(2,:    )  = gdept_1d(:)
-       z_bnds(1,2:jpk)  = gdept_1d(1:jpkm1)
-       z_bnds(1,1    )  = gdept_1d(1) - e3w_1d(1)
- #endif
        CALL iom_set_axis_attr( "depthw", bounds=z_bnds )
  
  # if defined key_floats
--- 168,182 ----
***************
*** 221,227 ****
        CALL iom_set_axis_attr( "ncatice", (/ (REAL(ji,wp), ji=1,jpl) /) )
  #endif
        CALL iom_set_axis_attr( "icbcla", class_num )
-       CALL iom_set_axis_attr( "icbsect", sectors_num )
        CALL iom_set_axis_attr( "iax_20C", (/ REAL(20,wp) /) )
        CALL iom_set_axis_attr( "iax_28C", (/ REAL(28,wp) /) )
        
--- 186,191 ----
***************
*** 648,668 ****
     END SUBROUTINE iom_g3d
     !!----------------------------------------------------------------------
  
-    SUBROUTINE iom_init_icb_axis()
-       !!-----------------------------------------------------------------------
-       !!                  ***  ROUTINE  iom_init_icb_axes  ***
-       !!
-       !! ** Purpose : reinitilize iom axes corresponding to icb io files after
-       !reading namelist in icbin.F90
-       !!
-       !! ** Method :
-       !!-----------------------------------------------------------------------
-       CALL iom_set_axis_attr( "icbsect", sectors_num )
-       !CALL iom_set_axis_attr( "icbcla", class_num )  
- 
- 
-    END SUBROUTINE iom_init_icb_axis
-    !!------------------------------------------------------------------------
     SUBROUTINE iom_get_123d( kiomid, kdom  , cdvar ,   &
           &                  pv_r1d, pv_r2d, pv_r3d,   &
           &                  ktime , kstart, kcount,   &
--- 612,617 ----
***************
*** 1180,1192 ****
        INTEGER                  , OPTIONAL, INTENT(in) ::   zoom_ibegin, zoom_jbegin, zoom_ni, zoom_nj, nvertex
        REAL(wp), DIMENSION(:)   , OPTIONAL, INTENT(in) ::   lonvalue, latvalue
        REAL(wp), DIMENSION(:,:) , OPTIONAL, INTENT(in) ::   bounds_lon, bounds_lat, area
- #if ! defined key_xios2
        LOGICAL,  DIMENSION(:,:) , OPTIONAL, INTENT(in) ::   mask
- #else
-       LOGICAL,  DIMENSION(:) , OPTIONAL, INTENT(in) ::   mask
- #endif
  
- #if ! defined key_xios2
        IF ( xios_is_valid_domain     (cdid) ) THEN
           CALL xios_set_domain_attr     ( cdid, ni_glo=ni_glo, nj_glo=nj_glo, ibegin=ibegin, jbegin=jbegin, ni=ni, nj=nj,   &
              &    data_dim=data_dim, data_ibegin=data_ibegin, data_ni=data_ni, data_jbegin=data_jbegin, data_nj=data_nj ,   &
--- 1129,1136 ----
***************
*** 1202,1251 ****
              &    lonvalue=lonvalue, latvalue=latvalue, mask=mask, nvertex=nvertex, bounds_lon=bounds_lon,                  &
              &    bounds_lat=bounds_lat, area=area )
        ENDIF
- 
- #else
-       IF ( xios_is_valid_domain     (cdid) ) THEN
-          CALL xios_set_domain_attr     ( cdid, ni_glo=ni_glo, nj_glo=nj_glo, ibegin=ibegin, jbegin=jbegin, ni=ni, nj=nj,   &
-             &    data_dim=data_dim, data_ibegin=data_ibegin, data_ni=data_ni, data_jbegin=data_jbegin, data_nj=data_nj ,   &
-             &    lonvalue_1D=lonvalue, latvalue_1D=latvalue, mask_1D=mask, nvertex=nvertex, bounds_lon_1D=bounds_lon,                  &
-             &    bounds_lat_1D=bounds_lat, area=area, type='curvilinear')
-      ENDIF
-       IF ( xios_is_valid_domaingroup(cdid) ) THEN
-          CALL xios_set_domaingroup_attr( cdid, ni_glo=ni_glo, nj_glo=nj_glo, ibegin=ibegin, jbegin=jbegin, ni=ni, nj=nj,   &
-             &    data_dim=data_dim, data_ibegin=data_ibegin, data_ni=data_ni, data_jbegin=data_jbegin, data_nj=data_nj ,   &
-             &    lonvalue_1D=lonvalue, latvalue_1D=latvalue, mask_1D=mask, nvertex=nvertex, bounds_lon_1D=bounds_lon,                  &
-             &    bounds_lat_1D=bounds_lat, area=area, type='curvilinear' )
-       ENDIF
- #endif
        CALL xios_solve_inheritance()
  
     END SUBROUTINE iom_set_domain_attr
  
- #if defined key_xios2
-   SUBROUTINE iom_set_zoom_domain_attr( cdid, ibegin, jbegin, ni, nj)
-      CHARACTER(LEN=*)                   , INTENT(in) ::   cdid
-      INTEGER                  , OPTIONAL, INTENT(in) ::   ibegin, jbegin, ni, nj
- 
-      IF ( xios_is_valid_zoom_domain     (cdid) ) THEN
-          CALL xios_set_zoom_domain_attr     ( cdid, ibegin=ibegin, jbegin=jbegin, ni=ni,    &
-            &   nj=nj)
-     ENDIF
-   END SUBROUTINE iom_set_zoom_domain_attr
- #endif
- 
  
     SUBROUTINE iom_set_axis_attr( cdid, paxis, bounds )
        CHARACTER(LEN=*)      , INTENT(in) ::   cdid
        REAL(wp), DIMENSION(:)  , OPTIONAL, INTENT(in) ::   paxis
        REAL(wp), DIMENSION(:,:), OPTIONAL, INTENT(in) ::   bounds
        IF ( PRESENT(paxis) ) THEN
- #if ! defined key_xios2
           IF ( xios_is_valid_axis     (cdid) )   CALL xios_set_axis_attr     ( cdid, size=SIZE(paxis), value=paxis )
           IF ( xios_is_valid_axisgroup(cdid) )   CALL xios_set_axisgroup_attr( cdid, size=SIZE(paxis), value=paxis )
- #else
-          IF ( xios_is_valid_axis     (cdid) )   CALL xios_set_axis_attr     ( cdid, n_glo=SIZE(paxis), value=paxis )
-          IF ( xios_is_valid_axisgroup(cdid) )   CALL xios_set_axisgroup_attr( cdid, n_glo=SIZE(paxis), value=paxis )
- #endif
        ENDIF
        IF ( xios_is_valid_axis     (cdid) )   CALL xios_set_axis_attr     ( cdid, bounds=bounds )
        IF ( xios_is_valid_axisgroup(cdid) )   CALL xios_set_axisgroup_attr( cdid, bounds=bounds )
--- 1146,1163 ----
***************
*** 1255,1267 ****
  
     SUBROUTINE iom_set_field_attr( cdid, freq_op, freq_offset )
        CHARACTER(LEN=*)          , INTENT(in) ::   cdid
- #if ! defined key_xios2
        CHARACTER(LEN=*),OPTIONAL , INTENT(in) ::   freq_op
        CHARACTER(LEN=*),OPTIONAL , INTENT(in) ::   freq_offset
- #else
-       TYPE(xios_duration),OPTIONAL , INTENT(in) ::   freq_op
-       TYPE(xios_duration),OPTIONAL , INTENT(in) ::   freq_offset
- #endif
        IF ( xios_is_valid_field     (cdid) )   CALL xios_set_field_attr       &
      &     ( cdid, freq_op=freq_op, freq_offset=freq_offset )
        IF ( xios_is_valid_fieldgroup(cdid) )   CALL xios_set_fieldgroup_attr  &
--- 1167,1174 ----
***************
*** 1281,1301 ****
  
     SUBROUTINE iom_get_file_attr( cdid, name, name_suffix, output_freq )
        CHARACTER(LEN=*)          , INTENT(in ) ::   cdid
!       CHARACTER(LEN=*),OPTIONAL , INTENT(out) ::   name, name_suffix
! #if ! defined key_xios2
!       CHARACTER(LEN=*),OPTIONAL , INTENT(out) ::    output_freq
! #else
!       TYPE(xios_duration)   ,OPTIONAL , INTENT(out) :: output_freq
! #endif  
        LOGICAL                                 ::   llexist1,llexist2,llexist3
        !---------------------------------------------------------------------
        IF( PRESENT( name        ) )   name = ''          ! default values
        IF( PRESENT( name_suffix ) )   name_suffix = ''
- #if ! defined key_xios2
        IF( PRESENT( output_freq ) )   output_freq = ''
- #else
-       IF( PRESENT( output_freq ) )   output_freq = xios_duration(0,0,0,0,0,0)
- #endif
        IF ( xios_is_valid_file     (cdid) ) THEN
           CALL xios_solve_inheritance()
           CALL xios_is_defined_file_attr     ( cdid, name = llexist1, name_suffix = llexist2, output_freq = llexist3)
--- 1188,1199 ----
  
     SUBROUTINE iom_get_file_attr( cdid, name, name_suffix, output_freq )
        CHARACTER(LEN=*)          , INTENT(in ) ::   cdid
!       CHARACTER(LEN=*),OPTIONAL , INTENT(out) ::   name, name_suffix, output_freq
        LOGICAL                                 ::   llexist1,llexist2,llexist3
        !---------------------------------------------------------------------
        IF( PRESENT( name        ) )   name = ''          ! default values
        IF( PRESENT( name_suffix ) )   name_suffix = ''
        IF( PRESENT( output_freq ) )   output_freq = ''
        IF ( xios_is_valid_file     (cdid) ) THEN
           CALL xios_solve_inheritance()
           CALL xios_is_defined_file_attr     ( cdid, name = llexist1, name_suffix = llexist2, output_freq = llexist3)
***************
*** 1316,1328 ****
     SUBROUTINE iom_set_grid_attr( cdid, mask )
        CHARACTER(LEN=*)                   , INTENT(in) ::   cdid
        LOGICAL, DIMENSION(:,:,:), OPTIONAL, INTENT(in) ::   mask
- #if ! defined key_xios2
        IF ( xios_is_valid_grid     (cdid) )   CALL xios_set_grid_attr     ( cdid, mask=mask )
        IF ( xios_is_valid_gridgroup(cdid) )   CALL xios_set_gridgroup_attr( cdid, mask=mask )
- #else
-       IF ( xios_is_valid_grid     (cdid) )   CALL xios_set_grid_attr     ( cdid, mask_3D=mask )
-       IF ( xios_is_valid_gridgroup(cdid) )   CALL xios_set_gridgroup_attr( cdid, mask_3D=mask )
- #endif
        CALL xios_solve_inheritance()
     END SUBROUTINE iom_set_grid_attr
  
--- 1214,1221 ----
***************
*** 1364,1374 ****
        
        ni=nlei-nldi+1 ; nj=nlej-nldj+1
  
- #if ! defined key_xios2
        CALL iom_set_domain_attr("grid_"//cdgrd, ni_glo=jpiglo, nj_glo=jpjglo, ibegin=nimpp+nldi-1, jbegin=njmpp+nldj-1, ni=ni, nj=nj)
- #else
-      CALL iom_set_domain_attr("grid_"//cdgrd, ni_glo=jpiglo, nj_glo=jpjglo, ibegin=nimpp+nldi-2, jbegin=njmpp+nldj-2, ni=ni, nj=nj)
- #endif     
        CALL iom_set_domain_attr("grid_"//cdgrd, data_dim=2, data_ibegin = 1-nldi, data_ni = jpi, data_jbegin = 1-nldj, data_nj = jpj)
        CALL iom_set_domain_attr("grid_"//cdgrd, lonvalue = RESHAPE(plon(nldi:nlei, nldj:nlej),(/ ni*nj /)),   &
           &                                     latvalue = RESHAPE(plat(nldi:nlei, nldj:nlej),(/ ni*nj /)))  
--- 1257,1263 ----
***************
*** 1382,1392 ****
           CASE('W')   ;   zmask(:,:,2:jpk  ) = tmask(:,:,1:jpkm1) + tmask(:,:,2:jpk)   ;   zmask(:,:,1) = tmask(:,:,1)
           END SELECT
           !
- #if ! defined key_xios2
           CALL iom_set_domain_attr( "grid_"//cdgrd       , mask = RESHAPE(zmask(nldi:nlei,nldj:nlej,1),(/ni,nj    /)) /= 0. )
- #else
-          CALL iom_set_domain_attr( "grid_"//cdgrd       , mask = RESHAPE(zmask(nldi:nlei,nldj:nlej,1),(/ni*nj    /)) /= 0. )
- #endif  
           CALL iom_set_grid_attr  ( "grid_"//cdgrd//"_3D", mask = RESHAPE(zmask(nldi:nlei,nldj:nlej,:),(/ni,nj,jpk/)) /= 0. )
        ENDIF
        
--- 1271,1277 ----
***************
*** 1520,1542 ****
        ni=nlei-nldi+1 ; nj=nlej-nldj+1            ! define zonal mean domain (jpj*jpk)
        ALLOCATE( zlon(ni*nj) )       ;       zlon(:) = 0.
  
-       CALL dom_ngb( 180., 90., ix, iy, 'T' ) !  i-line that passes near the North Pole : Reference latitude (used in plots)
- #if ! defined key_xios2
        CALL iom_set_domain_attr("gznl", ni_glo=jpiglo, nj_glo=jpjglo, ibegin=nimpp+nldi-1, jbegin=njmpp+nldj-1, ni=ni, nj=nj)
        CALL iom_set_domain_attr("gznl", data_dim=2, data_ibegin = 1-nldi, data_ni = jpi, data_jbegin = 1-nldj, data_nj = jpj)
        CALL iom_set_domain_attr("gznl", lonvalue = zlon,   &
           &                             latvalue = RESHAPE(plat(nldi:nlei, nldj:nlej),(/ ni*nj /)))  
        !
        CALL iom_set_domain_attr ('ptr', zoom_ibegin=ix, zoom_nj=jpjglo)
- #else
- ! Pas teste : attention aux indices !
-       CALL iom_set_domain_attr("gznl", ni_glo=jpiglo, nj_glo=jpjglo, ibegin=nimpp+nldi-2, jbegin=njmpp+nldj-2, ni=ni, nj=nj)
-       CALL iom_set_domain_attr("gznl", data_dim=2, data_ibegin = 1-nldi, data_ni = jpi, data_jbegin = 1-nldj, data_nj = jpj)
-       CALL iom_set_domain_attr("gznl", lonvalue = zlon,   &
-          &                             latvalue = RESHAPE(plat(nldi:nlei, nldj:nlej),(/ ni*nj /)))  
-        CALL iom_set_zoom_domain_attr ("ptr", ibegin=ix-1, jbegin=0, ni=1, nj=jpjglo)
- #endif
- 
        CALL iom_update_file_name('ptr')
        !
     END SUBROUTINE set_grid_znl
--- 1405,1417 ----
        ni=nlei-nldi+1 ; nj=nlej-nldj+1            ! define zonal mean domain (jpj*jpk)
        ALLOCATE( zlon(ni*nj) )       ;       zlon(:) = 0.
  
        CALL iom_set_domain_attr("gznl", ni_glo=jpiglo, nj_glo=jpjglo, ibegin=nimpp+nldi-1, jbegin=njmpp+nldj-1, ni=ni, nj=nj)
        CALL iom_set_domain_attr("gznl", data_dim=2, data_ibegin = 1-nldi, data_ni = jpi, data_jbegin = 1-nldj, data_nj = jpj)
        CALL iom_set_domain_attr("gznl", lonvalue = zlon,   &
           &                             latvalue = RESHAPE(plat(nldi:nlei, nldj:nlej),(/ ni*nj /)))  
        !
+       CALL dom_ngb( 180., 90., ix, iy, 'T' ) !  i-line that passes near the North Pole : Reference latitude (used in plots)
        CALL iom_set_domain_attr ('ptr', zoom_ibegin=ix, zoom_nj=jpjglo)
        CALL iom_update_file_name('ptr')
        !
     END SUBROUTINE set_grid_znl
***************
*** 1550,1560 ****
        !!----------------------------------------------------------------------
        REAL(wp), DIMENSION(1)   ::   zz = 1.
        !!----------------------------------------------------------------------
- #if ! defined key_xios2
        CALL iom_set_domain_attr('scalarpoint', ni_glo=jpnij, nj_glo=1, ibegin=narea, jbegin=1, ni=1, nj=1)
- #else
-       CALL iom_set_domain_attr('scalarpoint', ni_glo=jpnij, nj_glo=1, ibegin=narea-1, jbegin=0, ni=1, nj=1)
- #endif
        CALL iom_set_domain_attr('scalarpoint', data_dim=2, data_ibegin = 1, data_ni = 1, data_jbegin = 1, data_nj = 1)
        
        zz=REAL(narea,wp)
--- 1425,1431 ----
***************
*** 1575,1581 ****
        CHARACTER(len=1)               ::   cl1                      ! 1 character
        CHARACTER(len=2)               ::   cl2                      ! 2 characters
        CHARACTER(len=3)               ::   cl3                      ! 3 characters
-       CHARACTER(len=4)               ::   cl4                      ! 4 characters
        INTEGER                        ::   ji, jg                   ! loop counters
        INTEGER                        ::   ix, iy                   ! i-,j- index
        REAL(wp)        ,DIMENSION(11) ::   zlontao                  ! longitudes of tao    moorings
--- 1446,1451 ----
***************
*** 1584,1609 ****
        REAL(wp)        ,DIMENSION(11) ::   zlatrama                 ! latitudes  of rama   moorings
        REAL(wp)        ,DIMENSION( 3) ::   zlonpira                 ! longitudes of pirata moorings
        REAL(wp)        ,DIMENSION( 9) ::   zlatpira                 ! latitudes  of pirata moorings
- #if  defined key_xios2
-       TYPE(xios_duration)            ::   f_op, f_of
- #endif
-  
        !!----------------------------------------------------------------------
        ! 
        ! frequency of the call of iom_put (attribut: freq_op)
- #if ! defined key_xios2
        WRITE(cl1,'(i1)')        1   ;   CALL iom_set_field_attr('field_definition', freq_op = cl1//'ts', freq_offset='0ts')
        WRITE(cl1,'(i1)')  nn_fsbc   ;   CALL iom_set_field_attr('SBC'             , freq_op = cl1//'ts', freq_offset='0ts')
        WRITE(cl1,'(i1)')  nn_fsbc   ;   CALL iom_set_field_attr('SBC_scalar'      , freq_op = cl1//'ts', freq_offset='0ts')
        WRITE(cl1,'(i1)') nn_dttrc   ;   CALL iom_set_field_attr('ptrc_T'          , freq_op = cl1//'ts', freq_offset='0ts')
        WRITE(cl1,'(i1)') nn_dttrc   ;   CALL iom_set_field_attr('diad_T'          , freq_op = cl1//'ts', freq_offset='0ts')
- #else
-       f_op%timestep = 1        ;  f_of%timestep = 0  ; CALL iom_set_field_attr('field_definition', freq_op=f_op, freq_offset=f_of)
-       f_op%timestep = nn_fsbc  ;  f_of%timestep = 0  ; CALL iom_set_field_attr('SBC'             , freq_op=f_op, freq_offset=f_of)
-       f_op%timestep = nn_fsbc  ;  f_of%timestep = 0  ; CALL iom_set_field_attr('SBC_scalar'      , freq_op=f_op, freq_offset=f_of)
-       f_op%timestep = nn_dttrc ;  f_of%timestep = 0  ; CALL iom_set_field_attr('ptrc_T'          , freq_op=f_op, freq_offset=f_of)
-       f_op%timestep = nn_dttrc ;  f_of%timestep = 0  ; CALL iom_set_field_attr('diad_T'          , freq_op=f_op, freq_offset=f_of)
- #endif
         
        ! output file names (attribut: name)
        DO ji = 1, 9
--- 1454,1467 ----
***************
*** 1617,1638 ****
        DO ji = 1, 999
           WRITE(cl3,'(i3.3)') ji 
           CALL iom_update_file_name('file'//cl3)
- !{ DRAKKAR : 
- !     In DRAKKAR/OCCIPUT we add new file_id for inter member diags starting with i
- !     We also use separate files for meridional and zonal sections, so that it is safer
- !     to use particular ID for those files : secme, seczo and their inter member counter part isecme, iseczo
- !     We also choose to always use 3 digit starting 001 to 999
-          CALL iom_update_file_name('file'//cl3)
-          CALL iom_update_file_name('ifile'//cl3)
-          CALL iom_update_file_name('seczo'//cl3)
-          CALL iom_update_file_name('iseczo'//cl3)
-          CALL iom_update_file_name('secme'//cl3)
-          CALL iom_update_file_name('isecme'//cl3)
- !}
-       END DO
-       DO ji = 1, 9999
-          WRITE(cl4,'(i4.4)') ji
-          CALL iom_update_file_name('moor'//cl4)
        END DO
  
        ! Zooms...
--- 1475,1480 ----
***************
*** 1641,1651 ****
           cl1 = clgrd(jg)
           ! Equatorial section (attributs: jbegin, ni, name_suffix)
           CALL dom_ngb( 0., 0., ix, iy, cl1 )
- #if ! defined key_xios2
           CALL iom_set_domain_attr ('Eq'//cl1, zoom_jbegin=iy, zoom_ni=jpiglo)
- #else
-          CALL iom_set_zoom_domain_attr ('Eq'//cl1, jbegin=iy-1, ni=jpiglo)
- #endif
           CALL iom_get_file_attr   ('Eq'//cl1, name_suffix = clsuff             )
           CALL iom_set_file_attr   ('Eq'//cl1, name_suffix = TRIM(clsuff)//'_Eq')
           CALL iom_update_file_name('Eq'//cl1)
--- 1483,1489 ----
***************
*** 1725,1735 ****
                    ENDIF
                 ENDIF
                 clname = TRIM(ADJUSTL(clat))//TRIM(ADJUSTL(clon))
- #if ! defined key_xios2
                 CALL iom_set_domain_attr (TRIM(clname)//cl1, zoom_ibegin= ix, zoom_jbegin= iy)
- #else
-                CALL iom_set_zoom_domain_attr  (TRIM(clname)//cl1, ibegin= ix-1, jbegin= iy-1)
- #endif
                 CALL iom_get_file_attr   (TRIM(clname)//cl1, name_suffix = clsuff                         )
                 CALL iom_set_file_attr   (TRIM(clname)//cl1, name_suffix = TRIM(clsuff)//'_'//TRIM(clname))
                 CALL iom_update_file_name(TRIM(clname)//cl1)
--- 1563,1569 ----
***************
*** 1758,1776 ****
        INTEGER            ::   iyear, imonth, iday, isec
        REAL(wp)           ::   zsec
        LOGICAL            ::   llexist
- #if  defined key_xios2
-       TYPE(xios_duration)   ::   output_freq 
- #endif      
        !!----------------------------------------------------------------------
  
- 
        DO jn = 1,2
! #if ! defined key_xios2
           IF( jn == 1 )   CALL iom_get_file_attr( cdid, name        = clname, output_freq = clfreq )
- #else
-          output_freq = xios_duration(0,0,0,0,0,0)
-          IF( jn == 1 )   CALL iom_get_file_attr( cdid, name        = clname, output_freq = output_freq )
- #endif
           IF( jn == 2 )   CALL iom_get_file_attr( cdid, name_suffix = clname )
  
           IF ( TRIM(clname) /= '' ) THEN 
--- 1592,1602 ----
        INTEGER            ::   iyear, imonth, iday, isec
        REAL(wp)           ::   zsec
        LOGICAL            ::   llexist
        !!----------------------------------------------------------------------
  
        DO jn = 1,2
! 
           IF( jn == 1 )   CALL iom_get_file_attr( cdid, name        = clname, output_freq = clfreq )
           IF( jn == 2 )   CALL iom_get_file_attr( cdid, name_suffix = clname )
  
           IF ( TRIM(clname) /= '' ) THEN 
***************
*** 1781,1787 ****
                 idx = INDEX(clname,'@expname@') + INDEX(clname,'@EXPNAME@')
              END DO
  
- #if ! defined key_xios2
              idx = INDEX(clname,'@freq@') + INDEX(clname,'@FREQ@')
              DO WHILE ( idx /= 0 ) 
                 IF ( TRIM(clfreq) /= '' ) THEN
--- 1607,1612 ----
***************
*** 1794,1825 ****
                 ENDIF
                 idx = INDEX(clname,'@freq@') + INDEX(clname,'@FREQ@')
              END DO
! #else
!             idx = INDEX(clname,'@freq@') + INDEX(clname,'@FREQ@')
!             DO WHILE ( idx /= 0 ) 
!               IF ( output_freq%timestep /= 0) THEN
!                   WRITE(clfreq,'(I18,A2)')INT(output_freq%timestep),'ts' 
!                   itrlen = LEN_TRIM(ADJUSTL(clfreq))
!               ELSE IF ( output_freq%hour /= 0 ) THEN
!                   WRITE(clfreq,'(I19,A1)')INT(output_freq%hour),'h' 
!                   itrlen = LEN_TRIM(ADJUSTL(clfreq))
!               ELSE IF ( output_freq%day /= 0 ) THEN
!                   WRITE(clfreq,'(I19,A1)')INT(output_freq%day),'d' 
!                   itrlen = LEN_TRIM(ADJUSTL(clfreq))
!               ELSE IF ( output_freq%month /= 0 ) THEN   
!                   WRITE(clfreq,'(I19,A1)')INT(output_freq%month),'m' 
!                   itrlen = LEN_TRIM(ADJUSTL(clfreq))
!               ELSE IF ( output_freq%year /= 0 ) THEN   
!                   WRITE(clfreq,'(I19,A1)')INT(output_freq%year),'y' 
!                   itrlen = LEN_TRIM(ADJUSTL(clfreq))
!               ELSE
!                   CALL ctl_stop('error in the name of file id '//TRIM(cdid),   &
!                      & ' attribute output_freq is undefined -> cannot replace @freq@ in '//TRIM(clname) )
!               ENDIF
!               clname = clname(1:idx-1)//TRIM(ADJUSTL(clfreq))//clname(idx+6:LEN_TRIM(clname))
!               idx = INDEX(clname,'@freq@') + INDEX(clname,'@FREQ@')
!             END DO
! #endif
              idx = INDEX(clname,'@startdate@') + INDEX(clname,'@STARTDATE@')
              DO WHILE ( idx /= 0 ) 
                 cldate = iom_sdate( fjulday - rdt / rday )
--- 1619,1625 ----
                 ENDIF
                 idx = INDEX(clname,'@freq@') + INDEX(clname,'@FREQ@')
              END DO
! 
              idx = INDEX(clname,'@startdate@') + INDEX(clname,'@STARTDATE@')
              DO WHILE ( idx /= 0 ) 
                 cldate = iom_sdate( fjulday - rdt / rday )
diff -bic /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/IOM/restart.F90 /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/IOM/restart.F90
*** /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/IOM/restart.F90	Tue Apr  4 14:51:16 2017
--- /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/IOM/restart.F90	Fri Feb 24 15:39:23 2017
***************
*** 40,46 ****
  #  include "vectopt_loop_substitute.h90"
     !!----------------------------------------------------------------------
     !! NEMO/OPA 3.3 , NEMO Consortium (2010)
!    !! $Id: restart.F90 5407 2015-06-11 19:13:22Z smasson $
     !! Software governed by the CeCILL licence     (NEMOGCM/NEMO_CeCILL.txt)
     !!----------------------------------------------------------------------
  CONTAINS
--- 40,46 ----
  #  include "vectopt_loop_substitute.h90"
     !!----------------------------------------------------------------------
     !! NEMO/OPA 3.3 , NEMO Consortium (2010)
!    !! $Id: restart.F90 6140 2015-12-21 11:35:23Z timgraham $
     !! Software governed by the CeCILL licence     (NEMOGCM/NEMO_CeCILL.txt)
     !!----------------------------------------------------------------------
  CONTAINS
***************
*** 88,97 ****
              ELSE                            ;   WRITE(clkt, '(i8.8)') nitrst
              ENDIF
              ! create the file
! !{ DRAKKAR : use simpler name for restart files ( defined in domain.F90 )
! !           clname = TRIM(cexper)//"_"//TRIM(ADJUSTL(clkt))//"_"//TRIM(cn_ocerst_out)
!             clname = TRIM(cn_ocerst_out)
! !}
              clpath = TRIM(cn_ocerst_outdir)
              IF( clpath(LEN_TRIM(clpath):) /= '/' ) clpath = TRIM(clpath) // '/'
              IF(lwp) THEN
--- 88,94 ----
              ELSE                            ;   WRITE(clkt, '(i8.8)') nitrst
              ENDIF
              ! create the file
!             clname = TRIM(cexper)//"_"//TRIM(ADJUSTL(clkt))//"_"//TRIM(cn_ocerst_out)
              clpath = TRIM(cn_ocerst_outdir)
              IF( clpath(LEN_TRIM(clpath):) /= '/' ) clpath = TRIM(clpath) // '/'
              IF(lwp) THEN
***************
*** 182,187 ****
--- 179,185 ----
        !!                the file has already been opened
        !!----------------------------------------------------------------------
        INTEGER        ::   jlibalt = jprstlib
+       LOGICAL        ::   llok
        CHARACTER(lc)  ::   clpath   ! full path to ocean output restart file
        !!----------------------------------------------------------------------
        !
diff -bic /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/LBC/lib_mpp.F90 /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/LBC/lib_mpp.F90
*** /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/LBC/lib_mpp.F90	Tue Apr  4 14:56:58 2017
--- /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/LBC/lib_mpp.F90	Fri Feb 24 15:39:23 2017
***************
*** 172,178 ****
     INTEGER, PUBLIC                                  ::   ityp
     !!----------------------------------------------------------------------
     !! NEMO/OPA 3.3 , NEMO Consortium (2010)
!    !! $Id: lib_mpp.F90 6917 2016-09-06 12:50:02Z flavoni $
     !! Software governed by the CeCILL licence     (NEMOGCM/NEMO_CeCILL.txt)
     !!----------------------------------------------------------------------
  CONTAINS
--- 172,178 ----
     INTEGER, PUBLIC                                  ::   ityp
     !!----------------------------------------------------------------------
     !! NEMO/OPA 3.3 , NEMO Consortium (2010)
!    !! $Id: lib_mpp.F90 6918 2016-09-06 13:02:44Z flavoni $
     !! Software governed by the CeCILL licence     (NEMOGCM/NEMO_CeCILL.txt)
     !!----------------------------------------------------------------------
  CONTAINS
***************
*** 4238,4244 ****
     END SUBROUTINE ctl_warn
  
  
!    SUBROUTINE ctl_opn( knum, cdfile, cdstat, cdform, cdacce, klengh, kout, ldwp, karea, cdirout )
        !!----------------------------------------------------------------------
        !!                  ***  ROUTINE ctl_opn  ***
        !!
--- 4238,4244 ----
     END SUBROUTINE ctl_warn
  
  
!    SUBROUTINE ctl_opn( knum, cdfile, cdstat, cdform, cdacce, klengh, kout, ldwp, karea )
        !!----------------------------------------------------------------------
        !!                  ***  ROUTINE ctl_opn  ***
        !!
***************
*** 4255,4267 ****
        INTEGER          , INTENT(in   ) ::   kout      ! number of logical units for write
        LOGICAL          , INTENT(in   ) ::   ldwp      ! boolean term for print
        INTEGER, OPTIONAL, INTENT(in   ) ::   karea     ! proc number
!       CHARACTER(len=*) , OPTIONAL, INTENT(in   ) ::   cdirout ! prefix directory
!       !!
!       CHARACTER(len=380) ::   clfile
        INTEGER            ::   iost
-       INTEGER            ::   itry
        !!----------------------------------------------------------------------
! 
        ! adapt filename
        ! ----------------
        clfile = TRIM(cdfile)
--- 4255,4265 ----
        INTEGER          , INTENT(in   ) ::   kout      ! number of logical units for write
        LOGICAL          , INTENT(in   ) ::   ldwp      ! boolean term for print
        INTEGER, OPTIONAL, INTENT(in   ) ::   karea     ! proc number
!       !
!       CHARACTER(len=80) ::   clfile
        INTEGER           ::   iost
        !!----------------------------------------------------------------------
!       !
        ! adapt filename
        ! ----------------
        clfile = TRIM(cdfile)
***************
*** 4274,4296 ****
  #else
        knum=get_unit()
  #endif
! 
!       itry=0
!  50   CONTINUE
        iost=0
-       IF ( PRESENT (cdirout) ) clfile = TRIM(cdirout)//'/'//TRIM(clfile)
        IF( cdacce(1:6) == 'DIRECT' )  THEN
!          OPEN( UNIT=knum, FILE=TRIM(clfile), FORM=cdform, ACCESS=cdacce, STATUS=cdstat, RECL=klengh, ERR=100, IOSTAT=iost )
!       ELSE
!          IF ( knum == numout ) THEN
!            OPEN( UNIT=knum, FILE=TRIM(clfile), FORM=cdform, ACCESS=cdacce, STATUS=cdstat, RECL=400   , ERR=100, IOSTAT=iost )
           ELSE
!            OPEN( UNIT=knum, FILE=TRIM(clfile), FORM=cdform, ACCESS=cdacce, STATUS=cdstat             , ERR=100, IOSTAT=iost )
!          ENDIF
        ENDIF
        IF( iost == 0 ) THEN
           IF(ldwp) THEN
!             WRITE(kout,*) '     file   : ', TRIM(clfile),' open ok'
              WRITE(kout,*) '     unit   = ', knum
              WRITE(kout,*) '     status = ', cdstat
              WRITE(kout,*) '     form   = ', cdform
--- 4272,4287 ----
  #else
        knum=get_unit()
  #endif
!       !
        iost=0
        IF( cdacce(1:6) == 'DIRECT' )  THEN
!          OPEN( UNIT=knum, FILE=clfile, FORM=cdform, ACCESS=cdacce, STATUS=cdstat, RECL=klengh, ERR=100, IOSTAT=iost )
        ELSE
!          OPEN( UNIT=knum, FILE=clfile, FORM=cdform, ACCESS=cdacce, STATUS=cdstat             , ERR=100, IOSTAT=iost )
        ENDIF
        IF( iost == 0 ) THEN
           IF(ldwp) THEN
!             WRITE(kout,*) '     file   : ', clfile,' open ok'
              WRITE(kout,*) '     unit   = ', knum
              WRITE(kout,*) '     status = ', cdstat
              WRITE(kout,*) '     form   = ', cdform
***************
*** 4302,4308 ****
        IF( iost /= 0 ) THEN
           IF(ldwp) THEN
              WRITE(kout,*)
!             WRITE(kout,*) ' ===>>>> : bad opening file: ', TRIM(clfile)
              WRITE(kout,*) ' =======   ===  '
              WRITE(kout,*) '           unit   = ', knum
              WRITE(kout,*) '           status = ', cdstat
--- 4293,4299 ----
        IF( iost /= 0 ) THEN
           IF(ldwp) THEN
              WRITE(kout,*)
!             WRITE(kout,*) ' ===>>>> : bad opening file: ', clfile
              WRITE(kout,*) ' =======   ===  '
              WRITE(kout,*) '           unit   = ', knum
              WRITE(kout,*) '           status = ', cdstat
***************
*** 4312,4330 ****
              WRITE(kout,*) '           we stop. verify the file '
              WRITE(kout,*)
           ENDIF
-          ! output on the job log because there are some errors not on lwp
-            PRINT *, narea, ' ===>>>> : bad opening file: ', TRIM(clfile)
-            PRINT *, narea, '           unit   = ', knum
-            PRINT *, narea, '           iostat = ', iost
-            PRINT *, narea, '           retry  = ', itry
- 
- !          IF ( lk_mpp) CALL mppstop  ! cannot be used because lib_mpp use
-                                       ! in_out_manager -> circular reference
-            IF ( ( iost == 9 .OR. iost == 29 ) .AND. itry < 1 ) THEN
-              ! give up to 10 try before aborting
-              itry = itry + 1
-              GOTO 50
-            ENDIF
           STOP 'ctl_opn bad opening'
        ENDIF
        !
--- 4303,4308 ----
diff -bic /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/LBC/mppini.F90 /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/LBC/mppini.F90
*** /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/LBC/mppini.F90	Tue Apr  4 14:51:16 2017
--- /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/LBC/mppini.F90	Fri Feb 24 15:39:23 2017
***************
*** 23,29 ****
  
     !!----------------------------------------------------------------------
     !! NEMO/OPA 3.3 , NEMO Consortium (2010)
!    !! $Id: mppini.F90 4679 2014-06-20 10:17:06Z epico $ 
     !! Software governed by the CeCILL licence     (NEMOGCM/NEMO_CeCILL.txt)
     !!----------------------------------------------------------------------
  CONTAINS
--- 23,29 ----
  
     !!----------------------------------------------------------------------
     !! NEMO/OPA 3.3 , NEMO Consortium (2010)
!    !! $Id: mppini.F90 6412 2016-03-31 16:22:32Z lovato $ 
     !! Software governed by the CeCILL licence     (NEMOGCM/NEMO_CeCILL.txt)
     !!----------------------------------------------------------------------
  CONTAINS
***************
*** 323,329 ****
        nowe  = nproc - 1
        noea  = nproc + 1
        nono  = nproc + jpni
! 
        nlcj = nlcjt(narea)  
        nlci = nlcit(narea)  
        nldi = nldit(narea)
--- 323,353 ----
        nowe  = nproc - 1
        noea  = nproc + 1
        nono  = nproc + jpni
!       ! great neighbours
!       npnw = nono - 1
!       npne = nono + 1
!       npsw = noso - 1
!       npse = noso + 1
!       nbsw = 1
!       nbnw = 1
!       IF( MOD( nproc, jpni ) == 0 ) THEN
!          nbsw = 0
!          nbnw = 0
!       ENDIF
!       nbse = 1
!       nbne = 1
!       IF( MOD( nproc, jpni ) == jpni-1 ) THEN
!          nbse = 0
!          nbne = 0
!       ENDIF
!       IF(nproc < jpni) THEN
!          nbsw = 0
!          nbse = 0
!       ENDIF
!       IF( nproc >= (jpnj-1)*jpni ) THEN
!          nbnw = 0
!          nbne = 0
!       ENDIF
        nlcj = nlcjt(narea)  
        nlci = nlcit(narea)  
        nldi = nldit(narea)
***************
*** 340,349 ****
          CALL ctl_opn( inum, 'layout.dat', 'REPLACE', 'FORMATTED', 'SEQUENTIAL', -1, numout, .FALSE., narea )
          WRITE(inum,'(a)') '   jpnij     jpi     jpj     jpk  jpiglo  jpjglo'
          WRITE(inum,'(6i8)') jpnij,jpi,jpj,jpk,jpiglo,jpjglo
!         WRITE(inum,'(a)') 'RANK nlci nlcj nldi nldj nlei nlej nimpp njmpp'
  
          DO  jn = 1, jpnij
!          WRITE(inum,'(9i5)') jn-1, nlcit(jn), nlcjt(jn), &
                                        nldit(jn), nldjt(jn), &
                                        nleit(jn), nlejt(jn), &
                                        nimppt(jn), njmppt(jn)
--- 364,373 ----
          CALL ctl_opn( inum, 'layout.dat', 'REPLACE', 'FORMATTED', 'SEQUENTIAL', -1, numout, .FALSE., narea )
          WRITE(inum,'(a)') '   jpnij     jpi     jpj     jpk  jpiglo  jpjglo'
          WRITE(inum,'(6i8)') jpnij,jpi,jpj,jpk,jpiglo,jpjglo
!         WRITE(inum,'(a)') 'NAREA nlci nlcj nldi nldj nlei nlej nimpp njmpp'
  
          DO  jn = 1, jpnij
!          WRITE(inum,'(9i5)') jn, nlcit(jn), nlcjt(jn), &
                                        nldit(jn), nldjt(jn), &
                                        nleit(jn), nlejt(jn), &
                                        nimppt(jn), njmppt(jn)
***************
*** 414,423 ****
           WRITE(numout,*) ' nlcj   = ', nlcj
           WRITE(numout,*) ' nimpp  = ', nimpp
           WRITE(numout,*) ' njmpp  = ', njmpp
!          WRITE(numout,*) ' nbse   = ', nbse  , ' npse   = ', npse
!          WRITE(numout,*) ' nbsw   = ', nbsw  , ' npsw   = ', npsw
!          WRITE(numout,*) ' nbne   = ', nbne  , ' npne   = ', npne
!          WRITE(numout,*) ' nbnw   = ', nbnw  , ' npnw   = ', npnw
        ENDIF
  
        IF( nperio == 1 .AND. jpni /= 1 ) CALL ctl_stop( ' mpp_init: error on cyclicity' )
--- 438,448 ----
           WRITE(numout,*) ' nlcj   = ', nlcj
           WRITE(numout,*) ' nimpp  = ', nimpp
           WRITE(numout,*) ' njmpp  = ', njmpp
!          WRITE(numout,*) ' nreci  = ', nreci  , ' npse   = ', npse
!          WRITE(numout,*) ' nrecj  = ', nrecj  , ' npsw   = ', npsw
!          WRITE(numout,*) ' jpreci = ', jpreci , ' npne   = ', npne
!          WRITE(numout,*) ' jprecj = ', jprecj , ' npnw   = ', npnw
!          WRITE(numout,*)
        ENDIF
  
        IF( nperio == 1 .AND. jpni /= 1 ) CALL ctl_stop( ' mpp_init: error on cyclicity' )
diff -bic /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/LBC/mppini_2.h90 /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/LBC/mppini_2.h90
*** /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/LBC/mppini_2.h90	Tue Apr  4 14:56:58 2017
--- /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/LBC/mppini_2.h90	Fri Feb 24 15:39:23 2017
***************
*** 52,57 ****
--- 52,59 ----
           isurf, ijm1, imil,                &  !    "          "
           iino, ijno, iiso, ijso,           &  !    "          " 
           iiea, ijea, iiwe, ijwe,           &  !    "          "
+          iinw, ijnw, iine, ijne,           &  !    "          "
+          iisw, ijsw, iise, ijse,           &  !    "          "
           iresti, irestj, iproc                !    "          "
        INTEGER, DIMENSION(jpnij) ::   &
           iin, ijn          
***************
*** 59,79 ****
           iimppt, ijmppt, ilci  , ilcj  ,   &  ! temporary workspace
           ipproc, ibondj, ibondi, ipolj ,   &  !    "           "
           ilei  , ilej  , ildi  , ildj  ,   &  !    "           "
!          ioea  , iowe  , ioso  , iono         !    "           "
        INTEGER,  DIMENSION(jpiglo,jpjglo) ::   &
           imask                                ! temporary global workspace
        REAL(wp), DIMENSION(jpiglo,jpjglo) ::   &
           zdta, zdtaisf                     ! temporary data workspace
        REAL(wp) ::   zidom , zjdom          ! temporary scalars
  
-       INTEGER, DIMENSION(jpnij) :: ii_nono, ii_noso, ii_noea, ii_nowe
- 
        ! read namelist for ln_zco
        NAMELIST/namzgr/ ln_zco, ln_zps, ln_sco, ln_isfcav, ln_linssh
  
        !!----------------------------------------------------------------------
        !!  OPA 9.0 , LOCEAN-IPSL (2005) 
!       !! $Id: mppini_2.h90 5130 2015-03-05 19:59:13Z smasson $
        !! This software is governed by the CeCILL licence see modipsl/doc/NEMO_CeCILL.txt
        !!----------------------------------------------------------------------
  
--- 61,81 ----
           iimppt, ijmppt, ilci  , ilcj  ,   &  ! temporary workspace
           ipproc, ibondj, ibondi, ipolj ,   &  !    "           "
           ilei  , ilej  , ildi  , ildj  ,   &  !    "           "
!          ioea  , iowe  , ioso  , iono  ,   &  !    "           "
!          ione  , ionw  , iose  , iosw  ,   &  !    "           "
!          ibne  , ibnw  , ibse  , ibsw         !    "           "
        INTEGER,  DIMENSION(jpiglo,jpjglo) ::   &
           imask                                ! temporary global workspace
        REAL(wp), DIMENSION(jpiglo,jpjglo) ::   &
           zdta, zdtaisf                     ! temporary data workspace
        REAL(wp) ::   zidom , zjdom          ! temporary scalars
  
        ! read namelist for ln_zco
        NAMELIST/namzgr/ ln_zco, ln_zps, ln_sco, ln_isfcav, ln_linssh
  
        !!----------------------------------------------------------------------
        !!  OPA 9.0 , LOCEAN-IPSL (2005) 
!       !! $Id: mppini_2.h90 6412 2016-03-31 16:22:32Z lovato $
        !! This software is governed by the CeCILL licence see modipsl/doc/NEMO_CeCILL.txt
        !!----------------------------------------------------------------------
  
***************
*** 111,118 ****
           CALL iom_open ( 'bathy_meter.nc', inum )   ! Meter bathy in case of partial steps
           IF ( ln_isfcav ) THEN
               CALL iom_get ( inum, jpdom_unknown, 'Bathymetry_isf' , zdta, kstart=(/jpizoom,jpjzoom/), kcount=(/jpiglo,jpjglo/) )
-                ! JMM FIX fix jmm
-                zdta ( 1007+141, 482) = 0.
           ELSE
               ! Optionally use a file attribute (open_ocean_jstart) to set a start row for reading from the global file
               ! This allows the unextended grid bathymetry to be stored in the same file as the under ice-shelf extended bathymetry
--- 113,118 ----
***************
*** 129,145 ****
        IF ( ln_isfcav ) THEN
           CALL iom_open ( 'bathy_meter.nc', inum )   ! Meter bathy in case of partial steps
           CALL iom_get ( inum, jpdom_unknown, 'isf_draft' , zdtaisf, kstart=(/jpizoom,jpjzoom/), kcount=(/jpiglo,jpjglo/) )
!       ENDIF
        CALL iom_close (inum)
  
        ! land/sea mask over the global/zoom domain
  
        imask(:,:)=1
!          !JMM fix :                                 ----------------------------
!       WHERE ( zdta(:,:) == 0._wp ) imask=0 
!       ! mask additional point under ice_shelve accordin to rn_isfhmin criteria
!       WHERE ( zdta(:,:) - zdtaisf(:,:) <= rn_isfhmin .AND. zdtaisf(:,:) > 0._wp ) imask = 0
! !     WHERE ( zdta(:,:) - zdtaisf(:,:) <= rn_isfhmin ) imask = 0
  
        !  1. Dimension arrays for subdomains
        ! -----------------------------------
--- 129,141 ----
        IF ( ln_isfcav ) THEN
           CALL iom_open ( 'bathy_meter.nc', inum )   ! Meter bathy in case of partial steps
           CALL iom_get ( inum, jpdom_unknown, 'isf_draft' , zdtaisf, kstart=(/jpizoom,jpjzoom/), kcount=(/jpiglo,jpjglo/) )
!       END IF
        CALL iom_close (inum)
  
        ! land/sea mask over the global/zoom domain
  
        imask(:,:)=1
!       WHERE ( zdta(:,:) - zdtaisf(:,:) <= rn_isfhmin ) imask = 0
  
        !  1. Dimension arrays for subdomains
        ! -----------------------------------
***************
*** 242,248 ****
           iono(ii,ij) = iproc + jpni
           ildi(ii,ij) = 1 + jpreci
           ilei(ii,ij) = ili -jpreci
! 
           IF( ibondi(ii,ij) == -1 .OR. ibondi(ii,ij) == 2 ) ildi(ii,ij) = 1
           IF( ibondi(ii,ij) ==  1 .OR. ibondi(ii,ij) == 2 ) ilei(ii,ij) = ili
           ildj(ii,ij) =  1  + jprecj
--- 238,267 ----
           iono(ii,ij) = iproc + jpni
           ildi(ii,ij) = 1 + jpreci
           ilei(ii,ij) = ili -jpreci
!          ionw(ii,ij) = iono(ii,ij) - 1
!          ione(ii,ij) = iono(ii,ij) + 1
!          iosw(ii,ij) = ioso(ii,ij) - 1
!          iose(ii,ij) = ioso(ii,ij) + 1
!          ibsw(ii,ij) = 1
!          ibnw(ii,ij) = 1
!          IF( MOD(iproc,jpni) == 0 ) THEN
!             ibsw(ii,ij) = 0
!             ibnw(ii,ij) = 0
!          ENDIF
!          ibse(ii,ij) = 1
!          ibne(ii,ij) = 1
!          IF( MOD(iproc,jpni) == jpni-1 ) THEN
!             ibse(ii,ij) = 0
!             ibne(ii,ij) = 0
!          ENDIF
!          IF( iproc < jpni ) THEN
!             ibsw(ii,ij) = 0
!             ibse(ii,ij) = 0
!          ENDIF
!          IF( iproc >= (jpnj-1)*jpni ) THEN
!             ibnw(ii,ij) = 0
!             ibne(ii,ij) = 0
!          ENDIF
           IF( ibondi(ii,ij) == -1 .OR. ibondi(ii,ij) == 2 ) ildi(ii,ij) = 1
           IF( ibondi(ii,ij) ==  1 .OR. ibondi(ii,ij) == 2 ) ilei(ii,ij) = ili
           ildj(ii,ij) =  1  + jprecj
***************
*** 261,272 ****
              ENDIF
              IF( MOD(jarea,jpni) == 0 ) THEN
                 ioea(ii,ij) = iproc - (jpni-1)
              ENDIF
              IF( MOD(jarea,jpni) == 1 ) THEN
                 iowe(ii,ij) = iproc + jpni - 1
              ENDIF
           ENDIF
- !{ added from Epicoco
           ipolj(ii,ij) = 0
           IF( jperio == 3 .OR. jperio == 4 ) THEN
              ijm1 = jpni*(jpnj-1)
--- 280,306 ----
              ENDIF
              IF( MOD(jarea,jpni) == 0 ) THEN
                 ioea(ii,ij) = iproc - (jpni-1)
+                ione(ii,ij) = ione(ii,ij) - jpni
+                iose(ii,ij) = iose(ii,ij) - jpni
              ENDIF
              IF( MOD(jarea,jpni) == 1 ) THEN
                 iowe(ii,ij) = iproc + jpni - 1
+                ionw(ii,ij) = ionw(ii,ij) + jpni
+                iosw(ii,ij) = iosw(ii,ij) + jpni 
+             ENDIF
+             ibsw(ii,ij) = 1
+             ibnw(ii,ij) = 1
+             ibse(ii,ij) = 1
+             ibne(ii,ij) = 1
+             IF( iproc < jpni ) THEN
+                ibsw(ii,ij) = 0
+                ibse(ii,ij) = 0
+             ENDIF
+             IF( iproc >= (jpnj-1)*jpni ) THEN
+                ibnw(ii,ij) = 0
+                ibne(ii,ij) = 0
              ENDIF
           ENDIF
           ipolj(ii,ij) = 0
           IF( jperio == 3 .OR. jperio == 4 ) THEN
              ijm1 = jpni*(jpnj-1)
***************
*** 281,292 ****
              IF( jarea > ijm1) ipolj(ii,ij) = 5
              IF( MOD(jpni,2) == 1 .AND. jarea == imil ) ipolj(ii,ij) = 6
              IF( ipolj(ii,ij) == 5) iono(ii,ij) = jpni*jpnj-jarea+ijm1    ! MPI rank of northern neighbour
- !} check if it works !!!
           ENDIF
  
           isurf = 0
!          DO jj = 1+jprecj, ilj-jprecj
!             DO  ji = 1+jpreci, ili-jpreci
                 IF( imask(ji+iimppt(ii,ij)-1, jj+ijmppt(ii,ij)-1) == 1) isurf = isurf+1
              END DO
           END DO
--- 315,326 ----
              IF( jarea > ijm1) ipolj(ii,ij) = 5
              IF( MOD(jpni,2) == 1 .AND. jarea == imil ) ipolj(ii,ij) = 6
              IF( ipolj(ii,ij) == 5) iono(ii,ij) = jpni*jpnj-jarea+ijm1    ! MPI rank of northern neighbour
           ENDIF
  
+          ! Check wet points over the entire domain to preserve the MPI communication stencil
           isurf = 0
!          DO jj = 1, ilj
!             DO  ji = 1, ili
                 IF( imask(ji+iimppt(ii,ij)-1, jj+ijmppt(ii,ij)-1) == 1) isurf = isurf+1
              END DO
           END DO
***************
*** 378,432 ****
              IF( ibondi(iiwe,ijwe) == -1 ) ibondi(iiwe,ijwe) = 2
              IF( ibondi(iiwe,ijwe) ==  0 ) ibondi(iiwe,ijwe) = 1
           ENDIF
        END DO
  
  
!       ! just to save nono etc for all proc
!       ii_noso(:) = -1
!       ii_nono(:) = -1
!       ii_noea(:) = -1
!       ii_nowe(:) = -1 
        nproc = narea-1
!       DO jarea = 1, jpnij
!         ii = iin(jarea)
!         ij = ijn(jarea)
        IF( ioso(ii,ij) >= 0 .AND. ioso(ii,ij) <= (jpni*jpnj-1) ) THEN
           iiso = 1 + MOD(ioso(ii,ij),jpni)
           ijso = 1 +    (ioso(ii,ij))/jpni
           noso = ipproc(iiso,ijso)
-          ii_noso(jarea)= noso
        ENDIF
        IF( iowe(ii,ij) >= 0 .AND. iowe(ii,ij) <= (jpni*jpnj-1) ) THEN
           iiwe = 1 + MOD(iowe(ii,ij),jpni)
           ijwe = 1 +    (iowe(ii,ij))/jpni
           nowe = ipproc(iiwe,ijwe)
-          ii_nowe(jarea)= nowe
        ENDIF
        IF( ioea(ii,ij) >= 0 .AND. ioea(ii,ij) <= (jpni*jpnj-1) ) THEN
           iiea = 1 + MOD(ioea(ii,ij),jpni)
           ijea = 1 +    (ioea(ii,ij))/jpni
           noea = ipproc(iiea,ijea)
-          ii_noea(jarea)= noea
        ENDIF
        IF( iono(ii,ij) >= 0 .AND. iono(ii,ij) <= (jpni*jpnj-1) ) THEN
           iino = 1 + MOD(iono(ii,ij),jpni)
           ijno = 1 +    (iono(ii,ij))/jpni
           nono = ipproc(iino,ijno)
-          ii_nono(jarea)= nono
        ENDIF
!       END DO
!       ! 6. Change processor name
!       ! ------------------------
! 
!       nproc = narea-1
!       ii = iin(narea)
!       ij = ijn(narea)
! 
!       nono = ii_nono(narea)
!       noea = ii_noea(narea)
!       nowe = ii_nowe(narea)
!       noso = ii_noso(narea)
! 
        nlcj = ilcj(ii,ij)  
        nlci = ilci(ii,ij)  
        nldi = ildi(ii,ij)
--- 412,502 ----
              IF( ibondi(iiwe,ijwe) == -1 ) ibondi(iiwe,ijwe) = 2
              IF( ibondi(iiwe,ijwe) ==  0 ) ibondi(iiwe,ijwe) = 1
           ENDIF
+          IF( ipproc(ii,ij) == -1 .AND. ibne(ii,ij) == 1 ) THEN
+             iine = 1 + MOD(ione(ii,ij),jpni)
+             ijne = 1 +    (ione(ii,ij))/jpni
+             IF( ibsw(iine,ijne) == 1 ) ibsw(iine,ijne) = 0
+          ENDIF
+          IF( ipproc(ii,ij) == -1 .AND. ibsw(ii,ij) == 1 ) THEN
+             iisw = 1 + MOD(iosw(ii,ij),jpni)
+             ijsw = 1 +    (iosw(ii,ij))/jpni
+             IF( ibne(iisw,ijsw) == 1 ) ibne(iisw,ijsw) = 0
+          ENDIF
+          IF( ipproc(ii,ij) == -1 .AND. ibnw(ii,ij) == 1 ) THEN
+             iinw = 1 + MOD(ionw(ii,ij),jpni)
+             ijnw = 1 +    (ionw(ii,ij))/jpni
+             IF( ibse(iinw,ijnw) == 1 ) ibse(iinw,ijnw)=0
+          ENDIF
+          IF( ipproc(ii,ij) == -1 .AND. ibse(ii,ij) == 1 ) THEN
+             iise = 1 + MOD(iose(ii,ij),jpni)
+             ijse = 1 +    (iose(ii,ij))/jpni
+             IF( ibnw(iise,ijse) == 1 ) ibnw(iise,ijse) = 0
+          ENDIF
        END DO
  
  
!       ! 6. Change processor name
!       ! ------------------------
! 
        nproc = narea-1
!       ii = iin(narea)
!       ij = ijn(narea)
! 
!       ! set default neighbours
!       noso = ioso(ii,ij)
!       nowe = iowe(ii,ij)
!       noea = ioea(ii,ij)
!       nono = iono(ii,ij) 
!       npse = iose(ii,ij)
!       npsw = iosw(ii,ij)
!       npne = ione(ii,ij)
!       npnw = ionw(ii,ij)
! 
!       ! check neighbours location
        IF( ioso(ii,ij) >= 0 .AND. ioso(ii,ij) <= (jpni*jpnj-1) ) THEN 
           iiso = 1 + MOD(ioso(ii,ij),jpni)
           ijso = 1 +    (ioso(ii,ij))/jpni
           noso = ipproc(iiso,ijso)
        ENDIF
        IF( iowe(ii,ij) >= 0 .AND. iowe(ii,ij) <= (jpni*jpnj-1) ) THEN 
           iiwe = 1 + MOD(iowe(ii,ij),jpni)
           ijwe = 1 +    (iowe(ii,ij))/jpni
           nowe = ipproc(iiwe,ijwe)
        ENDIF
        IF( ioea(ii,ij) >= 0 .AND. ioea(ii,ij) <= (jpni*jpnj-1) ) THEN 
           iiea = 1 + MOD(ioea(ii,ij),jpni)
           ijea = 1 +    (ioea(ii,ij))/jpni
           noea = ipproc(iiea,ijea)
        ENDIF
        IF( iono(ii,ij) >= 0 .AND. iono(ii,ij) <= (jpni*jpnj-1) ) THEN 
           iino = 1 + MOD(iono(ii,ij),jpni)
           ijno = 1 +    (iono(ii,ij))/jpni
           nono = ipproc(iino,ijno)
        ENDIF
!       IF( iose(ii,ij) >= 0 .AND. iose(ii,ij) <= (jpni*jpnj-1) ) THEN 
!          iise = 1 + MOD(iose(ii,ij),jpni)
!          ijse = 1 +    (iose(ii,ij))/jpni
!          npse = ipproc(iise,ijse)
!       ENDIF
!       IF( iosw(ii,ij) >= 0 .AND. iosw(ii,ij) <= (jpni*jpnj-1) ) THEN 
!          iisw = 1 + MOD(iosw(ii,ij),jpni)
!          ijsw = 1 +    (iosw(ii,ij))/jpni
!          npsw = ipproc(iisw,ijsw)
!       ENDIF
!       IF( ione(ii,ij) >= 0 .AND. ione(ii,ij) <= (jpni*jpnj-1) ) THEN 
!          iine = 1 + MOD(ione(ii,ij),jpni)
!          ijne = 1 +    (ione(ii,ij))/jpni
!          npne = ipproc(iine,ijne)
!       ENDIF
!       IF( ionw(ii,ij) >= 0 .AND. ionw(ii,ij) <= (jpni*jpnj-1) ) THEN 
!          iinw = 1 + MOD(ionw(ii,ij),jpni)
!          ijnw = 1 +    (ionw(ii,ij))/jpni
!          npnw = ipproc(iinw,ijnw)
!       ENDIF
!       nbnw = ibnw(ii,ij)
!       nbne = ibne(ii,ij)
!       nbsw = ibsw(ii,ij)
!       nbse = ibse(ii,ij)
        nlcj = ilcj(ii,ij)  
        nlci = ilci(ii,ij)  
        nldi = ildi(ii,ij)
***************
*** 455,473 ****
           CALL ctl_opn( inum, 'layout.dat', 'REPLACE', 'FORMATTED', 'SEQUENTIAL', -1, numout, .FALSE., narea )
           WRITE(inum,'(a)') '   jpnij     jpi     jpj     jpk  jpiglo  jpjglo'
           WRITE(inum,'(6i8)') jpnij,jpi,jpj,jpk,jpiglo,jpjglo
!          WRITE(inum,'(a)') 'RANK  nlci nlcj nldi nldj nlei nlej nimpp njmpp nono noso nowe noea nbondi nbondj '
  
          DO  jproc = 1, jpnij
!          ii = iin(jproc)
!          ij = ijn(jproc)
! 
!          WRITE(inum,'(15i5)') jproc-1, nlcit(jproc), nlcjt(jproc),     &
                                         nldit(jproc), nldjt(jproc),     &
                                         nleit(jproc), nlejt(jproc),     &
!                                        nimppt(jproc), njmppt(jproc),   & 
!                                        ii_nono(jproc), ii_noso(jproc), &
!                                        ii_nowe(jproc), ii_noea(jproc), &
!                                        ibondi(ii,ij),  ibondj(ii,ij) 
          END DO
          CLOSE(inum)   
        END IF
--- 525,537 ----
           CALL ctl_opn( inum, 'layout.dat', 'REPLACE', 'FORMATTED', 'SEQUENTIAL', -1, numout, .FALSE., narea )
           WRITE(inum,'(a)') '   jpnij     jpi     jpj     jpk  jpiglo  jpjglo'
           WRITE(inum,'(6i8)') jpnij,jpi,jpj,jpk,jpiglo,jpjglo
!          WRITE(inum,'(a)') 'NAREA nlci nlcj nldi nldj nlei nlej nimpp njmpp'
  
          DO  jproc = 1, jpnij
!          WRITE(inum,'(9i5)') jproc, nlcit(jproc), nlcjt(jproc), &
                                        nldit(jproc), nldjt(jproc), &
                                        nleit(jproc), nlejt(jproc), &
!                                       nimppt(jproc), njmppt(jproc)
          END DO
          CLOSE(inum)   
        END IF
***************
*** 502,508 ****
           WRITE(numout,*) ' nlcj   = ', nlcj
           WRITE(numout,*) ' nimpp  = ', nimpp
           WRITE(numout,*) ' njmpp  = ', njmpp
! 
           WRITE(numout,*)
        ENDIF
  
--- 566,575 ----
           WRITE(numout,*) ' nlcj   = ', nlcj
           WRITE(numout,*) ' nimpp  = ', nimpp
           WRITE(numout,*) ' njmpp  = ', njmpp
!          WRITE(numout,*) ' nreci  = ', nreci  , ' npse   = ', npse
!          WRITE(numout,*) ' nrecj  = ', nrecj  , ' npsw   = ', npsw
!          WRITE(numout,*) ' jpreci = ', jpreci , ' npne   = ', npne
!          WRITE(numout,*) ' jprecj = ', jprecj , ' npnw   = ', npnw
           WRITE(numout,*)
        ENDIF
  
Only in /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/LDF: .gitkeep
diff -bic /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/LDF/ldfc1d_c2d.F90 /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/LDF/ldfc1d_c2d.F90
*** /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/LDF/ldfc1d_c2d.F90	Tue Apr  4 14:56:58 2017
--- /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/LDF/ldfc1d_c2d.F90	Fri Feb 24 15:39:23 2017
***************
*** 124,130 ****
        !
        INTEGER  ::   ji, jj, jk   ! dummy loop indices
        REAL(wp) ::   za00, zd_max, zemax1, zemax2   ! local scalar
-       REAL(wp), DIMENSION(jpi,jpj) :: zah1, zah2
        !!----------------------------------------------------------------------
        !
        zd_max = ra * rad       ! = 1 degree at the equator in meters
--- 124,129 ----
***************
*** 143,156 ****
              za00 = pah0 / zd_max
              DO jj = 1, jpj 
                 DO ji = 1, jpi 
! !                 zemax1 = MAX( e1t(ji,jj), e2t(ji,jj) ) * tmask(ji,jj,1)
! !                 zemax2 = MAX( e1f(ji,jj), e2f(ji,jj) ) * fmask(ji,jj,1)
! !                 pah1(ji,jj,1) = za00 * zemax1
! !                 pah2(ji,jj,1) = za00 * zemax2
!                   zemax1 = MAX( e1t(ji,jj), e2t(ji,jj) )
!                   zemax2 = MAX( e1f(ji,jj), e2f(ji,jj) )
!                   zah1(ji,jj) = za00 * zemax1
!                   zah2(ji,jj) = za00 * zemax2
                 END DO
              END DO
           ELSEIF( cd_op == 'BLP' ) THEN     ! bilaplacian operator
--- 142,151 ----
              za00 = pah0 / zd_max
              DO jj = 1, jpj 
                 DO ji = 1, jpi 
!                   zemax1 = MAX( e1t(ji,jj), e2t(ji,jj) ) * tmask(ji,jj,1)
!                   zemax2 = MAX( e1f(ji,jj), e2f(ji,jj) ) * fmask(ji,jj,1)
!                   pah1(ji,jj,1) = za00 * zemax1
!                   pah2(ji,jj,1) = za00 * zemax2
                 END DO
              END DO
           ELSEIF( cd_op == 'BLP' ) THEN     ! bilaplacian operator
***************
*** 158,183 ****
              za00 = pah0 / ( zd_max * zd_max * zd_max )
              DO jj = 1, jpj
                 DO ji = 1, jpi
! !                 zemax1 = MAX( e1t(ji,jj), e2t(ji,jj) ) * tmask(ji,jj,1)
! !                 zemax2 = MAX( e1f(ji,jj), e2f(ji,jj) ) * fmask(ji,jj,1)
! !                 pah1(ji,jj,1) = za00 * zemax1 * zemax1 * zemax1 
! !                 pah2(ji,jj,1) = za00 * zemax2 * zemax2 * zemax2 
!                   zemax1 = MAX( e1t(ji,jj), e2t(ji,jj) )
!                   zemax2 = MAX( e1f(ji,jj), e2f(ji,jj) )
!                   zah1(ji,jj) = za00 * zemax1 * zemax1 * zemax1 
!                   zah2(ji,jj) = za00 * zemax2 * zemax2 * zemax2 
                 END DO
              END DO
           ELSE                                ! NO diffusion/viscosity
              CALL ctl_stop( 'ldf_c2d: ', cd_op, ' case. Unknown lateral operator ' )
           ENDIF
           !                                !  deeper values  (LAP and BLP cases)
! !        DO jk = 2, jpk
!          DO jk = 1, jpk
! !           pah1(:,:,jk) = pah1(:,:,1) * tmask(:,:,jk) 
! !           pah2(:,:,jk) = pah2(:,:,1) * fmask(:,:,jk) 
!             pah1(:,:,jk) = zah1(:,:) * tmask(:,:,jk) 
!             pah2(:,:,jk) = zah2(:,:) * fmask(:,:,jk) 
           END DO
           !
        CASE( 'TRA' )                     ! U- and V-points (approximation in zps-coord.)
--- 153,171 ----
              za00 = pah0 / ( zd_max * zd_max * zd_max )
              DO jj = 1, jpj
                 DO ji = 1, jpi
!                   zemax1 = MAX( e1t(ji,jj), e2t(ji,jj) ) * tmask(ji,jj,1)
!                   zemax2 = MAX( e1f(ji,jj), e2f(ji,jj) ) * fmask(ji,jj,1)
!                   pah1(ji,jj,1) = za00 * zemax1 * zemax1 * zemax1 
!                   pah2(ji,jj,1) = za00 * zemax2 * zemax2 * zemax2 
                 END DO
              END DO
           ELSE                                ! NO diffusion/viscosity
              CALL ctl_stop( 'ldf_c2d: ', cd_op, ' case. Unknown lateral operator ' )
           ENDIF
           !                                !  deeper values  (LAP and BLP cases)
!          DO jk = 2, jpk
!             pah1(:,:,jk) = pah1(:,:,1) * tmask(:,:,jk) 
!             pah2(:,:,jk) = pah2(:,:,1) * fmask(:,:,jk) 
           END DO
           !
        CASE( 'TRA' )                     ! U- and V-points (approximation in zps-coord.)
***************
*** 186,199 ****
              za00 = pah0 / zd_max
              DO jj = 1, jpj 
                 DO ji = 1, jpi 
! !                 zemax1 = MAX( e1u(ji,jj), e2u(ji,jj) ) * umask(ji,jj,1)
! !                 zemax2 = MAX( e1v(ji,jj), e2v(ji,jj) ) * vmask(ji,jj,1)
! !                 pah1(ji,jj,1) = za00 * zemax1
! !                 pah2(ji,jj,1) = za00 * zemax2
!                   zemax1 = MAX( e1u(ji,jj), e2u(ji,jj) )
!                   zemax2 = MAX( e1v(ji,jj), e2v(ji,jj) )
!                   zah1(ji,jj) = za00 * zemax1
!                   zah2(ji,jj) = za00 * zemax2
                 END DO
              END DO
           ELSEIF( cd_op == 'BLP' ) THEN      ! bilaplacian operator (NB: square root of the coeff)
--- 174,183 ----
              za00 = pah0 / zd_max
              DO jj = 1, jpj 
                 DO ji = 1, jpi 
!                   zemax1 = MAX( e1u(ji,jj), e2u(ji,jj) ) * umask(ji,jj,1)
!                   zemax2 = MAX( e1v(ji,jj), e2v(ji,jj) ) * vmask(ji,jj,1)
!                   pah1(ji,jj,1) = za00 * zemax1
!                   pah2(ji,jj,1) = za00 * zemax2
                 END DO
              END DO
           ELSEIF( cd_op == 'BLP' ) THEN      ! bilaplacian operator (NB: square root of the coeff)
***************
*** 201,226 ****
              za00 = pah0 / ( zd_max * zd_max * zd_max )
              DO jj = 1, jpj
                 DO ji = 1, jpi
! !                 zemax1 = MAX( e1u(ji,jj), e2u(ji,jj) ) * umask(ji,jj,1) 
! !                 zemax2 = MAX( e1v(ji,jj), e2v(ji,jj) ) * vmask(ji,jj,1) 
! !                 pah1(ji,jj,1) = za00 * zemax1 * zemax1 * zemax1 
! !                 pah2(ji,jj,1) = za00 * zemax2 * zemax2 * zemax2 
!                   zemax1 = MAX( e1u(ji,jj), e2u(ji,jj) )
!                   zemax2 = MAX( e1v(ji,jj), e2v(ji,jj) )
!                   zah1(ji,jj) = za00 * zemax1 * zemax1 * zemax1 
!                   zah2(ji,jj) = za00 * zemax2 * zemax2 * zemax2 
                 END DO
              END DO
           ELSE                                ! NO diffusion/viscosity
              CALL ctl_stop( 'ldf_c2d: ', cd_op, ' case. Unknown lateral operator ' )
           ENDIF
           !                                !  deeper values  (LAP and BLP cases)
! !        DO jk = 2, jpk
!          DO jk = 1, jpk
! !           pah1(:,:,jk) = pah1(:,:,1) * umask(:,:,jk) 
! !           pah2(:,:,jk) = pah2(:,:,1) * vmask(:,:,jk) 
!             pah1(:,:,jk) = zah1(:,:) * umask(:,:,jk) 
!             pah2(:,:,jk) = zah2(:,:) * vmask(:,:,jk) 
           END DO
           !
        END SELECT
--- 185,203 ----
              za00 = pah0 / ( zd_max * zd_max * zd_max )
              DO jj = 1, jpj
                 DO ji = 1, jpi
!                   zemax1 = MAX( e1u(ji,jj), e2u(ji,jj) ) * umask(ji,jj,1) 
!                   zemax2 = MAX( e1v(ji,jj), e2v(ji,jj) ) * vmask(ji,jj,1) 
!                   pah1(ji,jj,1) = za00 * zemax1 * zemax1 * zemax1 
!                   pah2(ji,jj,1) = za00 * zemax2 * zemax2 * zemax2 
                 END DO
              END DO
           ELSE                                ! NO diffusion/viscosity
              CALL ctl_stop( 'ldf_c2d: ', cd_op, ' case. Unknown lateral operator ' )
           ENDIF
           !                                !  deeper values  (LAP and BLP cases)
!          DO jk = 2, jpk
!             pah1(:,:,jk) = pah1(:,:,1) * umask(:,:,jk) 
!             pah2(:,:,jk) = pah2(:,:,1) * vmask(:,:,jk) 
           END DO
           !
        END SELECT
diff -bic /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/LDF/ldfdyn.F90 /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/LDF/ldfdyn.F90
*** /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/LDF/ldfdyn.F90	Tue Apr  4 14:56:58 2017
--- /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/LDF/ldfdyn.F90	Fri Feb 24 15:39:23 2017
***************
*** 211,218 ****
              CALL ctl_stop('ldf_dyn_init: wrong choice for nn_ahm_ijk_t, the type of space-time variation of ahm')
           END SELECT
           !
- ! JMM TEST : no SQRT here case 20   nn_ahm_ijk_t
- !        IF( ln_dynldf_blp .AND. .NOT. l_ldfdyn_time .AND. nn_ahm_ijk_t /= 20 ) THEN       ! bilapcian and no time variation:
           IF( ln_dynldf_blp .AND. .NOT. l_ldfdyn_time ) THEN       ! bilapcian and no time variation:
              ahmt(:,:,:) = SQRT( ahmt(:,:,:) )                     ! take the square root of the coefficient
              ahmf(:,:,:) = SQRT( ahmf(:,:,:) )
--- 211,216 ----
Only in /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/OBS: .gitkeep
diff -bic /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/SBC/sbcblk_core.F90 /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/SBC/sbcblk_core.F90
*** /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/SBC/sbcblk_core.F90	Tue Apr  4 14:51:16 2017
--- /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/SBC/sbcblk_core.F90	Fri Feb 24 15:39:23 2017
***************
*** 62,80 ****
  #endif
     PUBLIC   turb_core_2z         ! routine calles in sbcblk_mfs module
  
- ! most of the PARAMETERS are made PUBLIC because they are used somehow in the dia_wri routine (flx)      
     INTEGER , PARAMETER         ::   jpfld   = 9   ! maximum number of files to read 
!    INTEGER , PUBLIC, PARAMETER ::   jp_wndi = 1   ! index of 10m wind velocity (i-component) (m/s)    at T-point
!    INTEGER , PUBLIC, PARAMETER ::   jp_wndj = 2   ! index of 10m wind velocity (j-component) (m/s)    at T-point
!    INTEGER , PUBLIC, PARAMETER ::   jp_humi = 3   ! index of specific humidity               ( - )
!    INTEGER , PUBLIC, PARAMETER ::   jp_qsr  = 4   ! index of solar heat                      (W/m2)
!    INTEGER , PUBLIC, PARAMETER ::   jp_qlw  = 5   ! index of Long wave                       (W/m2)
!    INTEGER , PUBLIC, PARAMETER ::   jp_tair = 6   ! index of 10m air temperature             (Kelvin)
!    INTEGER , PUBLIC, PARAMETER ::   jp_prec = 7   ! index of total precipitation (rain+snow) (Kg/m2/s)
!    INTEGER , PUBLIC, PARAMETER ::   jp_snow = 8   ! index of snow (solid prcipitation)       (kg/m2/s)
!    INTEGER , PUBLIC, PARAMETER ::   jp_tdif = 9   ! index of tau diff associated to HF tau   (N/m2)   at T-point
  
!    TYPE(FLD), PUBLIC, ALLOCATABLE, DIMENSION(:) ::   sf   ! structure of input fields (file informations, fields read)
           
     !                                             !!! CORE bulk parameters
     REAL(wp), PARAMETER ::   rhoa =    1.22        ! air density
--- 62,79 ----
  #endif
     PUBLIC   turb_core_2z         ! routine calles in sbcblk_mfs module
  
     INTEGER , PARAMETER ::   jpfld   = 9           ! maximum number of files to read
!    INTEGER , PARAMETER ::   jp_wndi = 1           ! index of 10m wind velocity (i-component) (m/s)    at T-point
!    INTEGER , PARAMETER ::   jp_wndj = 2           ! index of 10m wind velocity (j-component) (m/s)    at T-point
!    INTEGER , PARAMETER ::   jp_humi = 3           ! index of specific humidity               ( % )
!    INTEGER , PARAMETER ::   jp_qsr  = 4           ! index of solar heat                      (W/m2)
!    INTEGER , PARAMETER ::   jp_qlw  = 5           ! index of Long wave                       (W/m2)
!    INTEGER , PARAMETER ::   jp_tair = 6           ! index of 10m air temperature             (Kelvin)
!    INTEGER , PARAMETER ::   jp_prec = 7           ! index of total precipitation (rain+snow) (Kg/m2/s)
!    INTEGER , PARAMETER ::   jp_snow = 8           ! index of snow (solid prcipitation)       (kg/m2/s)
!    INTEGER , PARAMETER ::   jp_tdif = 9           ! index of tau diff associated to HF tau   (N/m2)   at T-point
  
!    TYPE(FLD), ALLOCATABLE, DIMENSION(:) ::   sf   ! structure of input fields (file informations, fields read)
  
     !                                             !!! CORE bulk parameters
     REAL(wp), PARAMETER ::   rhoa =    1.22        ! air density
***************
*** 92,124 ****
     REAL(wp) ::   rn_vfac     ! multiplication factor for ice/ocean velocity in the calculation of wind stress (clem)
     REAL(wp) ::   rn_zqt      ! z(q,t) : height of humidity and temperature measurements
     REAL(wp) ::   rn_zu       ! z(u)   : height of wind measurements
-    !{ DRAKKAR add JMM
-    LOGICAL  ::   ln_kata     ! logical flag for katabatic winds enhancement
-    CHARACTER(len=32) :: cl_katfile                !: katabatic filename
-    REAL(wp) , PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:) :: rmskkatax  !: array for katamask (T-point)
-    REAL(wp) , PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:) :: rmskkatay  !: array for katamask (T-point)
-    !}
  
     !! * Substitutions
  #  include "vectopt_loop_substitute.h90"
     !!----------------------------------------------------------------------
     !! NEMO/OPA 3.7 , NEMO-consortium (2014)
!    !! $Id: sbcblk_core.F90 5583 2015-07-10 13:23:59Z jchanut $
     !! Software governed by the CeCILL licence     (NEMOGCM/NEMO_CeCILL.txt)
     !!----------------------------------------------------------------------
  CONTAINS
  
-    INTEGER FUNCTION sbc_kata_alloc()
-       !!----------------------------------------------------------------------
-       !!                ***  FUNCTION sbc_kata_alloc  ***
-       !!----------------------------------------------------------------------
-       ALLOCATE( rmskkatax(jpi,jpj), rmskkatay(jpi,jpj),  STAT= sbc_kata_alloc )
-       !
-       IF( lk_mpp             )   CALL mpp_sum ( sbc_kata_alloc )
-       IF( sbc_kata_alloc > 0 )   CALL ctl_warn('sbc_kata_alloc: allocation of arrays failed')
-       !
-    END FUNCTION sbc_kata_alloc
- 
     SUBROUTINE sbc_blk_core( kt )
        !!---------------------------------------------------------------------
        !!                    ***  ROUTINE sbc_blk_core  ***
--- 91,106 ----
     REAL(wp) ::   rn_vfac     ! multiplication factor for ice/ocean velocity in the calculation of wind stress (clem)
     REAL(wp) ::   rn_zqt      ! z(q,t) : height of humidity and temperature measurements
     REAL(wp) ::   rn_zu       ! z(u)   : height of wind measurements
  
     !! * Substitutions
  #  include "vectopt_loop_substitute.h90"
     !!----------------------------------------------------------------------
     !! NEMO/OPA 3.7 , NEMO-consortium (2014)
!    !! $Id: sbcblk_core.F90 6813 2016-07-21 09:04:14Z mathiot $
     !! Software governed by the CeCILL licence     (NEMOGCM/NEMO_CeCILL.txt)
     !!----------------------------------------------------------------------
  CONTAINS
  
     SUBROUTINE sbc_blk_core( kt )
        !!---------------------------------------------------------------------
        !!                    ***  ROUTINE sbc_blk_core  ***
***************
*** 159,179 ****
        INTEGER  ::   ifpr     ! dummy loop indice
        INTEGER  ::   jfld     ! dummy loop arguments
        INTEGER  ::   ios      ! Local integer output status for namelist read
!       INTEGER  ::   inum     ! logical unit for IOM
!       !!
        CHARACTER(len=100) ::  cn_dir   !   Root directory for location of core files
        TYPE(FLD_N), DIMENSION(jpfld) ::   slf_i     ! array of namelist informations on the fields to read
        TYPE(FLD_N) ::   sn_wndi, sn_wndj, sn_humi, sn_qsr       ! informations about the fields to be read
        TYPE(FLD_N) ::   sn_qlw , sn_tair, sn_prec, sn_snow      !   "                                 "
        TYPE(FLD_N) ::   sn_tdif                                 !   "                                 "
-       TYPE(FLD_N) ::   sn_kati, sn_katj                        ! informations for katabatic winds
        NAMELIST/namsbc_core/ cn_dir , ln_taudif, rn_pfac, rn_efac, rn_vfac,  &
!          &                  sn_wndi, sn_wndj, sn_humi  , sn_qsr ,           &
!          &                  sn_qlw , sn_tair, sn_prec  , sn_snow,           &
!          &                  sn_tdif, rn_zqt , rn_zu,                        &
!          &                  ln_kata, sn_kati, sn_katj
        !!---------------------------------------------------------------------
- 
        !
        !                                         ! ====================== !
        IF( kt == nit000 ) THEN                   !  First call kt=nit000  !
--- 141,157 ----
        INTEGER  ::   ifpr     ! dummy loop indice
        INTEGER  ::   jfld     ! dummy loop arguments
        INTEGER  ::   ios      ! Local integer output status for namelist read
!       !
        CHARACTER(len=100) ::  cn_dir   !   Root directory for location of core files
        TYPE(FLD_N), DIMENSION(jpfld) ::   slf_i     ! array of namelist informations on the fields to read
        TYPE(FLD_N) ::   sn_wndi, sn_wndj, sn_humi, sn_qsr       ! informations about the fields to be read
        TYPE(FLD_N) ::   sn_qlw , sn_tair, sn_prec, sn_snow      !   "                                 "
        TYPE(FLD_N) ::   sn_tdif                                 !   "                                 "
        NAMELIST/namsbc_core/ cn_dir , ln_taudif, rn_pfac, rn_efac, rn_vfac,  &
!          &                  sn_wndi, sn_wndj  , sn_humi, sn_qsr ,           &
!          &                  sn_qlw , sn_tair  , sn_prec, sn_snow,           &
!          &                  sn_tdif, rn_zqt   ,  rn_zu
        !!---------------------------------------------------------------------
        !
        !                                         ! ====================== !
        IF( kt == nit000 ) THEN                   !  First call kt=nit000  !
***************
*** 216,237 ****
           CALL fld_fill( sf, slf_i, cn_dir, 'sbc_blk_core', 'flux formulation for ocean surface boundary condition', 'namsbc_core' )
           !
           sfx(:,:) = 0._wp                          ! salt flux; zero unless ice is present (computed in limsbc(_2).F90)
- 
-          IF ( ln_kata ) THEN
-             ! katabatik mask (read in NetCDF file)
-             IF ( sbc_kata_alloc() /= 0 ) CALL ctl_stop( 'STOP', 'sbc_kata_alloc: unable to allocate arrays' )
-             !
-             WRITE(cl_katfile,'(a,a)' ) TRIM( cn_dir ), TRIM( sn_kati%clname )
-             CALL iom_open ( cl_katfile, inum )                                       ! open file
-             CALL iom_get  ( inum, jpdom_data, sn_kati%clvar, rmskkatax )             ! read the katax array
-             CALL iom_get  ( inum, jpdom_data, sn_katj%clvar, rmskkatay )             ! read the katay array
-             CALL iom_close( inum )
-             ! replace 0 values by 1  in both arrays.
-             WHERE (ABS(rmskkatax) < 0.000001 )  ; rmskkatax=1.e0 ; rmskkatay=1.e0 ; END WHERE
-             ! check for outliers values
-             IF (MAXVAL(rmskkatax) > 6.00001)   CALL ctl_stop( 'Problem  in kata mask : maxval > 6 ')
-             IF (MAXVAL(rmskkatay) > 6.00001)   CALL ctl_stop( 'Problem  in kata mask : maxval > 6 ')
-          ENDIF
           !
        ENDIF
  
--- 194,199 ----
***************
*** 306,312 ****
        ! local scalars ( place there for vector optimisation purposes)
        zcoef_qsatw = 0.98 * 640380. / rhoa
        
!       zst(:,:) = pst(:,:) + rt0      ! convert SST from  Celsius to Kelvin (and set minimum value far above 0 K)
  
        ! ----------------------------------------------------------------------------- !
        !      0   Wind components and module at T-point relative to the moving ocean   !
--- 268,274 ----
        ! local scalars ( place there for vector optimisation purposes)
        zcoef_qsatw = 0.98 * 640380. / rhoa
        
!       zst(:,:) = pst(:,:) + rt0      ! convert SST from Celcius to Kelvin (and set minimum value far above 0 K)
  
        ! ----------------------------------------------------------------------------- !
        !      0   Wind components and module at T-point relative to the moving ocean   !
***************
*** 368,377 ****
           END DO
        END DO
  
-       IF ( ln_kata )   THEN   ! correction of wind stress at T point only ( no impact on wind speed)
-         zwnd_i(:,:) = rmskkatax(:,:)*zwnd_i(:,:)
-         zwnd_j(:,:) = rmskkatay(:,:)*zwnd_j(:,:)
-       ENDIF
        ! ... add the HF tau contribution to the wind stress module?
        IF( lhftau ) THEN
           taum(:,:) = taum(:,:) + sf(jp_tdif)%fnow(:,:,1)
--- 330,335 ----
***************
*** 514,525 ****
                 ! ... ice stress at I-point
                 utau_ice(ji,jj) = zwnorm_f * zwndi_f
                 vtau_ice(ji,jj) = zwnorm_f * zwndj_f
-                IF (ln_kata ) THEN   ! Apply Katabatic wind enhancement on stress
-                   utau_ice(ji,jj) = utau_ice(ji,jj) * 0.25 * ( rmskkatax(ji-1,jj  ) + rmskkatax(ji,jj  )  &
-                      &                                   + rmskkatax(ji-1,jj-1) + rmskkatax(ji,jj-1) )
-                   vtau_ice(ji,jj) = vtau_ice(ji,jj) * 0.25 * ( rmskkatay(ji-1,jj  ) + rmskkatay(ji,jj  )  &
-                      &                                   + rmskkatay(ji-1,jj-1) + rmskkatay(ji,jj-1) )
-                ENDIF
                 ! ... scalar wind at T-point (fld being at T-point)
                 zwndi_t = sf(jp_wndi)%fnow(ji,jj,1) - rn_vfac * 0.25 * (  u_ice(ji,jj+1) + u_ice(ji+1,jj+1)   &
                    &                                                    + u_ice(ji,jj  ) + u_ice(ji+1,jj  )  )
--- 472,477 ----
***************
*** 546,555 ****
                    &          * ( 0.5 * (sf(jp_wndi)%fnow(ji+1,jj,1) + sf(jp_wndi)%fnow(ji,jj,1) ) - rn_vfac * u_ice(ji,jj) )
                 vtau_ice(ji,jj) = zcoef_wnorm2 * ( wndm_ice(ji,jj+1  ) + wndm_ice(ji,jj) )                          &
                    &          * ( 0.5 * (sf(jp_wndj)%fnow(ji,jj+1,1) + sf(jp_wndj)%fnow(ji,jj,1) ) - rn_vfac * v_ice(ji,jj) )
-                IF (ln_kata ) THEN ! Apply Katabatic wind enhancement on stress
-                   utau_ice(ji,jj) = utau_ice(ji,jj) * 0.5 * ( rmskkatax(ji+1,jj) + rmskkatax(ji,jj) )
-                   vtau_ice(ji,jj) = vtau_ice(ji,jj) * 0.5 * ( rmskkatay(ji,jj+1) + rmskkatay(ji,jj) )
-                ENDIF
              END DO
           END DO
           CALL lbc_lnk( utau_ice, 'U', -1. )
--- 498,503 ----
***************
*** 618,624 ****
                 ! Short Wave (sw)
                 qsr_ice(ji,jj,jl) = zztmp * ( 1. - palb(ji,jj,jl) ) * qsr(ji,jj)
                 ! Long  Wave (lw)
-                !  0.95 is the emissivity 
                 z_qlw(ji,jj,jl) = 0.95 * ( sf(jp_qlw)%fnow(ji,jj,1) - Stef * ptsu(ji,jj,jl) * zst3 ) * tmask(ji,jj,1)
                 ! lw sensitivity
                 z_dqlw(ji,jj,jl) = zcoef_dqlw * zst3                                               
--- 566,571 ----
diff -bic /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/SBC/sbcice_lim.F90 /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/SBC/sbcice_lim.F90
*** /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/SBC/sbcice_lim.F90	Tue Apr  4 14:51:16 2017
--- /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/SBC/sbcice_lim.F90	Fri Feb 24 15:39:23 2017
***************
*** 343,351 ****
        INTEGER  ::   ios                 ! Local integer output status for namelist read
        NAMELIST/namicerun/ jpl, nlay_i, nlay_s, cn_icerst_in, cn_icerst_indir, cn_icerst_out, cn_icerst_outdir,  &
           &                ln_limdyn, rn_amax_n, rn_amax_s, ln_limdiahsb, ln_limdiaout, ln_icectl, iiceprt, jiceprt  
- !{ DRAKKAR
-       CHARACTER(LEN=20) :: cl_no
- !}
        !!-------------------------------------------------------------------
        !                    
        REWIND( numnam_ice_ref )              ! Namelist namicerun in reference namelist : Parameters for ice
--- 343,348 ----
***************
*** 357,373 ****
  902   IF( ios /= 0 )   CALL ctl_nam ( ios , 'namicerun in configuration namelist', lwp )
        IF(lwm) WRITE( numoni, namicerun )
        !
-       ! Add extension (job number to the restart dir. Differ for restart input and restart output
- !{ DRAKKAR modification : NEMO reads restart files :<CN_ICERST_INDIR>.<<nn_no-1>>/<CN_ICERST_IN>-<<nn_no -1 >>_<RANK>.nc
-       WRITE(cl_no,*) nn_no-1 ; cl_no = TRIM(ADJUSTL(cl_no) )
-       cn_icerst_indir=TRIM(cn_icerst_indir)//'.'//TRIM(cl_no)
-       cn_icerst_in= TRIM(cn_icerst_in)//'-'//TRIM(cl_no)
- 
- !  DRAKKAR modification : NEMO write restart files :<CN_ICERST_OUTDIR>.<<nn_no>>/<CN_ICERST_OUT>-<<nn_no >>_<RANK>.nc
-       WRITE(cl_no,*) nn_no   ; cl_no = TRIM(ADJUSTL(cl_no) )
-       cn_icerst_outdir=TRIM(cn_icerst_outdir)//'.'//TRIM(cl_no)
-       cn_icerst_out= TRIM(cn_icerst_out)//'-'//TRIM(cl_no)
- !}
        IF(lwp) THEN                        ! control print
           WRITE(numout,*)
           WRITE(numout,*) 'ice_run : ice share parameters for dynamics/advection/thermo of sea-ice'
--- 354,359 ----
diff -bic /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/SBC/sbcrnf.F90 /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/SBC/sbcrnf.F90
*** /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/SBC/sbcrnf.F90	Tue Apr  4 14:56:58 2017
--- /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/SBC/sbcrnf.F90	Fri Feb 24 15:39:23 2017
***************
*** 70,76 ****
   
     !!----------------------------------------------------------------------
     !! NEMO/OPA 3.3 , NEMO Consortium (2010)
!    !! $Id: sbcrnf.F90 5503 2015-06-29 12:31:29Z cetlod $
     !! Software governed by the CeCILL licence     (NEMOGCM/NEMO_CeCILL.txt)
     !!----------------------------------------------------------------------
  CONTAINS
--- 70,76 ----
   
     !!----------------------------------------------------------------------
     !! NEMO/OPA 3.3 , NEMO Consortium (2010)
!    !! $Id: sbcrnf.F90 6460 2016-04-08 16:00:29Z lovato $
     !! Software governed by the CeCILL licence     (NEMOGCM/NEMO_CeCILL.txt)
     !!----------------------------------------------------------------------
  CONTAINS
***************
*** 137,145 ****
           !                                                           ! use runoffs salinity data
           IF( ln_rnf_sal )   rnf_tsc(:,:,jp_sal) = ( sf_s_rnf(1)%fnow(:,:,1) ) * rnf(:,:) * r1_rau0
           !                                                           ! else use S=0 for runoffs (done one for all in the init)
- !{ DRAKKAR
-          WHERE(rnf(:,:) < 0._wp )  rnf(:,:)=0._wp
- !}
           CALL iom_put( "runoffs", rnf )         ! output runoffs arrays
        ENDIF
        !
--- 137,142 ----
***************
*** 497,503 ****
        !!                rnfmsk_z vertical structure
        !!----------------------------------------------------------------------
        INTEGER            ::   inum        ! temporary integers
!       CHARACTER(len=255) ::   cl_rnfile   ! runoff file name
        !!----------------------------------------------------------------------
        !
        IF(lwp) WRITE(numout,*)
--- 494,500 ----
        !!                rnfmsk_z vertical structure
        !!----------------------------------------------------------------------
        INTEGER            ::   inum        ! temporary integers
!       CHARACTER(len=140) ::   cl_rnfile   ! runoff file name
        !!----------------------------------------------------------------------
        !
        IF(lwp) WRITE(numout,*)
diff -bic /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/SBC/sbcssr.F90 /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/SBC/sbcssr.F90
*** /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/SBC/sbcssr.F90	Tue Apr  4 14:56:58 2017
--- /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/SBC/sbcssr.F90	Fri Feb 24 15:39:23 2017
***************
*** 23,29 ****
     USE lib_mpp        ! distribued memory computing library
     USE lbclnk         ! ocean lateral boundary conditions (or mpp link)
     USE timing         ! Timing
-    USE shapiro         ! used in case of ln_sssr_flt
     USE lib_fortran    ! Fortran utilities (allows no signed zero when 'key_nosignedzero' defined)  
  
     IMPLICIT NONE
--- 23,28 ----
***************
*** 34,42 ****
  
     REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:) ::   erp   !: evaporation damping   [kg/m2/s]
     REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:) ::   qrp   !: heat flux damping        [w/m2]
-    !{ DRAKKAR : local increase of restoring. eg Med Sea in ORCA025
-    REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:) ::   erpcoef  !: multiplicating coef for local change to erp
-    !}
  
     !                                   !!* Namelist namsbc_ssr *
     INTEGER, PUBLIC ::   nn_sstr         ! SST/SSS restoring indicator
--- 33,38 ----
***************
*** 45,69 ****
     REAL(wp)        ::   rn_deds         ! restoring factor on SST and SSS
     LOGICAL         ::   ln_sssr_bnd     ! flag to bound erp term 
     REAL(wp)        ::   rn_sssr_bnd     ! ABS(Max./Min.) value of erp term [mm/day]
-    !{ DRAKKAR 
-    LOGICAL, PUBLIC ::   ln_sssr_flt     ! flag to filter sss for restoring
-    INTEGER, PUBLIC ::   nn_shap_iter    ! number of iteration for shapiro
-    !}
  
     REAL(wp) , ALLOCATABLE, DIMENSION(:) ::   buffer   ! Temporary buffer for exchange
     TYPE(FLD), ALLOCATABLE, DIMENSION(:) ::   sf_sst   ! structure of input SST (file informations, fields read)
     TYPE(FLD), ALLOCATABLE, DIMENSION(:) ::   sf_sss   ! structure of input SSS (file informations, fields read)
-    !{ DRAKKAR : limit sss restoring in the coastal area
-    LOGICAL         :: ln_sssr_msk
-    TYPE(FLD_N)     :: sn_coast
-    REAL(wp), PUBLIC, ALLOCATABLE, DIMENSION(:,:) :: distcoast   ! use to read the distance and then for weight purpose
- 
-    REAL(wp)        :: rn_dist      ! (km) decaying lenght scale for SSS restoring near the coast
-    !}
  
     !!----------------------------------------------------------------------
     !! NEMO/OPA 4.0 , NEMO Consortium (2011)
!    !! $Id: sbcssr.F90 4990 2014-12-15 16:42:49Z timgraham $
     !! Software governed by the CeCILL licence     (NEMOGCM/NEMO_CeCILL.txt)
     !!----------------------------------------------------------------------
  CONTAINS
--- 41,54 ----
     REAL(wp)        ::   rn_deds         ! restoring factor on SST and SSS
     LOGICAL         ::   ln_sssr_bnd     ! flag to bound erp term 
     REAL(wp)        ::   rn_sssr_bnd     ! ABS(Max./Min.) value of erp term [mm/day]
  
     REAL(wp) , ALLOCATABLE, DIMENSION(:) ::   buffer   ! Temporary buffer for exchange
     TYPE(FLD), ALLOCATABLE, DIMENSION(:) ::   sf_sst   ! structure of input SST (file informations, fields read)
     TYPE(FLD), ALLOCATABLE, DIMENSION(:) ::   sf_sss   ! structure of input SSS (file informations, fields read)
  
     !!----------------------------------------------------------------------
     !! NEMO/OPA 4.0 , NEMO Consortium (2011)
!    !! $Id: sbcssr.F90 6140 2015-12-21 11:35:23Z timgraham $
     !! Software governed by the CeCILL licence     (NEMOGCM/NEMO_CeCILL.txt)
     !!----------------------------------------------------------------------
  CONTAINS
***************
*** 90,99 ****
        REAL(wp) ::   zsrp     ! local scalar for unit conversion of rn_deds factor
        REAL(wp) ::   zerp_bnd ! local scalar for unit conversion of rn_epr_max factor
        INTEGER  ::   ierror   ! return error code
-       !{ DRAKKAR 
-       REAL(wp) , DIMENSION (jpi,jpj) :: zsss_m ! temporary array
-       REAL(wp) , DIMENSION (jpi,jpj) :: zsst_m ! temporary array
-       !}
        !!
        CHARACTER(len=100) ::  cn_dir          ! Root directory for location of ssr files
        TYPE(FLD_N) ::   sn_sst, sn_sss        ! informations about the fields to be read
--- 75,80 ----
***************
*** 126,132 ****
                 DO jj = 1, jpj
                    DO ji = 1, jpi
                       zerp = zsrp * ( 1. - 2.*rnfmsk(ji,jj) )   &      ! No damping in vicinity of river mouths
!                         &        * ( sss_m(ji,jj) - sf_sss(1)%fnow(ji,jj,1) ) * erpcoef(ji,jj)
                       sfx(ji,jj) = sfx(ji,jj) + zerp                 ! salt flux
                       erp(ji,jj) = zerp / MAX( sss_m(ji,jj), 1.e-20 ) ! converted into an equivalent volume flux (diagnostic only)
                    END DO
--- 107,113 ----
                 DO jj = 1, jpj
                    DO ji = 1, jpi
                       zerp = zsrp * ( 1. - 2.*rnfmsk(ji,jj) )   &      ! No damping in vicinity of river mouths
!                         &        * ( sss_m(ji,jj) - sf_sss(1)%fnow(ji,jj,1) ) 
                       sfx(ji,jj) = sfx(ji,jj) + zerp                 ! salt flux
                       erp(ji,jj) = zerp / MAX( sss_m(ji,jj), 1.e-20 ) ! converted into an equivalent volume flux (diagnostic only)
                    END DO
***************
*** 136,163 ****
              ELSEIF( nn_sssr == 2 ) THEN                               !* Salinity damping term (volume flux (emp) and associated heat flux (qns)
                 zsrp = rn_deds / rday                                  ! from [mm/day] to [kg/m2/s]
                 zerp_bnd = rn_sssr_bnd / rday                          !       -              -    
-                !{ DRAKKAR : using filtered sss for restoring 
-                IF (ln_sssr_flt ) THEN
-                   CALL Shapiro_1D ( sss_m(:,:), nn_shap_iter, 'ORCA_GLOB', zsss_m )
-                   CALL Shapiro_1D ( sst_m(:,:), nn_shap_iter, 'ORCA_GLOB', zsst_m )
-                   zsss_m = zsss_m * tmask(:,:,1)
-                   zsst_m = zsst_m * tmask(:,:,1)
-                ELSE
-                   zsss_m = sss_m * tmask(:,:,1)
-                   zsst_m = sst_m * tmask(:,:,1)
-                ENDIF
-                !}
                 DO jj = 1, jpj
                    DO ji = 1, jpi                            
                       zerp = zsrp * ( 1. - 2.*rnfmsk(ji,jj) )   &      ! No damping in vicinity of river mouths
!                         &        * ( zsss_m(ji,jj) - sf_sss(1)%fnow(ji,jj,1) )   &
!                         &        / MAX(  zsss_m(ji,jj), 1.e-20   )               &
!                           &        * erpcoef(ji,jj)
                       IF( ln_sssr_bnd )   zerp = SIGN( 1., zerp ) * MIN( zerp_bnd, ABS(zerp) )
!                      IF( ln_sssr_msk )   zerp = zerp * distcoast(ji,jj) ! multiply by weigh to fade zerp out near the coast
!                      emp (ji,jj) = emp (ji,jj) + zerp
!                      qns(ji,jj) = qns(ji,jj) - zerp * rcp * zsst_m(ji,jj)
!                      erp (ji,jj) = zerp
                    END DO
                 END DO
                 CALL iom_put( "erp", erp )                             ! freshwater flux damping
--- 117,131 ----
              ELSEIF( nn_sssr == 2 ) THEN                               !* Salinity damping term (volume flux (emp) and associated heat flux (qns)
                 zsrp = rn_deds / rday                                  ! from [mm/day] to [kg/m2/s]
                 zerp_bnd = rn_sssr_bnd / rday                          !       -              -    
                 DO jj = 1, jpj
                    DO ji = 1, jpi                            
                       zerp = zsrp * ( 1. - 2.*rnfmsk(ji,jj) )   &      ! No damping in vicinity of river mouths
!                         &        * ( sss_m(ji,jj) - sf_sss(1)%fnow(ji,jj,1) )   &
!                         &        / MAX(  sss_m(ji,jj), 1.e-20   )
                       IF( ln_sssr_bnd )   zerp = SIGN( 1., zerp ) * MIN( zerp_bnd, ABS(zerp) )
!                      emp(ji,jj) = emp (ji,jj) + zerp
!                      qns(ji,jj) = qns(ji,jj) - zerp * rcp * sst_m(ji,jj)
!                      erp(ji,jj) = zerp
                    END DO
                 END DO
                 CALL iom_put( "erp", erp )                             ! freshwater flux damping
***************
*** 188,202 ****
        REAL(wp) ::   zerp_bnd ! local scalar for unit conversion of rn_epr_max factor
        INTEGER  ::   ierror   ! return error code
        !!
-       !{ DRAKKAR 
-       INTEGER  ::   ii0, ii1, ii2, ij0, ij1, ij2, inum
-       REAL(wp) :: zalph
-       !}
        CHARACTER(len=100) ::  cn_dir          ! Root directory for location of ssr files
-       CHARACTER(LEN=100) ::  cl_coastfile
        TYPE(FLD_N) ::   sn_sst, sn_sss        ! informations about the fields to be read
!       NAMELIST/namsbc_ssr/ cn_dir, nn_sstr, nn_sssr, rn_dqdt, rn_deds, sn_sst, sn_sss
!       NAMELIST/namsbc_ssr/ ln_sssr_bnd, rn_sssr_bnd, ln_sssr_flt, ln_sssr_msk, sn_coast, rn_dist, nn_shap_iter
        INTEGER     ::  ios
        !!----------------------------------------------------------------------
        !
--- 156,164 ----
        REAL(wp) ::   zerp_bnd ! local scalar for unit conversion of rn_epr_max factor
        INTEGER  ::   ierror   ! return error code
        !!
        CHARACTER(len=100) ::  cn_dir          ! Root directory for location of ssr files
        TYPE(FLD_N) ::   sn_sst, sn_sss        ! informations about the fields to be read
!       NAMELIST/namsbc_ssr/ cn_dir, nn_sstr, nn_sssr, rn_dqdt, rn_deds, sn_sst, sn_sss, ln_sssr_bnd, rn_sssr_bnd
        INTEGER     ::  ios
        !!----------------------------------------------------------------------
        !
***************
*** 222,237 ****
           WRITE(numout,*) '      dE/dS (restoring magnitude on SST)     rn_deds     = ', rn_deds, ' mm/day'
           WRITE(numout,*) '      flag to bound erp term                 ln_sssr_bnd = ', ln_sssr_bnd
           WRITE(numout,*) '      ABS(Max./Min.) erp threshold           rn_sssr_bnd = ', rn_sssr_bnd, ' mm/day'
-          WRITE(numout,*) '      Filtering of sss for restoring         ln_sssr_flt = ', ln_sssr_flt 
-          IF ( ln_sssr_flt ) THEN
-             WRITE(numout,*) '      Number of used Shapiro filter           nn_shap_iter = ', nn_shap_iter
-          ENDIF
-          WRITE(numout,*) '      Limit sss restoring near the coast     ln_sssr_msk = ', ln_sssr_msk
-          IF ( ln_sssr_msk ) WRITE(numout,*) '      Decaying lenght scale from the coast   rn_dist     = ', rn_dist, ' km'
        ENDIF
        !
        !                            !* Allocate erp and qrp array
!       ALLOCATE( qrp(jpi,jpj), erp(jpi,jpj), erpcoef(jpi,jpj),STAT=ierror )
        IF( ierror > 0 )   CALL ctl_stop( 'STOP', 'sbc_ssr: unable to allocate erp and qrp array' )
        !
        IF( nn_sstr == 1 ) THEN      !* set sf_sst structure & allocate arrays
--- 184,193 ----
           WRITE(numout,*) '      dE/dS (restoring magnitude on SST)     rn_deds     = ', rn_deds, ' mm/day'
           WRITE(numout,*) '      flag to bound erp term                 ln_sssr_bnd = ', ln_sssr_bnd
           WRITE(numout,*) '      ABS(Max./Min.) erp threshold           rn_sssr_bnd = ', rn_sssr_bnd, ' mm/day'
        ENDIF
        !
        !                            !* Allocate erp and qrp array
!       ALLOCATE( qrp(jpi,jpj), erp(jpi,jpj), STAT=ierror )
        IF( ierror > 0 )   CALL ctl_stop( 'STOP', 'sbc_ssr: unable to allocate erp and qrp array' )
        !
        IF( nn_sstr == 1 ) THEN      !* set sf_sst structure & allocate arrays
***************
*** 260,305 ****
           IF( sf_sss(1)%ln_tint )   ALLOCATE( sf_sss(1)%fdta(jpi,jpj,1,2), STAT=ierror )
           IF( ierror > 0 )   CALL ctl_stop( 'STOP', 'sbc_ssr: unable to allocate sf_sss data array' )
           !
-          ! if masking of coastal area is used
-          IF ( ln_sssr_msk ) THEN
-             ALLOCATE( distcoast(jpi,jpj),STAT=ierror )  
-             IF( ierror > 0 )   CALL ctl_stop( 'STOP', 'sbc_ssr: unable to allocate erp and qrp array' )
-             WRITE(cl_coastfile,'(a,a)' ) TRIM( cn_dir ), TRIM( sn_coast%clname )
-             CALL iom_open ( cl_coastfile, inum )                          ! open file
-             CALL iom_get  ( inum, jpdom_data, sn_coast%clvar, distcoast ) ! read tcoast  in m
-             CALL iom_close( inum )
-             ! transform distcoast to weight 
-             rn_dist=rn_dist*1000.  ! tranform rn_dist to m
-             distcoast(:,:)=0.5*(tanh(3.*(distcoast(:,:)*distcoast(:,:)/rn_dist/rn_dist - 1 )) + 1 )
-          ENDIF
        ENDIF
        !
-       ! DRAKKAR { initialize erpcoef to increase erp in the med sea
-       erpcoef(:,:) = 1._wp
-       IF( cp_cfg == "orca" .AND. jp_cfg == 25 ) THEN  ! ORCA R025 configuration
-          !! add extra SSS restoring in the Red Sea
-          ii0= 1280       ;  ii1 = 1325
-          ij0= 560        ;  ij1 = 625
-          erpcoef( mi0(ii0):mi1(ii1) , mj0(ij0):mj1(ij1)) =  5.0
- 
-          !! add extra SSS restoring in the Med sea (x3) decreasing to 1 into the alboran sea
-          ii1 = 1145  ; ii2 =  1330
-          ij1 = 626   ; ij2 =  726
-          erpcoef( mi0(ii1):mi1(ii2) , mj0(ij1):mj1(ij2)) = 3.0
- 
-          !! decrease in alboran sea (along i )
-          ii0= 1128       ;  ii1 = 1144
-          ij0= 645        ;  ij1 = 670
-          DO jj=mj0(ij0), mj1(ij1)
-             DO ji= mi0(ii0), mi1(ii1)
-                !zalph=( alph1 -alph0 )* (I - ii0 )/(ii1-ii0) + alph0
-                !zalph=( 3.    - 1.   )* (I - ii0 )/(ii1-ii0) + 1.
-                zalph=     2.   *    (mig(ji)-ii0)/(ii1-ii0) + 1.
-                erpcoef(ji,jj) = zalph 
-             ENDDO
-          ENDDO
-       ENDIF
-       !            }
        !                            !* Initialize qrp and erp if no restoring 
        IF( nn_sstr /= 1                   )   qrp(:,:) = 0._wp
        IF( nn_sssr /= 1 .OR. nn_sssr /= 2 )   erp(:,:) = 0._wp
--- 216,223 ----
Only in /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/SBC: shapiro.F90
Only in /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/STO: .gitkeep
diff -bic /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/TRA/trabbl.F90 /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/TRA/trabbl.F90
*** /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/TRA/trabbl.F90	Tue Apr  4 14:51:16 2017
--- /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/TRA/trabbl.F90	Fri Feb 24 15:39:23 2017
***************
*** 57,65 ****
     !                                            !  =2 :     -      -  using utr_bbl proportional to grad(rho)
     REAL(wp), PUBLIC ::   rn_ahtbbl   !: along slope bbl diffusive coefficient [m2/s]
     REAL(wp), PUBLIC ::   rn_gambbl   !: lateral coeff. for bottom boundary layer scheme [s]
! !{ DRAKKAR
!    LOGICAL , PUBLIC ::   ln_kriteria !: flag to use k-level instead of depth for bbl threshold
! !}
     LOGICAL , PUBLIC ::   l_bbl                  !: flag to compute bbl diffu. flux coef and transport
  
     REAL(wp), ALLOCATABLE, SAVE, DIMENSION(:,:), PUBLIC ::   utr_bbl  , vtr_bbl   ! u- (v-) transport in the bottom boundary layer
--- 57,63 ----
     !                                            !  =2 :     -      -  using utr_bbl proportional to grad(rho)
     REAL(wp), PUBLIC ::   rn_ahtbbl   !: along slope bbl diffusive coefficient [m2/s]
     REAL(wp), PUBLIC ::   rn_gambbl   !: lateral coeff. for bottom boundary layer scheme [s]
! 
     LOGICAL , PUBLIC ::   l_bbl       !: flag to compute bbl diffu. flux coef and transport
  
     REAL(wp), ALLOCATABLE, SAVE, DIMENSION(:,:), PUBLIC ::   utr_bbl  , vtr_bbl   ! u- (v-) transport in the bottom boundary layer
***************
*** 74,80 ****
  #  include "vectopt_loop_substitute.h90"
     !!----------------------------------------------------------------------
     !! NEMO/OPA 3.3 , NEMO Consortium (2010)
!    !! $Id: trabbl.F90 4990 2014-12-15 16:42:49Z timgraham $
     !! Software governed by the CeCILL licence     (NEMOGCM/NEMO_CeCILL.txt)
     !!----------------------------------------------------------------------
  CONTAINS
--- 72,78 ----
  #  include "vectopt_loop_substitute.h90"
     !!----------------------------------------------------------------------
     !! NEMO/OPA 3.3 , NEMO Consortium (2010)
!    !! $Id: trabbl.F90 6140 2015-12-21 11:35:23Z timgraham $
     !! Software governed by the CeCILL licence     (NEMOGCM/NEMO_CeCILL.txt)
     !!----------------------------------------------------------------------
  CONTAINS
***************
*** 86,92 ****
        ALLOCATE( utr_bbl  (jpi,jpj) , ahu_bbl  (jpi,jpj) , mbku_d  (jpi,jpj) , mgrhu(jpi,jpj) ,     &
           &      vtr_bbl  (jpi,jpj) , ahv_bbl  (jpi,jpj) , mbkv_d  (jpi,jpj) , mgrhv(jpi,jpj) ,     &
           &      ahu_bbl_0(jpi,jpj) , ahv_bbl_0(jpi,jpj) ,                                          &
!          &      e3u_bbl_0(jpi,jpj) , e3v_bbl_0(jpi,jpj) , STAT= tra_bbl_alloc                )
           !
        IF( lk_mpp            )   CALL mpp_sum ( tra_bbl_alloc )
        IF( tra_bbl_alloc > 0 )   CALL ctl_warn('tra_bbl_alloc: allocation of arrays failed.')
--- 84,90 ----
        ALLOCATE( utr_bbl  (jpi,jpj) , ahu_bbl  (jpi,jpj) , mbku_d  (jpi,jpj) , mgrhu(jpi,jpj) ,     &
           &      vtr_bbl  (jpi,jpj) , ahv_bbl  (jpi,jpj) , mbkv_d  (jpi,jpj) , mgrhv(jpi,jpj) ,     &
           &      ahu_bbl_0(jpi,jpj) , ahv_bbl_0(jpi,jpj) ,                                          &
!          &      e3u_bbl_0(jpi,jpj) , e3v_bbl_0(jpi,jpj) ,                                      STAT=tra_bbl_alloc )
           !
        IF( lk_mpp            )   CALL mpp_sum ( tra_bbl_alloc )
        IF( tra_bbl_alloc > 0 )   CALL ctl_warn('tra_bbl_alloc: allocation of arrays failed.')
***************
*** 499,506 ****
        INTEGER ::   ii0, ii1, ij0, ij1   ! local integer
        INTEGER ::   ios                  !   -      -
        REAL(wp), POINTER, DIMENSION(:,:) :: zmbk
!       !!
!       NAMELIST/nambbl/ nn_bbl_ldf, nn_bbl_adv, rn_ahtbbl, rn_gambbl, ln_kriteria
        !!----------------------------------------------------------------------
        !
        IF( nn_timing == 1 )  CALL timing_start( 'tra_bbl_init')
--- 497,504 ----
        INTEGER ::   ii0, ii1, ij0, ij1   ! local integer
        INTEGER ::   ios                  !   -      -
        REAL(wp), POINTER, DIMENSION(:,:) :: zmbk
!       !
!       NAMELIST/nambbl/ nn_bbl_ldf, nn_bbl_adv, rn_ahtbbl, rn_gambbl
        !!----------------------------------------------------------------------
        !
        IF( nn_timing == 1 )  CALL timing_start( 'tra_bbl_init')
***************
*** 525,539 ****
           WRITE(numout,*) '          advective bbl (=1/2) or not (=0)    nn_bbl_adv = ', nn_bbl_adv
           WRITE(numout,*) '          diffusive bbl coefficient           rn_ahtbbl  = ', rn_ahtbbl, ' m2/s'
           WRITE(numout,*) '          advective bbl coefficient           rn_gambbl  = ', rn_gambbl, ' s'
-          IF( nn_bbl_adv == 1 )    WRITE(numout,*) '       * Advective BBL using upper velocity'
-          IF( nn_bbl_adv == 2 )    WRITE(numout,*) '       * Advective BBL using velocity = F( delta rho)'
        ENDIF
  
        !                              ! allocate trabbl arrays
        IF( tra_bbl_alloc() /= 0 )   CALL ctl_stop( 'STOP', 'tra_bbl_init : unable to allocate arrays' )
       
! !JMM no more in 3.6 ???
!       IF( .NOT. ln_EOS80 )   CALL ctl_stop ( ' bbl parameterisation requires eos = 0. We stop.' )
  
        !                             !* vertical index of  "deep" bottom u- and v-points
        DO jj = 1, jpjm1                    ! (the "shelf" bottom k-indices are mbku and mbkv)
--- 523,535 ----
           WRITE(numout,*) '          advective bbl (=1/2) or not (=0)    nn_bbl_adv = ', nn_bbl_adv
           WRITE(numout,*) '          diffusive bbl coefficient           rn_ahtbbl  = ', rn_ahtbbl, ' m2/s'
           WRITE(numout,*) '          advective bbl coefficient           rn_gambbl  = ', rn_gambbl, ' s'
        ENDIF
  
        !                              ! allocate trabbl arrays
        IF( tra_bbl_alloc() /= 0 )   CALL ctl_stop( 'STOP', 'tra_bbl_init : unable to allocate arrays' )
  
!       IF( nn_bbl_adv == 1 )    WRITE(numout,*) '       * Advective BBL using upper velocity'
!       IF( nn_bbl_adv == 2 )    WRITE(numout,*) '       * Advective BBL using velocity = F( delta rho)'
  
        !                             !* vertical index of  "deep" bottom u- and v-points
        DO jj = 1, jpjm1                    ! (the "shelf" bottom k-indices are mbku and mbkv)
***************
*** 542,548 ****
              mbkv_d(ji,jj) = MAX(  mbkt(ji  ,jj+1) , mbkt(ji,jj)  )
           END DO
        END DO
!       ! convert into REAL to use lbc_lnk ; impose a min value of 1 as a zero can be set in lbclnk
        CALL wrk_alloc( jpi, jpj, zmbk )
        zmbk(:,:) = REAL( mbku_d(:,:), wp )   ;   CALL lbc_lnk(zmbk,'U',1.)   ;   mbku_d(:,:) = MAX( INT( zmbk(:,:) ), 1 )
        zmbk(:,:) = REAL( mbkv_d(:,:), wp )   ;   CALL lbc_lnk(zmbk,'V',1.)   ;   mbkv_d(:,:) = MAX( INT( zmbk(:,:) ), 1 )
--- 538,544 ----
              mbkv_d(ji,jj) = MAX(  mbkt(ji  ,jj+1) , mbkt(ji,jj)  )
           END DO
        END DO
!       ! converte into REAL to use lbc_lnk ; impose a min value of 1 as a zero can be set in lbclnk
        CALL wrk_alloc( jpi, jpj, zmbk )
        zmbk(:,:) = REAL( mbku_d(:,:), wp )   ;   CALL lbc_lnk(zmbk,'U',1.)   ;   mbku_d(:,:) = MAX( INT( zmbk(:,:) ), 1 )
        zmbk(:,:) = REAL( mbkv_d(:,:), wp )   ;   CALL lbc_lnk(zmbk,'V',1.)   ;   mbkv_d(:,:) = MAX( INT( zmbk(:,:) ), 1 )
***************
*** 552,571 ****
        mgrhu(jpi,:) = 0   ;   mgrhu(:,jpj) = 0   ;   mgrhv(jpi,:) = 0   ;   mgrhv(:,jpj) = 0
        DO jj = 1, jpjm1
           DO ji = 1, jpim1
- ! { DRAKKAR : ln_kriteria
-             IF ( ln_kriteria ) THEN
-               mgrhu(ji,jj) = mbkt(ji+1,jj) - mbkt(ji,jj)
-               mgrhv(ji,jj) = mbkt(ji,jj+1) - mbkt(ji,jj)
-               IF ( mgrhu(ji,jj) /= 0 ) THEN 
-                   mgrhu(ji,jj) = INT(  SIGN( 1.e0, FLOAT(mbkt(ji+1,jj) - mbkt(ji,jj)) )) 
-               ENDIF
-               IF ( mgrhv(ji,jj) /= 0 ) THEN 
-                   mgrhv(ji,jj) = INT(  SIGN( 1.e0, FLOAT(mbkt(ji,jj+1) - mbkt(ji,jj)) ))  
-               ENDIF
-             ELSE
              mgrhu(ji,jj) = INT(  SIGN( 1.e0, gdept_0(ji+1,jj,mbkt(ji+1,jj)) - gdept_0(ji,jj,mbkt(ji,jj)) )  )
              mgrhv(ji,jj) = INT(  SIGN( 1.e0, gdept_0(ji,jj+1,mbkt(ji,jj+1)) - gdept_0(ji,jj,mbkt(ji,jj)) )  )
-             ENDIF
           END DO
        END DO
  
--- 548,555 ----
diff -bic /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/TRA/tradmp.F90 /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/TRA/tradmp.F90
*** /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/TRA/tradmp.F90	Tue Apr  4 14:51:16 2017
--- /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/TRA/tradmp.F90	Fri Feb 24 15:39:23 2017
***************
*** 20,26 ****
     !!   tra_dmp_alloc : allocate tradmp arrays
     !!   tra_dmp       : update the tracer trend with the internal damping
     !!   tra_dmp_init  : initialization, namlist read, parameters control
-    !!   dtacof        : restoring coefficient for global domain
     !!----------------------------------------------------------------------
     USE oce            ! ocean: variables
     USE dom_oce        ! ocean: domain variables
--- 20,25 ----
***************
*** 44,73 ****
  
     PUBLIC   tra_dmp        ! called by step.F90
     PUBLIC   tra_dmp_init   ! called by nemogcm.F90
-    PUBLIC   dtacof         ! called by tradmp.F90, trcdmp.F90 and dyndmp.F90
  
     !                                           !!* Namelist namtra_dmp : T & S newtonian damping *
     LOGICAL            , PUBLIC ::   ln_tradmp   !: internal damping flag
     INTEGER            , PUBLIC ::   nn_zdmp     !: = 0/1/2 flag for damping in the mixed layer
     CHARACTER(LEN=200) , PUBLIC ::   cn_resto    !: name of netcdf file containing restoration coefficient field
     !
- 
- !{ DRAKKAR
-    INTEGER , PUBLIC ::   nn_hdmp     ! > 0 standard NEMO CODE
-                                      ! = -2 = DRAKKAR customization
-    INTEGER , PUBLIC ::   nn_file     ! = 1 create a damping.coeff NetCDF file 
-    LOGICAL  ::   ln_dmpmask          !  flag for using mask_dmp file
-    INTEGER, SAVE   ::   nk200        !  vertical index for depth > 200 m in ORCA 2
-    REAL(wp) ::   rn_timsk            !  restoring time scale used with mask_dmp       [days] 
- !}
- 
     REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:,:) ::   resto    !: restoring coeff. on T and S (s-1)
  
     !! * Substitutions
  #  include "vectopt_loop_substitute.h90"
     !!----------------------------------------------------------------------
     !! NEMO/OPA 3.3 , NEMO Consortium (2010)
!    !! $Id: tradmp.F90 4624 2014-04-28 12:09:03Z acc $ 
     !! Software governed by the CeCILL licence     (NEMOGCM/NEMO_CeCILL.txt)
     !!----------------------------------------------------------------------
  CONTAINS
--- 43,61 ----
  
     PUBLIC   tra_dmp        ! called by step.F90
     PUBLIC   tra_dmp_init   ! called by nemogcm.F90
  
     !                                           !!* Namelist namtra_dmp : T & S newtonian damping *
     LOGICAL            , PUBLIC ::   ln_tradmp   !: internal damping flag
     INTEGER            , PUBLIC ::   nn_zdmp     !: = 0/1/2 flag for damping in the mixed layer
     CHARACTER(LEN=200) , PUBLIC ::   cn_resto    !: name of netcdf file containing restoration coefficient field
     !
     REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:,:) ::   resto    !: restoring coeff. on T and S (s-1)
  
     !! * Substitutions
  #  include "vectopt_loop_substitute.h90"
     !!----------------------------------------------------------------------
     !! NEMO/OPA 3.3 , NEMO Consortium (2010)
!    !! $Id: tradmp.F90 6140 2015-12-21 11:35:23Z timgraham $ 
     !! Software governed by the CeCILL licence     (NEMOGCM/NEMO_CeCILL.txt)
     !!----------------------------------------------------------------------
  CONTAINS
***************
*** 186,197 ****
        !!
        !! ** Method  :   read the namtra_dmp namelist and check the parameters
        !!----------------------------------------------------------------------
        NAMELIST/namtra_dmp/ ln_tradmp, nn_zdmp, cn_resto
-       INTEGER ::  ios         ! Local integer for output status of namelist read
- !{DRAKKAR
-       INTEGER :: jk ! dummy loop index
-       NAMELIST/namtra_dmp/ nn_hdmp , nn_file, ln_dmpmask, rn_timsk
- !}
        !!----------------------------------------------------------------------
        !
        REWIND( numnam_ref )   ! Namelist namtra_dmp in reference namelist : T & S relaxation
--- 174,182 ----
        !!
        !! ** Method  :   read the namtra_dmp namelist and check the parameters
        !!----------------------------------------------------------------------
+       INTEGER ::   ios, imask   ! local integers 
+       !
        NAMELIST/namtra_dmp/ ln_tradmp, nn_zdmp, cn_resto
        !!----------------------------------------------------------------------
        !
        REWIND( numnam_ref )   ! Namelist namtra_dmp in reference namelist : T & S relaxation
***************
*** 211,222 ****
           WRITE(numout,*) '      Apply relaxation   or not       ln_tradmp = ', ln_tradmp
           WRITE(numout,*) '      mixed layer damping option      nn_zdmp   = ', nn_zdmp
           WRITE(numout,*) '      Damping file name               cn_resto  = ', cn_resto
- !{DRAKKAR
-          WRITE(numout,*) '      T and S damping option          nn_hdmp   = ', nn_hdmp
-          WRITE(numout,*) '      use a mask_dmp file (T/F)      ln_dmpmask = ', ln_dmpmask
-          WRITE(numout,*) '      time scale (mask_dmp)            rn_timsk = ', rn_timsk
-          WRITE(numout,*) '      create a damping.coeff file     nn_file   = ', nn_file
- !}
           WRITE(numout,*)
        ENDIF
        !
--- 196,201 ----
***************
*** 224,234 ****
           !                          ! Allocate arrays
           IF( tra_dmp_alloc() /= 0 )   CALL ctl_stop( 'STOP', 'tra_dmp_init: unable to allocate arrays' )
           !
-          SELECT CASE ( nn_hdmp )
-          CASE (  -2  )   ;   IF(lwp) WRITE(numout,*) '   Drakkar customization '
-          CASE DEFAULT
-                              IF(lwp) WRITE(numout,*) '   Standard Nemo relaxation '
-          END SELECT
           SELECT CASE (nn_zdmp)      ! Check values of nn_zdmp
           CASE ( 0 )   ;   IF(lwp) WRITE(numout,*) '   tracer damping as specified by mask'
           CASE ( 1 )   ;   IF(lwp) WRITE(numout,*) '   no tracer damping in the mixing layer (kz > 5 cm2/s)'
--- 203,208 ----
***************
*** 236,547 ****
           CASE DEFAULT
              CALL ctl_stop('tra_dmp_init : wrong value of nn_zdmp')
           END SELECT
! 
!          !TG: Initialisation of dtatsd - Would it be better to have dmpdta routine
!          !so can damp to something other than intitial conditions files?
!          ! JMM : DRAKKAR version is doing so !
           IF( .NOT.ln_tsd_tradmp ) THEN
!             CALL ctl_warn( 'tra_dmp_init: read T-S data not initialized, we force ln_tsd_tradmp=T' )
              CALL dta_tsd_init( ld_tradmp=ln_tradmp )        ! forces the initialisation of T-S data
           ENDIF
! 
!          CALL dtacof( nn_hdmp, nn_file, 'TRA', resto )
! 
!          !
!          !{ DRAKKAR : for ORCA  damping (used only for ORCA 2 so far ) 
!          IF ( cp_cfg == 'orca' ) THEN
!            nk200 = jpk
!            DO jk = jpk, 1, -1
!             IF ( gdept_1d(jk) > 200 ) THEN 
!               nk200 = jk
!             ELSE
!               EXIT
!             ENDIF
!            ENDDO
!          ENDIF
!        
!       ENDIF
!       !
!    END SUBROUTINE tra_dmp_init
! 
! 
!    SUBROUTINE dtacof( kn_hdmp, kn_file, cdtype , presto )
!       !!----------------------------------------------------------------------
!       !!                  ***  ROUTINE dtacof  ***
!       !!
!       !! ** Purpose :   Compute the damping coefficient
!       !!
!       !! ** Method  :   Arrays defining the damping are computed for each grid
!       !!                point for temperature and salinity (resto)
!       !!                Damping depends on distance to coast, depth and latitude
!       !!
!       !! ** Action  : - resto, the damping coeff. for T and S
!       !!----------------------------------------------------------------------
!       USE ioipsl
!       !!
!       INTEGER                         , INTENT(in   )  ::  kn_hdmp    ! damping option
!       INTEGER                         , INTENT(in   )  ::  kn_file    ! save the damping coef on a file or not
!       CHARACTER(len=3)                , INTENT(in   )  ::  cdtype     ! =TRA, TRC or DYN (tracer/dynamics indicator)
!       REAL(wp), DIMENSION(jpi,jpj,jpk), INTENT(inout)  ::  presto     ! restoring coeff. (s-1)
!       !
!       INTEGER  ::   ji, jj, jk                  ! dummy loop indices
!       INTEGER  ::   ii0, ii1, ij0, ij1          ! local integers
!       INTEGER  ::   imask        ! File handle 
! !{DRAKKAR
!       INTEGER  ::   jrelax                      ! width of buffer zone
!       INTEGER  ::   inum                        ! Logical unit for reading dmp_mask
!       REAL(wp) ::   ztrelax, ztvanish           ! restoring time scale
!       REAL(wp) ::   zlon1, zlon2                ! Longitude min and max for patch
!       REAL(wp) ::   zbw, zd1, zd2               ! Band width, depth limit
!       REAL(wp) ::   zv1, zv2                    ! local scalars
! !}
!       REAL(wp) ::   zinfl, zlon                 ! local scalars
!       REAL(wp) ::   zlat, zlat0, zlat1, zlat2   !   -      -
!       REAL(wp) ::   zsdmp, zbdmp                !   -      -
!       CHARACTER(len=80)                   :: cfile
!       REAL(wp), POINTER, DIMENSION(:,:,:) :: zdct 
!       !!----------------------------------------------------------------------
!       !
!       IF( nn_timing == 1 )  CALL timing_start('dtacof')
!       !
!       CALL wrk_alloc( jpi, jpj, jpk, zdct )
! 
!       presto(:,:,:) = 0._wp
!       !
!       IF( kn_hdmp > 0 ) THEN      ! use standard NEMO code (read from file )
! 
!          !Read in mask from file
           CALL iom_open ( cn_resto, imask)
!          CALL iom_get  ( imask, jpdom_autoglo, 'resto', resto)
           CALL iom_close( imask )
- 
- !{ DRAKKAR
-       ELSE IF ( nn_hdmp == -2 ) THEN  !
-        !--------------------------------------------------------------------------------------------------------------
-        ! 3D restoring in semi enclosed seas :
-        ! Black Sea :
-        ! Lonmin     ! Lonmax       ! Latmin        ! Latmax       ! Band      ! min relax time   !
-        !  deg E     ! deg E        !  deg N        ! Deg N        !  deg      !   days           !
-        zlon1 = 27.4 ; zlon2 = 42.0 ;  zlat1 = 41.0 ; zlat2 = 47.5 ; zbw = 0.  ; ztrelax = 180. 
- 
-        CALL resto_patch ( zlon1, zlon2, zlat1, zlat2, zbw, ztrelax , presto )
- 
-        ! Red Sea
-        ! Lonmin     ! Lonmax       ! Latmin        ! Latmax       ! Band      ! min relax time   !
-        !  deg E     ! deg E        !  deg N        ! Deg N        !  deg      !   days           !
-        zlon1 = 29.4 ; zlon2 = 43.6 ;  zlat1 = 12.9 ; zlat2 = 30.3 ; zbw = 0.  ; ztrelax = 180. 
- 
-        CALL resto_patch ( zlon1, zlon2, zlat1, zlat2, zbw, ztrelax , presto )
- 
-        ! Persian Gulf
-        ! Lonmin     ! Lonmax       ! Latmin        ! Latmax       ! Band      ! min relax time   !
-        !  deg E     ! deg E        !  deg N        ! Deg N        !  deg      !   days           !
-        zlon1 = 46.5 ; zlon2 = 57.0 ;  zlat1 = 23.0 ; zlat2 = 31.5 ; zbw = 1.  ; ztrelax = 180. 
- 
-        CALL resto_patch ( zlon1, zlon2, zlat1, zlat2, zbw, ztrelax , presto )
-       
-        ! ---------------------------------------------------------------------------------------------------------------
-        ! 3D overflow restoring 
-        ! Gibraltar (limited to 600-1300 m depth range )
-        ! Lonmin     ! Lonmax       ! Latmin        ! Latmax       ! Radius    ! relax time   ! dep min    ! dep max    !
-        !  deg E     ! deg E        !  deg N        ! Deg N        !  km       !   days       !  m         !   m        !
-        zlon1 = -7.  ; zlon2 = -7.  ;  zlat1 = 36.0 ; zlat2 = 36.0 ; zbw = 80. ; ztrelax = 6. ; zd1 = 600. ; zd2 = 1300.
- 
-        CALL resto_patch ( zlon1, zlon2, zlat1, zlat2, zbw, ztrelax, presto , zd1, zd2 )
- 
-        ! Bab El Mandeb  ( all water column )
-        ! Lonmin     ! Lonmax       ! Latmin        ! Latmax       ! Radius    ! relax time   ! dep min    ! dep max    !
-        !  deg E     ! deg E        !  deg N        ! Deg N        !  km       !   days       !  m         !   m        !
-        zlon1=44.75  ; zlon2 =44.75 ;  zlat1 = 11.5 ; zlat2 = 11.5 ; zbw =100. ; ztrelax = 6. ; zd1 = 0.   ; zd2 = 6000.!
- 
-        CALL resto_patch ( zlon1, zlon2, zlat1, zlat2, zbw, ztrelax, presto , zd1, zd2 )
- 
-        ! Ormuz Strait  ( all water column )
-        ! Lonmin     ! Lonmax       ! Latmin        ! Latmax       ! Radius    ! relax time   ! dep min    ! dep max    !
-        !  deg E     ! deg E        !  deg N        ! Deg N        !  km       !   days       !  m         !   m        !
-        zlon1=57.75  ; zlon2 =57.75 ;  zlat1 = 25.0 ; zlat2 = 25.0 ; zbw =100. ; ztrelax = 6. ; zd1 = 0.   ; zd2 = 6000.!
- 
-        CALL resto_patch ( zlon1, zlon2, zlat1, zlat2, zbw, ztrelax, presto , zd1, zd2 )
- 
-        !---------------------------------------------------------------------------------------------------------------
-        ! Use a mask_dmp.nc file 
-        IF ( ln_dmpmask ) THEN 
-          ! in this case, a real 0-1 mask is read into mask_dmp.nc file for 3D restoring following 
-          ! particular geometry. This mask is to be build by preprocessing using its own criteria
-          ! eg : used for restoring particular water mass. 
-          ! The typical restoring time scale is introduced here.
-           cfile='dmp_mask.nc'
-           CALL iom_open ( cfile, imask )
-           CALL iom_get ( imask, jpdom_data, 'wdmp', zdct )  ! use zdct as temporary array
-           CALL iom_close (imask)
-           WHERE ( zdct > 1 ) zdct = 0.  !  JMM : WHY ???
-           ! it seems that this where is not well accepted on brodie => replaced by a loop
-           presto(:,:,:) = presto(:,:,:) + zdct(:,:,:)/rn_timsk/86400.
-            IF (lwp) WRITE(numout,*) 'dtacof : read dmp_mask.nc file '
-            IF (lwp) WRITE(numout,*) '~~~~~'
         ENDIF
-        ! Particular cases
-        IF ( cp_cfg == 'natl' ) THEN  ! ALL NATL config have an eastern  Med sea truncated
-          ! Eastern Med Sea truncated in NATL
-          ! Lonmin     ! Lonmax       ! Latmin        ! Latmax       ! Band      ! relax time   !
-          !  deg E     ! deg E        !  deg N        ! Deg N        !  deg      !   days       !
-          zlon1= 20.0  ; zlon2 = 26.0 ;  zlat1 = 28.0 ; zlat2 = 45.0 ; zbw =2.   ; ztrelax = 3. 
- 
-          CALL resto_patch ( zlon1, zlon2, zlat1, zlat2, zbw, ztrelax , presto )
-         
- !         IF ( Agrif_Root() ) THEN
- !         ! Additional modification in case of closed boundary (north and/or south )
- !         IF ( .NOT. lk_obc ) THEN
- !           jrelax = 28 ! number of point for the buffer zone
- !                       ! use resto_patch with lon lat expressed in i,j points, but set ld_ij flag
- !           ztrelax  = 3.
- !           ztvanish= 100.
- !           zv1 = ( ztvanish -  ztrelax ) / ( jrelax  - 1 )
- !           DO jj=1, jrelax
- !              zv2 = 1./ ( ztrelax + ( jj - 1 ) * zv1 ) / 86400.
- !              ! South
- !              presto (:, mj0(jj):mj1(jj)                , :) = zv2
- !              ! North
- !              presto (:, mj0(jpjglo-jj):mj1(jpjglo - jj), :) = zv2
- !           ENDDO
- !         ENDIF
- !         ENDIF  ! agrif root
-        ENDIF
- 
-          !                         !--------------------!
-       ELSE                         !     No damping     !
-          !                         !--------------------!
-          CALL ctl_stop( 'Choose a correct value of nn_hdmp or put ln_tradmp to FALSE' )
-       ENDIF
-       !                            !--------------------------------!
-       IF( kn_file == 1 ) THEN      !  save damping coef. in a file  !
-          !                         !--------------------------------!
-          IF(lwp) WRITE(numout,*) '              create damping.coeff.nc file'
-          IF( cdtype == 'TRA' ) cfile = 'damping.coeff'
-          IF( cdtype == 'TRC' ) cfile = 'damping.coeff.trc'
-          IF( cdtype == 'DYN' ) cfile = 'damping.coeff.dyn'
-          cfile = TRIM( cfile )
-          CALL iom_open  ( cfile, imask, ldwrt = .TRUE., kiolib = jprstlib )
-          CALL iom_rstput( 0, 0, imask, 'Resto', presto )
-          CALL iom_close ( imask )
-       ENDIF
-       !
-       CALL wrk_dealloc( jpi, jpj, jpk, zdct )
-       !
-       IF( nn_timing == 1 )  CALL timing_stop('dtacof')
        !
!    END SUBROUTINE dtacof
! 
!    SUBROUTINE resto_patch ( plon1, plon2, plat1, plat2, pbw ,ptmax, presto, pz1, pz2 )
!       !!------------------------------------------------------------------------
!       !!                 ***  Routine resto_patch  ***
!       !!
!       !! ** Purpose :   modify resto array on a geographically defined zone.
!       !!
!       !! ** Method  :  Use glamt, gphit arrays. If the defined zone is outside 
!       !!              the domain, resto is unchanged. If pz1 and pz2 are provided
!       !!              then plon1, plat1 is taken as the position of a the center
!       !!              of a circle with decay radius is pbw (in km) 
!       !!
!       !! ** Action  : IF not present pz1, pz2 : 
!       !!              - plon1, plon2 : min and max longitude of the zone (Deg)
!       !!              - plat1, plat2 : min and max latitude of the zone (Deg)
!       !!              - pbw : band width of the linear decaying restoring (Deg)
!       !!              - ptmax : restoring time scale for the inner zone (days)
!       !!              IF present pz1 pz2
!       !!              - plon1, plat1 : position of the center of the circle
!       !!              - pbw = radius (km) of the restoring circle
!       !!              - ptmax = time scale at maximum restoring
!       !!              - pz1, pz2 : optional: if used, define the depth range (m)
!       !!                          for restoring. If not all depths are considered
!       !!------------------------------------------------------------------------
!       REAL(wp),                   INTENT(in   ) :: plon1, plon2, plat1, plat2, pbw, ptmax
!       REAL(wp), DIMENSION(:,:,:), INTENT(inout) :: presto 
!       REAL(wp), OPTIONAL, INTENT(in) :: pz1, pz2
!       !!
!       INTEGER :: ji,jj, jk    ! dummy loop index
!       INTEGER :: ik1, ik2     ! limiting vertical index corresponding to pz1,pz2
!       INTEGER :: ij0, ij1, iiO, ii1
!       INTEGER, DIMENSION(1)           :: iloc 
! 
!       REAL(wp) :: zv1, zv2, zv3, zv4, zcoef, ztmp, zdist, zradius2, zcoef2
!       REAL(wp), POINTER, DIMENSION(:,:) :: zpatch
!       REAL(wp), POINTER, DIMENSION(:)   :: zmask
!       !!------------------------------------------------------------------------
!       CALL wrk_alloc( jpk,      zmask  )
!       CALL wrk_alloc( jpi, jpj, zpatch )
!  
!       zpatch = 0._wp
!       zcoef  = 1._wp/ptmax/86400._wp
! 
!       IF (PRESENT (pz1) ) THEN 
!         ! horizontal extent
!         zradius2 = pbw * pbw !  radius squared
!         DO jj = 1, jpj
!           DO ji = 1 , jpi
!             zpatch(ji,jj) =  sin(gphit(ji,jj)*rad)* sin(plat1*rad)  &
!        &                         + cos(gphit(ji,jj)*rad)* cos(plat1*rad)  &
!        &                         * cos(rad*(plon1-glamt(ji,jj)))
!           ENDDO
!         ENDDO
! 
!         WHERE ( abs (zpatch ) > 1 ) zpatch = 1.
!         DO jj = 1, jpj
!           DO ji= 1, jpi 
!              ztmp = zpatch(ji,jj)
!              zdist = atan(sqrt( (1.-ztmp)/(1+ztmp)) )*2.*ra/1000.
!              zpatch(ji,jj) = exp( - zdist*zdist/zradius2 )
!           ENDDO
!         ENDDO
!         ! clean cut off
!         WHERE (ABS(zpatch) < 0.01 ) zpatch = 0.
!         ! Vertical limitation
!         zmask = 1.
!         WHERE ( gdept_1d < pz1 .OR. gdept_1d > pz2 ) zmask = 0.
!         iloc=MAXLOC(zmask) ; ik1 = iloc(1)
!         zmask(1:ik1) = 1.
!         iloc=MAXLOC(zmask) ; ik2 = iloc(1) - 1
!         zmask(1:ik1) = 1.
!         iloc=MAXLOC(zmask) ; ik2 = iloc(1) - 1
!         IF (ik2 > 2 ) THEN
!           zmask = 0._wp
!           zmask(ik1       ) = 0.25_wp
!           zmask(ik1+1     ) = 0.75_wp
!           zmask(ik1+2:ik2-2) = 1.0_wp
!           zmask(ik2-1     ) = 0.75_wp
!           zmask(ik2       ) = 0.25_wp
!         ELSE
!           zmask = 1.   ! all the water column is restored the same
!         ENDIF
! 
!         DO jk=1, jpk
!           presto(:,:,jk)= presto(:,:,jk) + zpatch * zcoef * zmask(jk) 
!         ENDDO
!         ! JMM : eventually add some checking to avoid locally large resto.
! 
!       ELSE
!         ! horizontal extent
!         zcoef2=1./(pbw +1.e-20 ) ! to avoid division by 0
!         DO jj=1,jpj
!           DO ji=1,jpi
!              zv1=MAX(0., zcoef2*( glamt(ji,jj) - plon1)  )
!              zv2=MAX(0., zcoef2*( plon2 - glamt(ji,jj))  )
!              zv3=MAX(0., zcoef2*( gphit(ji,jj) - plat1)  )
!              zv4=MAX(0., zcoef2*( plat2 - gphit(ji,jj))  )
!              zpatch(ji,jj)= MIN( 1., MIN( 1., zv1,zv2,zv3,zv4 ) )
!           ENDDO
!         ENDDO
!           ! resto all over the water column
!           presto(:,:,1)= presto(:,:,1) + zpatch *zcoef
!           WHERE (zpatch /= 0 ) presto(:,:,1) = MIN( presto(:,:,1), zcoef )
!           DO jk=2, jpk
!              presto(:,:,jk)=presto(:,:,1)
!           ENDDO
!       ENDIF
!       !
!       CALL wrk_dealloc( jpk,       zmask  )
!       CALL wrk_dealloc( jpi, jpj , zpatch )
!       !
!    END SUBROUTINE resto_patch
  
  END MODULE tradmp
--- 210,231 ----
           CASE DEFAULT
              CALL ctl_stop('tra_dmp_init : wrong value of nn_zdmp')
           END SELECT
!          !
!          !!TG: Initialisation of dtatsd - Would it be better to have dmpdta routine
!          !    so can damp to something other than intitial conditions files?
!          !!gm: In principle yes. Nevertheless, we can't anticipate demands that have never been formulated.
           IF( .NOT.ln_tsd_tradmp ) THEN
!             IF(lwp) WRITE(numout,*)
!             IF(lwp) WRITE(numout, *)  '   read T-S data not initialized, we force ln_tsd_tradmp=T'
              CALL dta_tsd_init( ld_tradmp=ln_tradmp )        ! forces the initialisation of T-S data
           ENDIF
!          !                          ! Read in mask from file
           CALL iom_open ( cn_resto, imask)
!          CALL iom_get  ( imask, jpdom_autoglo, 'resto', resto )
           CALL iom_close( imask )
        ENDIF
        !
!    END SUBROUTINE tra_dmp_init
  
+    !!======================================================================
  END MODULE tradmp
Only in /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/TRD: .gitkeep
diff -bic /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/ZDF/zdftke.F90 /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/ZDF/zdftke.F90
*** /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/ZDF/zdftke.F90	Tue Apr  4 14:56:58 2017
--- /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/ZDF/zdftke.F90	Fri Feb 24 15:39:23 2017
***************
*** 97,108 ****
     REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:,:) ::   e_pdl, e_ric   !: prandl and local Richardson numbers
  #endif
  
-    !{ DRAKKAR customization 
-    REAL(wp) ::   rn_ebbice      ! coefficient of the surface input of tke under ice
-    INTEGER  ::   nn_havti       ! background modified under ice or not (0/1)
-    !! local module variable used in 2 routines 
-    REAL(wp), ALLOCATABLE, SAVE, DIMENSION(:,:)          ::   ziceavtb! avtb background variation under ice
-    !}
     !! * Substitutions
  #  include "vectopt_loop_substitute.h90"
     !!----------------------------------------------------------------------
--- 97,102 ----
***************
*** 121,127 ****
           &      e_dis(jpi,jpj,jpk) , e_mix(jpi,jpj,jpk) ,                          &
           &      e_pdl(jpi,jpj,jpk) , e_ric(jpi,jpj,jpk) ,                          &
  #endif
!          &      htau  (jpi,jpj)    , dissl(jpi,jpj,jpk) ,  ziceavtb(jpi,jpj) ,     &
           &      apdlr(jpi,jpj,jpk) ,   STAT= zdf_tke_alloc      )
           !
        IF( lk_mpp             )   CALL mpp_sum ( zdf_tke_alloc )
--- 115,121 ----
           &      e_dis(jpi,jpj,jpk) , e_mix(jpi,jpj,jpk) ,                          &
           &      e_pdl(jpi,jpj,jpk) , e_ric(jpi,jpj,jpk) ,                          &
  #endif
!          &      htau  (jpi,jpj)    , dissl(jpi,jpj,jpk) ,     & 
           &      apdlr(jpi,jpj,jpk) ,                                           STAT= zdf_tke_alloc      )
           !
        IF( lk_mpp             )   CALL mpp_sum ( zdf_tke_alloc )
***************
*** 178,186 ****
        INTEGER, INTENT(in) ::   kt   ! ocean time step
        !!----------------------------------------------------------------------
        !
- 
-       ! interpolation parent grid => child grid for avm_k ( ex : at west border: update column 1 and 2)
  #if defined key_agrif
        IF( .NOT.Agrif_Root() )   CALL Agrif_Tke
  #endif
        !
--- 172,179 ----
        INTEGER, INTENT(in) ::   kt   ! ocean time step
        !!----------------------------------------------------------------------
        !
  #if defined key_agrif 
+       ! interpolation parent grid => child grid for avm_k ( ex : at west border: update column 1 and 2)
        IF( .NOT.Agrif_Root() )   CALL Agrif_Tke
  #endif
        !
***************
*** 241,248 ****
        REAL(wp), POINTER, DIMENSION(:,:  ) ::   zhlc
        REAL(wp), POINTER, DIMENSION(:,:,:) ::   zpelc, zdiag, zd_up, zd_lw, z3du, z3dv
        REAL(wp)                            ::   zri  !   local Richardson number
-       !{ DRAKKAR modification
-       REAL(wp) ::   zc1, zc2                        ! local scalar
        !!--------------------------------------------------------------------
        !
        IF( nn_timing == 1 )  CALL timing_start('tke_tke')
--- 234,239 ----
***************
*** 251,266 ****
        CALL wrk_alloc( jpi,jpj,       zhlc ) 
        CALL wrk_alloc( jpi,jpj,jpk,   zpelc, zdiag, zd_up, zd_lw, z3du, z3dv ) 
        !
!       ! This 2D coef is used as a multiplying factor for avtb(jk). it is 1 over open ocean 0.1 under ice pack
!       ! to avoid interaction with equatorial disminution of avt, done in zdf_tke_init
!       ziceavtb(:,:) =  avtb_2d
!       IF( nn_havti == 1 ) THEN
!          WHERE( fr_i > 0.01 ) ziceavtb(:,:) =(1. - 0.9 * fr_i(:,:) )       !
!       ENDIF
!       !                                            ! Local constant initialization
!       zc1    =   ( rn_ebb - rn_ebbice ) / rau0
!       zc2    =   rn_ebb / rau0
!       !} 
        zfact1 = -.5_wp * rdt 
        zfact2 = 1.5_wp * rdt * rn_ediss
        zfact3 = 0.5_wp       * rn_ediss
--- 242,248 ----
        CALL wrk_alloc( jpi,jpj,       zhlc ) 
        CALL wrk_alloc( jpi,jpj,jpk,   zpelc, zdiag, zd_up, zd_lw, z3du, z3dv ) 
        !
!       zbbrau = rn_ebb / rau0       ! Local constant initialisation
        zfact1 = -.5_wp * rdt 
        zfact2 = 1.5_wp * rdt * rn_ediss
        zfact3 = 0.5_wp       * rn_ediss
***************
*** 278,286 ****
        END IF
        DO jj = 2, jpjm1            ! en(1)   = rn_ebb taum / rau0  (min value rn_emin0)
           DO ji = fs_2, fs_jpim1   ! vector opt.
-             !{ DRAKKAR : regular disminution from rn_ebb/rau0 (open ocean) to rn_ebbice/rau0 (pack)
-             zbbrau =  zc2 - zc1 * fr_i(ji,jj)
-             !}
              en(ji,jj,1) = MAX( rn_emin0, zbbrau * taum(ji,jj) ) * tmask(ji,jj,1)
           END DO
        END DO
--- 260,265 ----
***************
*** 295,302 ****
        ! The condition is coded here for completion but commented out until there is proof that the
        ! computational cost is justified
        !<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
-       ! JMM : I guess it is the same for the top boundary for ice cavities in case of ln_isfcav
-       ! 
        !                     en(bot)   = (rn_ebb0/rau0)*0.5*sqrt(u_botfr^2+v_botfr^2) (min value rn_emin)
  !!    DO jj = 2, jpjm1
  !!       DO ji = fs_2, fs_jpim1   ! vector opt.
--- 274,279 ----
***************
*** 345,356 ****
                    zind = 0.5 - SIGN( 0.5, gdepw_n(ji,jj,jk) - zhlc(ji,jj) )
                    zwlc = zind * rn_lc * zus * SIN( rpi * gdepw_n(ji,jj,jk) / zhlc(ji,jj) )
                    !                                           ! TKE Langmuir circulation source term
! !CT TKE LC effect reduction
! !                 en(ji,jj,jk) = en(ji,jj,jk) + rdt * (1._wp - fr_i(ji,jj) ) * ( zwlc * zwlc * zwlc )   &
! !                    &                              / zhlc(ji,jj) * wmask(ji,jj,jk) * tmask(ji,jj,1)
!                   en(ji,jj,jk) = en(ji,jj,jk) + rdt * ( MAX(0.,1._wp - 4.*fr_i(ji,jj) ) ) * ( zwlc * zwlc * zwlc ) &
                       &                              / zhlc(ji,jj) * wmask(ji,jj,jk) * tmask(ji,jj,1)
- !CT TKE LC effect reduction
                 END DO
              END DO
           END DO
--- 322,329 ----
                    zind = 0.5 - SIGN( 0.5, gdepw_n(ji,jj,jk) - zhlc(ji,jj) )
                    zwlc = zind * rn_lc * zus * SIN( rpi * gdepw_n(ji,jj,jk) / zhlc(ji,jj) )
                    !                                           ! TKE Langmuir circulation source term
!                   en(ji,jj,jk) = en(ji,jj,jk) + rdt * (1._wp - fr_i(ji,jj) ) * ( zwlc * zwlc * zwlc )   &
                       &                              / zhlc(ji,jj) * wmask(ji,jj,jk) * tmask(ji,jj,1)
                 END DO
              END DO
           END DO
***************
*** 473,487 ****
        !                            !  TKE due to surface and internal wave breaking
        !                            !<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  !!gm BUG : in the exp  remove the depth of ssh !!!
! !  JMM : GM + CL : change behaviour below sea ice : shut down the penetration when ice conc is > 0.25
        
        IF( nn_etau == 1 ) THEN           !* penetration below the mixed layer (rn_efr fraction)
           DO jk = 2, jpkm1
              DO jj = 2, jpjm1
                 DO ji = fs_2, fs_jpim1   ! vector opt.
                    en(ji,jj,jk) = en(ji,jj,jk) + rn_efr * en(ji,jj,1) * EXP( -gdepw_n(ji,jj,jk) / htau(ji,jj) )   &
!                      &                                 * ( MAX(0.,1._wp - 4*fr_i(ji,jj) ))  * wmask(ji,jj,jk) * tmask(ji,jj,1)
! !                    &                                 * ( 1._wp - fr_i(ji,jj) )  * wmask(ji,jj,jk) * tmask(ji,jj,1)
                 END DO
              END DO
           END DO
--- 446,459 ----
        !                            !  TKE due to surface and internal wave breaking
        !                            !<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  !!gm BUG : in the exp  remove the depth of ssh !!!
!       
        
        IF( nn_etau == 1 ) THEN           !* penetration below the mixed layer (rn_efr fraction)
           DO jk = 2, jpkm1
              DO jj = 2, jpjm1
                 DO ji = fs_2, fs_jpim1   ! vector opt.
                    en(ji,jj,jk) = en(ji,jj,jk) + rn_efr * en(ji,jj,1) * EXP( -gdepw_n(ji,jj,jk) / htau(ji,jj) )   &
!                      &                                 * ( 1._wp - fr_i(ji,jj) )  * wmask(ji,jj,jk) * tmask(ji,jj,1)
                 END DO
              END DO
           END DO
***************
*** 490,504 ****
              DO ji = fs_2, fs_jpim1   ! vector opt.
                 jk = nmln(ji,jj)
                 en(ji,jj,jk) = en(ji,jj,jk) + rn_efr * en(ji,jj,1) * EXP( -gdepw_n(ji,jj,jk) / htau(ji,jj) )   &
!                      &                                 * ( MAX(0.,1._wp - 4*fr_i(ji,jj) ))  * wmask(ji,jj,jk) * tmask(ji,jj,1)
! !                 &                                 * ( 1._wp - fr_i(ji,jj) )  * wmask(ji,jj,jk) * tmask(ji,jj,1)
              END DO
           END DO
        ELSEIF( nn_etau == 3 ) THEN       !* penetration belox the mixed layer (HF variability)
-          !{ DRAKKAR : JMM : not convinced 
-          zbbrau = rn_ebb / rau0         ! ice is taken into account
-          ! yes but in this case we use rn_ebb instead of rn_ebbice ...
-          !}
           DO jk = 2, jpkm1
              DO jj = 2, jpjm1
                 DO ji = fs_2, fs_jpim1   ! vector opt.
--- 462,471 ----
              DO ji = fs_2, fs_jpim1   ! vector opt.
                 jk = nmln(ji,jj)
                 en(ji,jj,jk) = en(ji,jj,jk) + rn_efr * en(ji,jj,1) * EXP( -gdepw_n(ji,jj,jk) / htau(ji,jj) )   &
!                   &                                 * ( 1._wp - fr_i(ji,jj) )  * wmask(ji,jj,jk) * tmask(ji,jj,1)
              END DO
           END DO
        ELSEIF( nn_etau == 3 ) THEN       !* penetration belox the mixed layer (HF variability)
           DO jk = 2, jpkm1
              DO jj = 2, jpjm1
                 DO ji = fs_2, fs_jpim1   ! vector opt.
***************
*** 508,515 ****
                    zdif = taum(ji,jj) - ztau                            ! mean of modulus - modulus of the mean 
                    zdif = rhftau_scl * MAX( 0._wp, zdif + rhftau_add )  ! apply some modifications...
                    en(ji,jj,jk) = en(ji,jj,jk) + zbbrau * zdif * EXP( -gdepw_n(ji,jj,jk) / htau(ji,jj) )   &
!                      &                                 * ( MAX(0.,1._wp - 4*fr_i(ji,jj) ))  * wmask(ji,jj,jk) * tmask(ji,jj,1)
! !                     &                        * ( 1._wp - fr_i(ji,jj) ) * wmask(ji,jj,jk) * tmask(ji,jj,1)
                 END DO
              END DO
           END DO
--- 475,481 ----
                    zdif = taum(ji,jj) - ztau                            ! mean of modulus - modulus of the mean 
                    zdif = rhftau_scl * MAX( 0._wp, zdif + rhftau_add )  ! apply some modifications...
                    en(ji,jj,jk) = en(ji,jj,jk) + zbbrau * zdif * EXP( -gdepw_n(ji,jj,jk) / htau(ji,jj) )   &
!                      &                        * ( 1._wp - fr_i(ji,jj) ) * wmask(ji,jj,jk) * tmask(ji,jj,1)
                 END DO
              END DO
           END DO
***************
*** 694,702 ****
                 zsqen = SQRT( en(ji,jj,jk) )
                 zav   = rn_ediff * zmxlm(ji,jj,jk) * zsqen
                 avm  (ji,jj,jk) = MAX( zav,                   avmb(jk) ) * wmask(ji,jj,jk)
!                !{ DRAKKAR 
!                avt  (ji,jj,jk) = MAX( zav, ziceavtb(ji,jj) * avtb(jk) ) * wmask(ji,jj,jk)
!                !}
                 dissl(ji,jj,jk) = zsqen / zmxld(ji,jj,jk)
              END DO
           END DO
--- 660,666 ----
                 zsqen = SQRT( en(ji,jj,jk) )
                 zav   = rn_ediff * zmxlm(ji,jj,jk) * zsqen
                 avm  (ji,jj,jk) = MAX( zav,                  avmb(jk) ) * wmask(ji,jj,jk)
!                avt  (ji,jj,jk) = MAX( zav, avtb_2d(ji,jj) * avtb(jk) ) * wmask(ji,jj,jk)
                 dissl(ji,jj,jk) = zsqen / zmxld(ji,jj,jk)
              END DO
           END DO
***************
*** 764,772 ****
           &                 rn_emin0, rn_bshear, nn_mxl , ln_mxl0  ,   &
           &                 rn_mxl0 , nn_pdl   , ln_lc  , rn_lc    ,   &
           &                 nn_etau , nn_htau  , rn_efr   
- !{ DRAKKAR add
-       NAMELIST/namzdf_tke/ rn_ebbice, nn_havti
- !}
        !!----------------------------------------------------------------------
        !
        REWIND( numnam_ref )              ! Namelist namzdf_tke in reference namelist : Turbulent Kinetic Energy
--- 728,733 ----
***************
*** 800,809 ****
           WRITE(numout,*) '      coef. to compute avt                        rn_ediff  = ', rn_ediff
           WRITE(numout,*) '      Kolmogoroff dissipation coef.               rn_ediss  = ', rn_ediss
           WRITE(numout,*) '      tke surface input coef.                     rn_ebb    = ', rn_ebb
-          !{ DRAKKAR
-          WRITE(numout,*) '      tke surface input coef under ice            rn_ebbice = ', rn_ebbice
-          WRITE(numout,*) '      horizontal variation for avtb under ice     nn_havti  = ', nn_havti
-          !}
           WRITE(numout,*) '      minimum value of tke                        rn_emin   = ', rn_emin
           WRITE(numout,*) '      surface minimum value of tke                rn_emin0  = ', rn_emin0
           WRITE(numout,*) '      background shear (>0)                       rn_bshear = ', rn_bshear
--- 761,766 ----
diff -bic /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/ZDF/zdftmx.F90 /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/ZDF/zdftmx.F90
*** /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/ZDF/zdftmx.F90	Tue Apr  4 14:51:16 2017
--- /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/ZDF/zdftmx.F90	Fri Feb 24 15:39:23 2017
***************
*** 27,33 ****
     USE wrk_nemo       ! work arrays
     USE timing         ! Timing
     USE lib_fortran    ! Fortran utilities (allows no signed zero when 'key_nosignedzero' defined)  
!    USE fldread        ! for file management
     IMPLICIT NONE
     PRIVATE
  
--- 27,33 ----
     USE wrk_nemo       ! work arrays
     USE timing         ! Timing
     USE lib_fortran    ! Fortran utilities (allows no signed zero when 'key_nosignedzero' defined)  
! 
     IMPLICIT NONE
     PRIVATE
  
***************
*** 53,59 ****
  #  include "vectopt_loop_substitute.h90"
     !!----------------------------------------------------------------------
     !! NEMO/OPA 3.7 , NEMO Consortium (2014)
!    !! $Id: zdftmx.F90 5130 2015-03-05 19:59:13Z smasson $
     !! Software governed by the CeCILL licence     (NEMOGCM/NEMO_CeCILL.txt)
     !!----------------------------------------------------------------------
  CONTAINS
--- 53,59 ----
  #  include "vectopt_loop_substitute.h90"
     !!----------------------------------------------------------------------
     !! NEMO/OPA 3.7 , NEMO Consortium (2014)
!    !! $Id: zdftmx.F90 6497 2016-04-27 07:33:46Z gm $
     !! Software governed by the CeCILL licence     (NEMOGCM/NEMO_CeCILL.txt)
     !!----------------------------------------------------------------------
  CONTAINS
***************
*** 354,374 ****
        INTEGER  ::   inum         ! local integer
        INTEGER  ::   ios
        REAL(wp) ::   ztpc, ze_z   ! local scalars
!       REAL(wp) ::   ztpmn, ztpmx ! local scalars
!       REAL(wp), DIMENSION(:,:)  , POINTER ::  zem2, zek1 ,zes2   ! read M2 and K1 tidal energy
        REAL(wp), DIMENSION(:,:)  , POINTER ::  zkz                ! total M2, K1 and S2 tidal energy
        REAL(wp), DIMENSION(:,:)  , POINTER ::  zfact              ! used for vertical structure function
        REAL(wp), DIMENSION(:,:)  , POINTER ::  zhdep              ! Ocean depth 
        REAL(wp), DIMENSION(:,:,:), POINTER ::  zpc, zav_tide               ! power consumption
-       TYPE(FLD_N) :: sn_mskitf, sn_m2, sn_s2, sn_k1
        !!
!       NAMELIST/namzdf_tmx/ rn_htmx, rn_n2min, rn_tfe, rn_me, ln_tmx_itf, rn_tfe_itf,     &
!          &    sn_mskitf, sn_m2, sn_s2, sn_k1
        !!----------------------------------------------------------------------
        !
        IF( nn_timing == 1 )  CALL timing_start('zdf_tmx_init')
        !
!       CALL wrk_alloc( jpi,jpj, zem2, zes2, zek1, zkz, zfact, zhdep )
        !
        REWIND( numnam_ref )             ! Namelist namzdf_tmx in reference namelist : Tidal Mixing
        READ  ( numnam_ref, namzdf_tmx, IOSTAT = ios, ERR = 901)
--- 354,372 ----
        INTEGER  ::   inum         ! local integer
        INTEGER  ::   ios
        REAL(wp) ::   ztpc, ze_z   ! local scalars
!       REAL(wp), DIMENSION(:,:)  , POINTER ::  zem2, zek1     ! read M2 and K1 tidal energy
        REAL(wp), DIMENSION(:,:)  , POINTER ::  zkz            ! total M2, K1 and S2 tidal energy
        REAL(wp), DIMENSION(:,:)  , POINTER ::  zfact          ! used for vertical structure function
        REAL(wp), DIMENSION(:,:)  , POINTER ::  zhdep          ! Ocean depth 
        REAL(wp), DIMENSION(:,:,:), POINTER ::  zpc, zav_tide  ! power consumption
        !!
!       NAMELIST/namzdf_tmx/ rn_htmx, rn_n2min, rn_tfe, rn_me, ln_tmx_itf, rn_tfe_itf
        !!----------------------------------------------------------------------
        !
        IF( nn_timing == 1 )  CALL timing_start('zdf_tmx_init')
        !
!       CALL wrk_alloc( jpi,jpj,       zem2, zek1, zkz, zfact, zhdep )
!       CALL wrk_alloc( jpi,jpj,jpk,   zpc, zav_tide )
        !
        REWIND( numnam_ref )             ! Namelist namzdf_tmx in reference namelist : Tidal Mixing
        READ  ( numnam_ref, namzdf_tmx, IOSTAT = ios, ERR = 901)
***************
*** 395,428 ****
        IF( zdf_tmx_alloc() /= 0 )   CALL ctl_stop( 'STOP', 'zdf_tmx_init : unable to allocate tmx arrays' )
  
        IF( ln_tmx_itf ) THEN          ! read the Indonesian Through Flow mask
!          CALL iom_open  (sn_mskitf%clname, inum)
!          CALL iom_get   (inum, jpdom_data, sn_mskitf%clvar, mask_itf,1) ! 
!          CALL iom_close (inum)
        ENDIF
! 
!       ! read M2 tidal energy flux : W/m2  ( zem2 < 0 )
!       CALL iom_open  (sn_m2%clname, inum)
!       CALL iom_get   (inum, jpdom_data, sn_m2%clvar,  zem2,1) ! 
!       WHERE ( zem2 > 0.d0 ) zem2 = 0.d0
!       CALL iom_close (inum)
! 
!       ! read S2 tidal energy flux : W/m2  ( zes2 < 0 )
!       CALL iom_open  (sn_s2%clname, inum)
!       CALL iom_get   (inum, jpdom_data, sn_s2%clvar,  zes2,1) ! 
!       WHERE ( zes2 > 0.d0 ) zes2 = 0.d0
!       CALL iom_close (inum)
! 
!       ! read K1 tidal energy flux : W/m2  ( zek1 < 0 )
!       CALL iom_open  (sn_k1%clname, inum)
!       CALL iom_get   (inum, jpdom_data, sn_k1%clvar,  zek1,1) ! 
!       WHERE ( zek1 > 0.d0 ) zek1 = 0.d0
!       CALL iom_close (inum)
!  
!       ! Total tidal energy ( M2, S2 and K1  with S2=(1/2)^2 * M2 )
!       ! only the energy available for mixing is taken into account,
!       ! (mixing efficiency tidal dissipation efficiency)
!       !  zes2(:,:) = zem2(:,:) * 0.25   !  if no specific field for S2
!       en_tmx(:,:) = - rn_tfe * rn_me * ( zem2(:,:) + zes2(:,:) + zek1(:,:) ) * ssmask(:,:)
  
  !============
  !TG: Bug for VVL? Should this section be moved out of _init and be updated at every timestep?
--- 393,414 ----
        IF( zdf_tmx_alloc() /= 0 )   CALL ctl_stop( 'STOP', 'zdf_tmx_init : unable to allocate tmx arrays' )
  
        IF( ln_tmx_itf ) THEN            ! read the Indonesian Through Flow mask
!          CALL iom_open('mask_itf',inum)
!          CALL iom_get (inum, jpdom_data, 'tmaskitf',mask_itf,1) ! 
!          CALL iom_close(inum)
        ENDIF
!       !                                ! read M2 tidal energy flux : W/m2  ( zem2 < 0 )
!       CALL iom_open('M2rowdrg',inum)
!       CALL iom_get (inum, jpdom_data, 'field',zem2,1) ! 
!       CALL iom_close(inum)
!       !                                ! read K1 tidal energy flux : W/m2  ( zek1 < 0 )
!       CALL iom_open('K1rowdrg',inum)
!       CALL iom_get (inum, jpdom_data, 'field',zek1,1) ! 
!       CALL iom_close(inum)
!       !                                ! Total tidal energy ( M2, S2 and K1  with S2=(1/2)^2 * M2 )
!       !                                ! only the energy available for mixing is taken into account,
!       !                                ! (mixing efficiency tidal dissipation efficiency)
!       en_tmx(:,:) = - rn_tfe * rn_me * ( zem2(:,:) * 1.25 + zek1(:,:) ) * ssmask(:,:)
  
  !============
  !TG: Bug for VVL? Should this section be moved out of _init and be updated at every timestep?
***************
*** 445,457 ****
        END DO
  !===========
        !
!       IF( nprint == 1 ) THEN
           ! Control print
           ! Total power consumption due to vertical mixing
           ! zpc = rau0 * 1/rn_me * rn2 * zav_tide
-          !
-          CALL wrk_alloc( jpi,jpj,jpk,   zpc, zav_tide )
-          !
           zav_tide(:,:,:) = 0.e0
           DO jk = 2, jpkm1
              zav_tide(:,:,jk) = az_tmx(:,:,jk) / MAX( rn_n2min, rn2(:,:,jk) )
--- 431,440 ----
        END DO
  !===========
        !
!       IF( nprint == 1 .AND. lwp ) THEN
           ! Control print
           ! Total power consumption due to vertical mixing
           ! zpc = rau0 * 1/rn_me * rn2 * zav_tide
           zav_tide(:,:,:) = 0.e0
           DO jk = 2, jpkm1
              zav_tide(:,:,jk) = az_tmx(:,:,jk) / MAX( rn_n2min, rn2(:,:,jk) )
***************
*** 469,476 ****
           IF( lk_mpp )   CALL mpp_sum( ztpc )
           ztpc= rau0 * 1/(rn_tfe * rn_me) * ztpc
           !
!          IF (lwp) WRITE(numout,*) 
!          IF (lwp) WRITE(numout,*) '          Total power consumption of the tidally driven part of Kz : ztpc = ', ztpc * 1.e-12 ,'TW'
           !
           ! control print 2
           zav_tide(:,:,:) = MIN( zav_tide(:,:,:), 60.e-4 )   
--- 452,459 ----
           IF( lk_mpp )   CALL mpp_sum( ztpc )
           ztpc= rau0 * 1/(rn_tfe * rn_me) * ztpc
           !
!          WRITE(numout,*) 
!          WRITE(numout,*) '          Total power consumption of the tidally driven part of Kz : ztpc = ', ztpc * 1.e-12 ,'TW'
           !
           ! control print 2
           zav_tide(:,:,:) = MIN( zav_tide(:,:,:), 60.e-4 )   
***************
*** 487,504 ****
              END DO
           END DO
           ztpc  =  1.e50
-          ztpmx = -1.e50
           DO jj = 1, jpj
              DO ji = 1, jpi
                 IF( zkz(ji,jj) /= 0.e0 )   THEN
!                    ztpc  = MIN( zkz(ji,jj), ztpc )
                 ENDIF
-                ztpmx = MAX( zkz(ji,jj), ztpmx )
              END DO
           END DO
!          IF( lk_mpp )   CALL mpp_min( ztpc  )
!          IF( lk_mpp )   CALL mpp_max( ztpmx )
!          IF (lwp) WRITE(numout,*) '          Min de zkz ', ztpc, ' Max = ', ztpmx
           !
           DO jk = 2, jpkm1
              zav_tide(:,:,jk) = zav_tide(:,:,jk) * MIN( zkz(:,:), 30./6. ) * wmask(:,:,jk)  !kz max = 300 cm2/s
--- 470,483 ----
              END DO
           END DO
           ztpc = 1.e50
           DO jj = 1, jpj
              DO ji = 1, jpi
                 IF( zkz(ji,jj) /= 0.e0 )   THEN
!                    ztpc = Min( zkz(ji,jj), ztpc)
                 ENDIF
              END DO
           END DO
!          WRITE(numout,*) '          Min de zkz ', ztpc, ' Max = ', maxval(zkz(:,:) )
           !
           DO jk = 2, jpkm1
              zav_tide(:,:,jk) = zav_tide(:,:,jk) * MIN( zkz(:,:), 30./6. ) * wmask(:,:,jk)  !kz max = 300 cm2/s
***************
*** 514,581 ****
           END DO
           IF( lk_mpp )   CALL mpp_sum( ztpc )
           ztpc= rau0 * 1/(rn_tfe * rn_me) * ztpc
!          IF(lwp) WRITE(numout,*) '          2 Total power consumption of the tidally driven part of Kz : ztpc = ', ztpc * 1.e-12 ,'TW'
!          !
           DO jk = 1, jpk
!             ze_z = SUM( e1e2t(:,:) * zav_tide(:,:,jk) * tmask_i(:,:) )
!             ztpc = SUM( e1e2t(:,:) * wmask   (:,:,jk) * tmask_i(:,:) )
!             IF( lk_mpp )   CALL mpp_sum( ze_z  )
!             IF( lk_mpp )   CALL mpp_sum( ztpc )
!             ze_z  =  ze_z / MAX( 1.e-20, ztpc )
!             ztpmn =  1.e50
!             ztpmx = -1.e50
              DO jj = 1, jpj
                 DO ji = 1, jpi
!                   IF( zav_tide(ji,jj,jk) /= 0.e0 )   ztpmn = MIN( ztpmn, zav_tide(ji,jj,jk) )
                 END DO
-                ztpmx = MAX( zav_tide(ji,jj,jk), ztpmx )
              END DO
!             IF( lk_mpp )   CALL mpp_min( ztpmn )
!             IF( lk_mpp )   CALL mpp_max( ztpmx )
!             IF(lwp) WRITE(numout,*) '            N2 min - jk= ', jk,'   ', ze_z * 1.e4, &
!                &                    ' cm2/s min= ',ztpmn*1.e4, 'max= ', ztpmx*1.e4, ' cm2/s'
           END DO
!          !
!          ztpc = SUM( e1e2t*en_tmx )
!          IF( lk_mpp )   CALL mpp_sum( ztpc )
!          IF(lwp) WRITE(numout,*) '          e_tide : ', ztpc / ( rn_tfe * rn_me ) * 1.e-12, 'TW'
!          IF(lwp) WRITE(numout,*) 
!          IF(lwp) WRITE(numout,*) '          Initial profile of tidal vertical mixing'
           DO jk = 1, jpk
              DO jj = 1,jpj
                 DO ji = 1,jpi
                    zkz(ji,jj) = az_tmx(ji,jj,jk) /MAX( rn_n2min, rn2(ji,jj,jk) )
                 END DO
              END DO
!             ze_z  = SUM( e1e2t(:,:) * zkz(:,:) * tmask_i(:,:) )
!             ztpc  = SUM( e1e2t(:,:) * wmask(:,:,jk) * tmask_i(:,:) )
!             IF( lk_mpp )   CALL mpp_sum( ze_z )
!             IF( lk_mpp )   CALL mpp_sum( ztpc )
!             ze_z  =  ze_z / MAX( 1.e-20, ztpc )
!             IF(lwp) WRITE(numout,*) '                jk= ', jk,'   ', ze_z * 1.e4,' cm2/s'
           END DO
-          !
           DO jk = 1, jpk
!             zkz(:,:) = az_tmx(:,:,jk) / rn_n2min
!             ztpmx = MAXVAL( zkz )
!             ztpmn = MINVAL( zkz )
!             ze_z  = SUM( e1e2t(:,:) * zkz(:,:) * tmask_i(:,:) )
!             ztpc  = SUM( e1e2t(:,:) * wmask(:,:,jk) * tmask_i(:,:) )
!             IF( lk_mpp )   CALL mpp_sum( ze_z  )
!             IF( lk_mpp )   CALL mpp_sum( ztpc  )
!             IF( lk_mpp )   CALL mpp_max( ztpmx )
!             IF( lk_mpp )   CALL mpp_min( ztpmn )
!             ze_z  =  ze_z / MAX( 1.e-20, ztpc )
!             IF(lwp) WRITE(numout,*) 
!             IF(lwp) WRITE(numout,*) '          N2 min - jk= ', jk,'   ', ze_z * 1.e4, &
!                &                    ' cm2/s min= ',ztpmn*1.e4, 'max= ', ztpc*1.e4, ' cm2/s'
           END DO
           !
-          CALL wrk_dealloc( jpi,jpj,jpk, zpc, zav_tide )
        ENDIF
- 
        !
!       CALL wrk_dealloc( jpi,jpj, zem2, zek1, zes2, zkz, zfact, zhdep )
        !
        IF( nn_timing == 1 )  CALL timing_stop('zdf_tmx_init')
        !
--- 493,540 ----
           END DO
           IF( lk_mpp )   CALL mpp_sum( ztpc )
           ztpc= rau0 * 1/(rn_tfe * rn_me) * ztpc
!          WRITE(numout,*) '          2 Total power consumption of the tidally driven part of Kz : ztpc = ', ztpc * 1.e-12 ,'TW'
! !!gm bug mpp  in these diagnostics
           DO jk = 1, jpk
!             ze_z =                  SUM( e1e2t(:,:) * zav_tide(:,:,jk) * tmask_i(:,:) )   &
!                &     / MAX( 1.e-20, SUM( e1e2t(:,:) * wmask   (:,:,jk) * tmask_i(:,:) ) )
!             ztpc = 1.e50
              DO jj = 1, jpj
                 DO ji = 1, jpi
!                   IF( zav_tide(ji,jj,jk) /= 0.e0 )   ztpc = MIN( ztpc, zav_tide(ji,jj,jk) )
                 END DO
              END DO
!             WRITE(numout,*) '            N2 min - jk= ', jk,'   ', ze_z * 1.e4,' cm2/s min= ',ztpc*1.e4,   &
!                &       'max= ', MAXVAL(zav_tide(:,:,jk) )*1.e4, ' cm2/s'
           END DO
! 
!          WRITE(numout,*) '          e_tide : ', SUM( e1e2t*en_tmx ) / ( rn_tfe * rn_me ) * 1.e-12, 'TW'
!          WRITE(numout,*) 
!          WRITE(numout,*) '          Initial profile of tidal vertical mixing'
           DO jk = 1, jpk
              DO jj = 1,jpj
                 DO ji = 1,jpi
                    zkz(ji,jj) = az_tmx(ji,jj,jk) /MAX( rn_n2min, rn2(ji,jj,jk) )
                 END DO
              END DO
!             ze_z =                  SUM( e1e2t(:,:) * zkz  (:,:)    * tmask_i(:,:) )   &
!                &     / MAX( 1.e-20, SUM( e1e2t(:,:) * wmask(:,:,jk) * tmask_i(:,:) ) )
!             WRITE(numout,*) '                jk= ', jk,'   ', ze_z * 1.e4,' cm2/s'
           END DO
           DO jk = 1, jpk
!             zkz(:,:) = az_tmx(:,:,jk) /rn_n2min
!             ze_z =                  SUM( e1e2t(:,:) * zkz  (:,:)    * tmask_i(:,:) )   &
!                &     / MAX( 1.e-20, SUM( e1e2t(:,:) * wmask(:,:,jk) * tmask_i(:,:) ) )
!             WRITE(numout,*) 
!             WRITE(numout,*) '          N2 min - jk= ', jk,'   ', ze_z * 1.e4,' cm2/s min= ',MINVAL(zkz)*1.e4,   &
!                &       'max= ', MAXVAL(zkz)*1.e4, ' cm2/s'
           END DO
+ !!gm  end bug mpp
           !
        ENDIF
        !
!       CALL wrk_dealloc( jpi,jpj, zem2, zek1, zkz, zfact, zhdep )
!       CALL wrk_dealloc( jpi,jpj,jpk, zpc )
        !
        IF( nn_timing == 1 )  CALL timing_stop('zdf_tmx_init')
        !
***************
*** 635,641 ****
  #  include "vectopt_loop_substitute.h90"
     !!----------------------------------------------------------------------
     !! NEMO/OPA 4.0 , NEMO Consortium (2016)
!    !! $Id: zdftmx.F90 6314 2016-02-15 12:04:56Z cetlod $
     !! Software governed by the CeCILL licence     (NEMOGCM/NEMO_CeCILL.txt)
     !!----------------------------------------------------------------------
  CONTAINS
--- 594,600 ----
  #  include "vectopt_loop_substitute.h90"
     !!----------------------------------------------------------------------
     !! NEMO/OPA 4.0 , NEMO Consortium (2016)
!    !! $Id: zdftmx.F90 6497 2016-04-27 07:33:46Z gm $
     !! Software governed by the CeCILL licence     (NEMOGCM/NEMO_CeCILL.txt)
     !!----------------------------------------------------------------------
  CONTAINS
Common subdirectories: /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/ASM and /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/ASM
Common subdirectories: /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/BDY and /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/BDY
Common subdirectories: /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/C1D and /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/C1D
Common subdirectories: /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/CRS and /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/CRS
Common subdirectories: /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/DIA and /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/DIA
Common subdirectories: /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/DIU and /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/DIU
Common subdirectories: /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/DOM and /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/DOM
Common subdirectories: /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/DYN and /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/DYN
Common subdirectories: /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/FLO and /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/FLO
Common subdirectories: /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/ICB and /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/ICB
Common subdirectories: /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/IOM and /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/IOM
Common subdirectories: /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/LBC and /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/LBC
Common subdirectories: /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/LDF and /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/LDF
Common subdirectories: /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/OBS and /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/OBS
Only in /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/: README
Common subdirectories: /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/SBC and /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/SBC
Only in /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/: SOL
Common subdirectories: /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/STO and /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/STO
Common subdirectories: /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/TRA and /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/TRA
Common subdirectories: /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/TRD and /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/TRD
Common subdirectories: /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/ZDF and /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/ZDF
diff -bic /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/nemogcm.F90 /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/nemogcm.F90
*** /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/nemogcm.F90	Tue Apr  4 14:51:16 2017
--- /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/nemogcm.F90	Fri Feb 24 15:39:23 2017
***************
*** 38,46 ****
     !!   nemo_gcm       : solve ocean dynamics, tracer, biogeochemistry and/or sea-ice
     !!   nemo_init      : initialization of the NEMO system
     !!   nemo_ctl       : initialisation of the contol print
!    !!   nemo_closefile : close remaining open files
     !!   nemo_alloc     : dynamical allocation
!    !!   nemo_partition : calculate MPP domain decomposition
     !!   factorise      : calculate the factors of the no. of MPI processes
     !!----------------------------------------------------------------------
     USE step_oce       ! module used in the ocean time stepping module (step.F90)
--- 38,46 ----
     !!   nemo_gcm      : solve ocean dynamics, tracer, biogeochemistry and/or sea-ice
     !!   nemo_init     : initialization of the NEMO system
     !!   nemo_ctl      : initialisation of the contol print
!    !!   nemo_closefile: close remaining open files
     !!   nemo_alloc    : dynamical allocation
!    !!   nemo_partition: calculate MPP domain decomposition
     !!   factorise     : calculate the factors of the no. of MPI processes
     !!----------------------------------------------------------------------
     USE step_oce       ! module used in the ocean time stepping module (step.F90)
***************
*** 87,94 ****
     USE xios           ! xIOserver
  #endif
     USE crsini          ! initialise grid coarsening utility
!    USE lbcnfd, ONLY: isendto, nsndto, nfsloop, nfeloop ! Setup of north fold exchanges 
!    USE sbc_oce, ONLY: lk_oasis
     USE diatmb          ! Top,middle,bottom output
     USE dia25h          ! 25h mean output
     USE wet_dry         ! Wetting and drying setting   (wad_init routine)
--- 87,94 ----
     USE xios           ! xIOserver
  #endif
     USE crsini         ! initialise grid coarsening utility
!    USE lbcnfd , ONLY  : isendto, nsndto, nfsloop, nfeloop   ! Setup of north fold exchanges 
!    USE sbc_oce, ONLY  : lk_oasis
     USE diatmb          ! Top,middle,bottom output
     USE dia25h          ! 25h mean output
     USE wet_dry         ! Wetting and drying setting   (wad_init routine)
***************
*** 101,112 ****
     PUBLIC   nemo_alloc  ! needed by TAM
  
     CHARACTER(lc) ::   cform_aaa="( /, 'AAAAAAAA', / ) "     ! flag for output listing
-    CHARACTER(lc) ::   cform_bbb="( /, 'BBBBBBBB', / ) "     ! flag for output listing
-    CHARACTER(lc) ::   cform_ccc="( /, ';);););)', / ) "     ! flag for output listing
  
     !!----------------------------------------------------------------------
     !! NEMO/OPA 3.7 , NEMO Consortium (2015)
!    !! $Id: nemogcm.F90 5656 2015-07-31 08:55:56Z timgraham $
     !! Software governed by the CeCILL licence     (NEMOGCM/NEMO_CeCILL.txt)
     !!----------------------------------------------------------------------
  CONTAINS
--- 101,110 ----
     PUBLIC   nemo_alloc  ! needed by TAM
  
     CHARACTER(lc) ::   cform_aaa="( /, 'AAAAAAAA', / ) "     ! flag for output listing
  
     !!----------------------------------------------------------------------
     !! NEMO/OPA 3.7 , NEMO Consortium (2015)
!    !! $Id: nemogcm.F90 6152 2015-12-21 22:33:57Z acc $
     !! Software governed by the CeCILL licence     (NEMOGCM/NEMO_CeCILL.txt)
     !!----------------------------------------------------------------------
  CONTAINS
***************
*** 126,136 ****
        !!              Madec, 2008, internal report, IPSL.
        !!----------------------------------------------------------------------
        INTEGER ::   istp       ! time step index
-       !! for timing each step
-       CHARACTER(LEN=8)      :: cldate
-       CHARACTER(LEN=10)     :: cltime
-       CHARACTER(LEN=5)      :: clzone
-       INTEGER, DIMENSION(8) :: ivalue
        !!----------------------------------------------------------------------
        !
  #if defined key_agrif
--- 124,129 ----
***************
*** 154,160 ****
        ! they will never enter in step and other processes will wait until the end of the cpu time!
        IF( lk_mpp )   CALL mpp_max( nstop )
  
!       IF(lwp) WRITE(numout,cform_bbb)   ! Flag BBBBBB
  
        !                            !-----------------------!
        !                            !==   time stepping   ==!
--- 147,153 ----
        ! they will never enter in step and other processes will wait until the end of the cpu time!
        IF( lk_mpp )   CALL mpp_max( nstop )
  
!       IF(lwp) WRITE(numout,cform_aaa)   ! Flag AAAAAAA
  
        !                            !-----------------------!
        !                            !==   time stepping   ==!
***************
*** 180,191 ****
  #endif
  
           DO WHILE ( istp <= nitend .AND. nstop == 0 )
-             !{ DRAKKAR : print time step for run monitoring
-            IF (lwp ) THEN
-              CALL DATE_AND_TIME(cldate,cltime,clzone,ivalue)
-              print '(i8,1x,8i4)', istp, ivalue(:)   ! DRAKKAR code : print time step for run monitoring
-            ENDIF
-             !}
  #if defined key_agrif
              CALL stp                         ! AGRIF: time stepping
  #else
--- 173,178 ----
***************
*** 207,223 ****
        !                            !------------------------!
        !                            !==  finalize the run  ==!
        !                            !------------------------!
!       !{ DRAKKAR : to have information  for scripts
!       IF(lwp) WRITE(numout,*) 'run stop at : ',ndastp
!       !}
!       IF ( lwp ) THEN 
!       IF( nstop /= 0  ) THEN   ! error print
!          WRITE(numout,cform_ccc)   ! Flag ;);););)
           WRITE(numout,cform_err)
           WRITE(numout,*) nstop, ' error have been found' 
-       ELSE
-          WRITE(numout,cform_aaa)   ! Flag AAAAAAA
-       ENDIF
        ENDIF
        !
  #if defined key_agrif
--- 194,204 ----
        !                            !------------------------!
        !                            !==  finalize the run  ==!
        !                            !------------------------!
!       IF(lwp) WRITE(numout,cform_aaa)   ! Flag AAAAAAA
!       !
!       IF( nstop /= 0 .AND. lwp ) THEN   ! error print
           WRITE(numout,cform_err)
           WRITE(numout,*) nstop, ' error have been found'
        ENDIF
        !
  #if defined key_agrif
***************
*** 351,363 ****
        ! then we calculate them here now that we have our communicator size
        IF( jpni < 1 .OR. jpnj < 1 ) THEN
  #if   defined key_mpp_mpi
!          IF( Agrif_Root() ) CALL nemo_partition(mppsize)
  #else
           jpni  = 1
           jpnj  = 1
           jpnij = jpni*jpnj
  #endif
!       END IF
  
        ! Calculate domain dimensions given calculated jpni and jpnj
        ! This used to be done in par_oce.F90 when they were parameters rather than variables
--- 332,344 ----
        ! then we calculate them here now that we have our communicator size
        IF( jpni < 1 .OR. jpnj < 1 ) THEN
  #if   defined key_mpp_mpi
!          IF( Agrif_Root() )   CALL nemo_partition( mppsize )
  #else
           jpni  = 1
           jpnj  = 1
           jpnij = jpni*jpnj
  #endif
!       ENDIF
  
        ! Calculate domain dimensions given calculated jpni and jpnj
        ! This used to be done in par_oce.F90 when they were parameters rather than variables
***************
*** 366,373 ****
           jpi = ( nx_global+2-2*jpreci + (jpni-1) ) / jpni + 2*jpreci ! first  dim.
           jpj = ( ny_global+2-2*jprecj + (jpnj-1) ) / jpnj + 2*jprecj ! second dim. 
  #else
!          jpi = ( jpiglo-2*jpreci + (jpni-1) ) / jpni + 2*jpreci   ! first  dim.
!          jpj = ( jpjglo-2*jprecj + (jpnj-1) ) / jpnj + 2*jprecj   ! second dim.
  #endif
        ENDIF         
           jpk = jpkdta                                             ! third dim
--- 347,354 ----
           jpi = ( nx_global+2-2*jpreci + (jpni-1) ) / jpni + 2*jpreci    ! first  dim.
           jpj = ( ny_global+2-2*jprecj + (jpnj-1) ) / jpnj + 2*jprecj    ! second dim. 
  #else
!          jpi = ( jpiglo     -2*jpreci + (jpni-1) ) / jpni + 2*jpreci    ! first  dim.
!          jpj = ( jpjglo     -2*jprecj + (jpnj-1) ) / jpnj + 2*jprecj    ! second dim.
  #endif
        ENDIF         
           jpk = jpkdta                                             ! third dim
***************
*** 375,381 ****
           ! simple trick to use same vertical grid as parent but different number of levels: 
           ! Save maximum number of levels in jpkdta, then define all vertical grids with this number.
           ! Suppress once vertical online interpolation is ok
!          IF(.NOT.Agrif_Root()) jpkdta = Agrif_Parent(jpkdta)
  #endif
           jpim1 = jpi-1                                            ! inner domain indices
           jpjm1 = jpj-1                                            !   "           "
--- 356,362 ----
           ! simple trick to use same vertical grid as parent but different number of levels: 
           ! Save maximum number of levels in jpkdta, then define all vertical grids with this number.
           ! Suppress once vertical online interpolation is ok
!          IF(.NOT.Agrif_Root())   jpkdta = Agrif_Parent( jpkdta )
  #endif
           jpim1 = jpi-1                                            ! inner domain indices
           jpjm1 = jpj-1                                            !   "           "
diff -bic /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/stpctl.F90 /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/stpctl.F90
*** /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/stpctl.F90	Tue Apr  4 14:56:58 2017
--- /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/stpctl.F90	Fri Feb 24 15:39:23 2017
***************
*** 27,33 ****
     PUBLIC stp_ctl           ! routine called by step.F90
     !!----------------------------------------------------------------------
     !! NEMO/OPA 3.3 , NEMO Consortium (2010)
!    !! $Id: stpctl.F90 3294 2012-01-28 16:44:18Z rblod $
     !! Software governed by the CeCILL licence (NEMOGCM/NEMO_CeCILL.txt)
     !!----------------------------------------------------------------------
  CONTAINS
--- 27,33 ----
     PUBLIC stp_ctl           ! routine called by step.F90
     !!----------------------------------------------------------------------
     !! NEMO/OPA 3.3 , NEMO Consortium (2010)
!    !! $Id: stpctl.F90 6140 2015-12-21 11:35:23Z timgraham $
     !! Software governed by the CeCILL licence (NEMOGCM/NEMO_CeCILL.txt)
     !!----------------------------------------------------------------------
  CONTAINS
***************
*** 45,51 ****
        !! ** Actions :   'time.step' file containing the last ocean time-step
        !!                
        !!----------------------------------------------------------------------
!       INTEGER, INTENT( in ) ::   kt         ! ocean time-step index
        INTEGER, INTENT(inout) ::   kindic   ! error indicator
        !!
        INTEGER  ::   ji, jj, jk              ! dummy loop indices
--- 45,51 ----
        !! ** Actions :   'time.step' file containing the last ocean time-step
        !!                
        !!----------------------------------------------------------------------
!       INTEGER, INTENT(in   ) ::   kt       ! ocean time-step index
        INTEGER, INTENT(inout) ::   kindic   ! error indicator
        !!
        INTEGER  ::   ji, jj, jk             ! dummy loop indices
***************
*** 79,86 ****
        END DO        
        IF( lk_mpp )   CALL mpp_max( zumax )                 ! max over the global domain
        !
!       IF( MOD( kt, 10  ) == 1 .AND. lwp )   WRITE(numout,*) ' ==>> time-step= ',kt,' abs(U) max: ', zumax
! !     IF( lwp )   WRITE(numout,*) ' ==>> time-step= ',kt,' abs(U) max: ', zumax
        !
        IF( zumax > 20.e0 ) THEN
           IF( lk_mpp ) THEN
--- 79,85 ----
        END DO        
        IF( lk_mpp )   CALL mpp_max( zumax )                 ! max over the global domain
        !
!       IF( MOD( kt, nwrite ) == 1 .AND. lwp )   WRITE(numout,*) ' ==>> time-step= ',kt,' abs(U) max: ', zumax
        !
        IF( zumax > 20.e0 ) THEN
           IF( lk_mpp ) THEN
***************
*** 101,112 ****
           ENDIF
           kindic = -3
        ENDIF
! 9400  FORMAT (' kt=',i8,' max abs(U): ',1pg11.4,', i j k: ',3i5)
! 
        !                                              !* Test minimum of salinity
        !                                              !  ------------------------
        !! zsmin = MINVAL( tsn(:,:,1,jp_sal), mask = tmask(:,:,1) == 1.e0 )  slower than the following loop on NEC SX5
!       zsmin = 100.e0
        DO jj = 2, jpjm1
           DO ji = 1, jpi
              IF( tmask(ji,jj,1) == 1) zsmin = MIN(zsmin,tsn(ji,jj,1,jp_sal))
--- 100,111 ----
           ENDIF
           kindic = -3
        ENDIF
! 9400  FORMAT (' kt=',i6,' max abs(U): ',1pg11.4,', i j k: ',3i5)
!       !
        !                                              !* Test minimum of salinity
        !                                              !  ------------------------
        !! zsmin = MINVAL( tsn(:,:,1,jp_sal), mask = tmask(:,:,1) == 1.e0 )  slower than the following loop on NEC SX5
!       zsmin = 100._wp
        DO jj = 2, jpjm1
           DO ji = 1, jpi
              IF( tmask(ji,jj,1) == 1) zsmin = MIN(zsmin,tsn(ji,jj,1,jp_sal))
***************
*** 114,121 ****
        END DO
        IF( lk_mpp )   CALL mpp_min( zsmin )                ! min over the global domain
        !
!       IF( MOD( kt, 60 ) == 1 .AND. lwp )   WRITE(numout,*) ' ==>> time-step= ',kt,' SSS min:', zsmin
! !     IF( lwp )   WRITE(numout,*) ' ==>> time-step= ',kt,' SSS min:', zsmin
        !
        IF( zsmin < 0.) THEN 
           IF (lk_mpp) THEN
--- 113,119 ----
        END DO
        IF( lk_mpp )   CALL mpp_min( zsmin )                ! min over the global domain
        !
!       IF( MOD( kt, nwrite ) == 1 .AND. lwp )   WRITE(numout,*) ' ==>> time-step= ',kt,' SSS min:', zsmin
        !
        IF( zsmin < 0.) THEN 
           IF (lk_mpp) THEN
***************
*** 136,144 ****
           ENDIF
           kindic = -3
        ENDIF
! 9500  FORMAT (' kt=',i8,' min SSS: ',1pg11.4,', i j: ',2i5)
! 
!       
        IF( lk_c1d )  RETURN          ! No log file in case of 1D vertical configuration
  
        ! log file (ssh statistics)
--- 134,142 ----
           ENDIF
           kindic = -3
        ENDIF
! 9500  FORMAT (' kt=',i6,' min SSS: ',1pg11.4,', i j: ',2i5)
!       !
!       !
        IF( lk_c1d )  RETURN          ! No log file in case of 1D vertical configuration
  
        ! log file (ssh statistics)
diff -bic /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/timing.F90 /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/timing.F90
*** /scratch/cnt0024/hmg2840/albert7a/WNACHOS12.L75-MAA01/NEMO/OPA_SRC/timing.F90	Tue Apr  4 14:51:16 2017
--- /scratch/cnt0024/hmg2840/albert7a/DEV/NEMODRAK_4.0/NEMOREF/NEMOGCM/NEMO/OPA_SRC/timing.F90	Fri Feb 24 15:39:23 2017
***************
*** 77,83 ****
     LOGICAL :: lwriter
     !!----------------------------------------------------------------------
     !! NEMO/OPA 4.0 , NEMO Consortium (2011)
!    !! $Id: timing.F90 5120 2015-03-03 16:11:55Z acc $
     !! Software governed by the CeCILL licence     (NEMOGCM/NEMO_CeCILL.txt)
     !!----------------------------------------------------------------------
  CONTAINS
--- 77,83 ----
     LOGICAL :: lwriter
     !!----------------------------------------------------------------------
     !! NEMO/OPA 4.0 , NEMO Consortium (2011)
!    !! $Id: timing.F90 6981 2016-10-04 12:34:18Z nicolasmartin $
     !! Software governed by the CeCILL licence     (NEMOGCM/NEMO_CeCILL.txt)
     !!----------------------------------------------------------------------
  CONTAINS
***************
*** 321,327 ****
        IF( lwriter ) WRITE(numtime,*) 'Total timing (sum) :'
        IF( lwriter ) WRITE(numtime,*) '--------------------'
        IF( lwriter ) WRITE(numtime,"('Elapsed Time (s)  CPU Time (s)')")
!       IF( lwriter ) WRITE(numtime,'(5x,f13.3,1x,f12.3)')  tot_etime, tot_ctime
        IF( lwriter ) WRITE(numtime,*) 
  #if defined key_mpp_mpi
        IF( ll_averep ) CALL waver_info
--- 321,327 ----
        IF( lwriter ) WRITE(numtime,*) 'Total timing (sum) :'
        IF( lwriter ) WRITE(numtime,*) '--------------------'
        IF( lwriter ) WRITE(numtime,"('Elapsed Time (s)  CPU Time (s)')")
!       IF( lwriter ) WRITE(numtime,'(5x,f12.3,1x,f12.3)')  tot_etime, tot_ctime
        IF( lwriter ) WRITE(numtime,*) 
  #if defined key_mpp_mpi
        IF( ll_averep ) CALL waver_info
***************
*** 491,496 ****
--- 491,498 ----
           s_timer => s_timer%next
        END DO      
  
+          WRITE(*,*) 'ARPDBG: timing: done gathers'
+       
        IF( narea == 1 ) THEN    
           ! Compute some stats
           sl_timer_glob => sl_timer_glob_root
***************
*** 513,518 ****
--- 515,522 ----
              sl_timer_glob => sl_timer_glob%next                                
           END DO
  
+          WRITE(*,*) 'ARPDBG: timing: done computing stats'
+       
           ! reorder the averaged list by CPU time      
           s_wrk => NULL()
           sl_timer_ave => sl_timer_ave_root
